#define FIFTH_FIRST
#ifdef FIFTH_FIRST

/*
	2023_04_04(월)
	String Class file 분리 

*/
// --------------------------------------------------
//	2023 1 학기 STL 4월 03일 TUE 23 Tue 56 ( 5주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include <string>

#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};
	char* p{}; // default nullptr 이다.  // unique_ptr<char> p 로 바꿔서 코딩하여 살려볼것 
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;

public:
	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}
	//String() = default;
	String() {
		print("디폴트 생성");
	}
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사생성자를 코딩했다면 복사할당 연산자도 반드시 코딩해야 한다.???
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}


	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");

		// 꼭 delete 써야힘 
	}

	/*friend String& operator+(const String& _str1, const String& _str2) {
		int len = _str1.len + _str2.len;
		char* p = new char[len];
		for (int i = 0; i < _str1.len; ++i) {
			p[i] = _str1.p[i];
		}
		for (int i = _str1.len; i < len; ++i) {
			p[i] = _str2.p[i];
		}

		String str{p};
		delete[]p;
		return str;

	}*/


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}


	string getString() const {
		return string(p, len);
	}

	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	/*

		** 그림 그리면서 복습해보기 **


	*/

	array<String, 5> news{
		"유재석이", "목숨", "걸어가지고"
	};

	관찰 = true;

	// 이렇게 자면 복사되니까 쓸데없는짓을 많이한다...
	for (String s : news) {
		cout << s << endl;

	}
	// & 를 써야한다. 
	for (String& s : news) {
		cout << s << endl;

	}

	// [문제] : news를 오름차순 정렬하라 
	// 꼭 레퍼런스를 넣자 .... 복사 소멸 엄청함 
	sort(news.begin(), news.end(), [](const String& a, const String& b) {
		return a.getString() < b.getString(); // 오름차순 
		});


	관찰 = false;

	
	MySaveFileCode::Save_File("5주차_1.cpp", "5주차_1.txt");


	//save("STL.cpp");

}
#endif // FIFTH_FIRST

#define FIFTH_FIRST
#ifdef FIFTH_FIRST

/*
	2023_04_04(월)
	String Class file 분리 

*/
// --------------------------------------------------
//	2023 1 학기 STL 4월 03일 TUE 23 Tue 56 ( 5주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

/*
	class String {

		public:
		 === SPECIAL FUNCTION ===
		 / 프로그래머가 작성하지 않으면 컴파일러가 알아서 만들어주는 특징 / 
			* 생성자		,	소멸자
			* 복사생성자	,	복사할당연산자
			* 이동생성자 ,	이동할당연산자
		 ========================
			* 연산자 오버로딩
			* gettor  /  settor
			* 그 외 interface 함수  

	}

*/

#include <iostream>
#include <array>
#include <algorithm>
#include <string>

#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};		// 확보한 자원의 바이트 수  
	char* p{};			// 확보한 자원의 주소  
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;	// 클래스 스태틱

public:


	// 디폴트 생성자   
	String() {
		print("디폴트 생성");
	}

	// 생성자 
	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");
	}

	// 소멸자  
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	// 복사생성자
	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사할당 연산자
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}

	// 이동생성자  
	String(String&& other) {		// && - r_Value Reference  

	}


	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}

	// gettor / settor
	string getString() const {
		return string(p, len);
	}

	// 그 외 함수  
	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	String a{ "12345" };
	
	String b = move(a);
	//String b = a;

	cout << a << endl;
	cout << b << endl;

	MySaveFileCode::Save_File("5주차_1.cpp", "5주차_1.txt");
}
#endif // FIFTH_FIRST

#define FIFTH_FIRST
#ifdef FIFTH_FIRST

/*
	2023_04_04(월)
	String Class file 분리 

*/
// --------------------------------------------------
//	2023 1 학기 STL 4월 03일 TUE 23 Tue 56 ( 5주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

/*
	class String {

		public:
		 === SPECIAL FUNCTION ===
		 / 프로그래머가 작성하지 않으면 컴파일러가 알아서 만들어주는 특징 / 
			* 생성자		,	소멸자
			* 복사생성자	,	복사할당연산자
			* 이동생성자 ,	이동할당연산자
		 ========================
			* 연산자 오버로딩
			* gettor  /  settor
			* 그 외 interface 함수  

	}

*/

#include <iostream>
#include <array>
#include <algorithm>
#include <string>

#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};		// 확보한 자원의 바이트 수  
	char* p{};			// 확보한 자원의 주소  
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;	// 클래스 스태틱

public:


	// 디폴트 생성자   
	String() {
		print("디폴트 생성");
	}

	// 생성자 
	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");
	}

	// 소멸자  
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	// 복사생성자
	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사할당 연산자
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}

	// 이동생성자  
	String(String&& other) {		// && - r_Value Reference  

	}


	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}

	// gettor / settor
	string getString() const {
		return string(p, len);
	}

	// 그 외 함수  
	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	String a{ "12345" };
	
	String b = move(a);
	//String b = a;

	cout << " a : " << a << endl;
	cout << " b : " << b << endl;

	MySaveFileCode::Save_File("5주차_1.cpp", "5주차_1.txt");
}
#endif // FIFTH_FIRST

#define FIFTH_FIRST
#ifdef FIFTH_FIRST

/*
	2023_04_04(월)
	String Class file 분리 

*/
// --------------------------------------------------
//	2023 1 학기 STL 4월 03일 TUE 23 Tue 56 ( 5주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

/*
	class String {

		public:
		 === SPECIAL FUNCTION ===
		 / 프로그래머가 작성하지 않으면 컴파일러가 알아서 만들어주는 특징 / 
			* 생성자		,	소멸자
			* 복사생성자	,	복사할당연산자
			* 이동생성자 ,	이동할당연산자
		 ========================
			* 연산자 오버로딩
			* gettor  /  settor
			* 그 외 interface 함수  

	}

*/

#include <iostream>
#include <array>
#include <algorithm>
#include <string>

#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};		// 확보한 자원의 바이트 수  
	char* p{};			// 확보한 자원의 주소  
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;	// 클래스 스태틱

public:


	// 디폴트 생성자   
	String() {
		print("디폴트 생성");
	}

	// 생성자 
	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");
	}

	// 소멸자  
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	// 복사생성자
	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사할당 연산자
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}

	// 이동생성자  
	String(String&& other) {		// && - r_Value Reference  

	}


	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}

	// gettor / settor
	string getString() const {
		return string(p, len);
	}

	// 그 외 함수  
	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	String a{ "12345" };
	
	String b = move(a);
	//String b = a;

	cout << sizeof(a) << endl;

	cout << " a : " << a << endl;
	cout << " b : " << b << endl;

	MySaveFileCode::Save_File("5주차_1.cpp", "5주차_1.txt");
}
#endif // FIFTH_FIRST

#define FIFTH_FIRST
#ifdef FIFTH_FIRST

/*
	2023_04_04(월)
	String Class file 분리 

*/
// --------------------------------------------------
//	2023 1 학기 STL 4월 03일 TUE 23 Tue 56 ( 5주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

/*
	class String {

		public:
		 === SPECIAL FUNCTION ===
		 / 프로그래머가 작성하지 않으면 컴파일러가 알아서 만들어주는 특징 / 
			* 생성자		,	소멸자
			* 복사생성자	,	복사할당연산자
			* 이동생성자 ,	이동할당연산자
		 ========================
			* 연산자 오버로딩
			* gettor  /  settor
			* 그 외 interface 함수  

	}

*/

#include <iostream>
#include <array>
#include <algorithm>
#include <string>

#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};		// 확보한 자원의 바이트 수  
	char* p{};			// 확보한 자원의 주소  
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;	// 클래스 스태틱

public:


	// 디폴트 생성자   
	String() {
		print("디폴트 생성");
	}

	// 생성자 
	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");
	}

	// 소멸자  
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	// 복사생성자
	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사할당 연산자
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}

	// 이동생성자  
	String(String&& other) {		// && - r_Value Reference  

	}


	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}

	// gettor / settor
	string getString() const {
		return string(p, len);
	}

	// 그 외 함수  
	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	String a{ "12345" };
	
	String b = move(a);
	//String b = a;

	cout << sizeof(String) << endl;

	cout << " a : " << a << endl;
	cout << " b : " << b << endl;

	MySaveFileCode::Save_File("5주차_1.cpp", "5주차_1.txt");
}
#endif // FIFTH_FIRST

#define FIFTH_FIRST
#ifdef FIFTH_FIRST

/*
	2023_04_04(월)
	String Class file 분리 

*/
// --------------------------------------------------
//	2023 1 학기 STL 4월 03일 TUE 23 Tue 56 ( 5주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

/*
	class String {

		public:
		 === SPECIAL FUNCTION ===
		 / 프로그래머가 작성하지 않으면 컴파일러가 알아서 만들어주는 특징 / 
			* 생성자		,	소멸자
			* 복사생성자	,	복사할당연산자
			* 이동생성자 ,	이동할당연산자
		 ========================
			* 연산자 오버로딩
			* gettor  /  settor
			* 그 외 interface 함수  

	}

*/

#include <iostream>
#include <array>
#include <algorithm>
#include <string>

#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};		// 확보한 자원의 바이트 수  
	char* p{};			// 확보한 자원의 주소  
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;	// 클래스 스태틱

public:


	// 디폴트 생성자   
	String() {
		print("디폴트 생성");
	}

	// 생성자 
	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");
	}

	// 소멸자  
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	// 복사생성자
	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사할당 연산자
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}

	// 이동생성자  
	String(String&& other) {		// && - r_Value Reference  

	}


	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}

	// gettor / settor
	string getString() const {
		return string(p, len);
	}

	// 그 외 함수  
	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	String a{ "12345" };
	
	String b = move( a );
	//String b = a;

	cout << sizeof(String) << endl;

	cout << " a : " << a << endl;
	cout << " b : " << b << endl;

	MySaveFileCode::Save_File("5주차_1.cpp", "5주차_1.txt");
}
#endif // FIFTH_FIRST

#define FIFTH_FIRST
#ifdef FIFTH_FIRST

/*
	2023_04_04(월)
	String Class file 분리 

*/
// --------------------------------------------------
//	2023 1 학기 STL 4월 03일 TUE 23 Tue 56 ( 5주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

/*
	class String {

		public:
		 === SPECIAL FUNCTION ===
		 / 프로그래머가 작성하지 않으면 컴파일러가 알아서 만들어주는 특징 / 
			* 생성자		,	소멸자
			* 복사생성자	,	복사할당연산자
			* 이동생성자 ,	이동할당연산자
		 ========================
			* 연산자 오버로딩
			* gettor  /  settor
			* 그 외 interface 함수  

	}

*/

#include <iostream>
#include <array>
#include <algorithm>
#include <string>

#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};		// 확보한 자원의 바이트 수  
	char* p{};			// 확보한 자원의 주소  
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;	// 클래스 스태틱

public:


	// 디폴트 생성자   
	String() {
		print("디폴트 생성");
	}

	// 생성자 
	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");
	}

	// 소멸자  
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	// 복사생성자
	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사할당 연산자
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}

	// 이동생성자  
	String(String&& other) {		// && - r_Value Reference  
		print("이동생성자");


	}

	// 이동 할당 연산자 
	


	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}

	// gettor / settor
	string getString() const {
		return string(p, len);
	}

	// 그 외 함수  
	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	String a{ "12345" };
	
	String b = move( a );
	//String b = a;

	cout << sizeof(String) << endl;

	cout << " a : " << a << endl;
	cout << " b : " << b << endl;

	MySaveFileCode::Save_File("5주차_1.cpp", "5주차_1.txt");
}
#endif // FIFTH_FIRST

#define FIFTH_FIRST
#ifdef FIFTH_FIRST

/*
	2023_04_04(월)
	String Class file 분리 

*/
// --------------------------------------------------
//	2023 1 학기 STL 4월 03일 TUE 23 Tue 56 ( 5주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

/*
	class String {

		public:
		 === SPECIAL FUNCTION ===
		 / 프로그래머가 작성하지 않으면 컴파일러가 알아서 만들어주는 특징 / 
			* 생성자		,	소멸자
			* 복사생성자	,	복사할당연산자
			* 이동생성자 ,	이동할당연산자
		 ========================
			* 연산자 오버로딩
			* gettor  /  settor
			* 그 외 interface 함수  

	}

*/

#include <iostream>
#include <array>
#include <algorithm>
#include <string>

#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};		// 확보한 자원의 바이트 수  
	char* p{};			// 확보한 자원의 주소  
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;	// 클래스 스태틱

public:


	// 디폴트 생성자   
	String() {
		print("디폴트 생성");
	}

	// 생성자 
	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");
	}

	// 소멸자  
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	// 복사생성자
	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사할당 연산자
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}

	// 이동생성자  
	String(String&& other) {		// && - r_Value Reference  
		print("이동생성자");


	}

	// 이동 할당 연산자 
	


	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}

	// gettor / settor
	string getString() const {
		return string(p, len);
	}

	// 그 외 함수  
	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	String a{ "12345" };
	//String b = move( a );
	String b = a;

	cout << sizeof(String) << endl;

	cout << " a : " << a << endl;
	cout << " b : " << b << endl;

	MySaveFileCode::Save_File("5주차_1.cpp", "5주차_1.txt");
}
#endif // FIFTH_FIRST

#define FIFTH_FIRST
#ifdef FIFTH_FIRST

/*
	2023_04_04(월)
	String Class file 분리 

*/
// --------------------------------------------------
//	2023 1 학기 STL 4월 03일 TUE 23 Tue 56 ( 5주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

/*
	class String {

		public:
		 === SPECIAL FUNCTION ===
		 / 프로그래머가 작성하지 않으면 컴파일러가 알아서 만들어주는 특징 / 
			* 생성자		,	소멸자
			* 복사생성자	,	복사할당연산자
			* 이동생성자 ,	이동할당연산자
		 ========================
			* 연산자 오버로딩
			* gettor  /  settor
			* 그 외 interface 함수  

	}

*/

#include <iostream>
#include <array>
#include <algorithm>
#include <string>

#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};		// 확보한 자원의 바이트 수  
	char* p{};			// 확보한 자원의 주소  
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;	// 클래스 스태틱

public:


	// 디폴트 생성자   
	String() {
		print("디폴트 생성");
	}

	// 생성자 
	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");
	}

	// 소멸자  
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	// 복사생성자
	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사할당 연산자
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}

	// 이동생성자  
	String(String&& other) {		// && - r_Value Reference  
		print("이동생성자");


	}

	// 이동 할당 연산자 
	


	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}

	// gettor / settor
	string getString() const {
		return string(p, len);
	}

	// 그 외 함수  
	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	String a{ "12345" };
	String b = move( a );
	//String b = a;

	cout << sizeof(String) << endl;

	cout << " a : " << a << endl;
	cout << " b : " << b << endl;

	MySaveFileCode::Save_File("5주차_1.cpp", "5주차_1.txt");
}
#endif // FIFTH_FIRST

#define FIFTH_FIRST
#ifdef FIFTH_FIRST

/*
	2023_04_04(월)
	String Class file 분리 

*/
// --------------------------------------------------
//	2023 1 학기 STL 4월 03일 TUE 23 Tue 56 ( 5주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

/*
	class String {

		public:
		 === SPECIAL FUNCTION ===
		 / 프로그래머가 작성하지 않으면 컴파일러가 알아서 만들어주는 특징 / 
			* 생성자		,	소멸자
			* 복사생성자	,	복사할당연산자
			* 이동생성자 ,	이동할당연산자
		 ========================
			* 연산자 오버로딩
			* gettor  /  settor
			* 그 외 interface 함수  

	}

*/

#include <iostream>
#include <array>
#include <algorithm>
#include <string>

#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};		// 확보한 자원의 바이트 수  
	char* p{};			// 확보한 자원의 주소  
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;	// 클래스 스태틱

public:


	// 디폴트 생성자   
	String() {
		print("디폴트 생성");
	}

	// 생성자 
	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");
	}

	// 소멸자  
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	// 복사생성자
	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사할당 연산자
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}

	// 이동생성자  
	String(String&& other) {		// && - r_Value Reference  
		print("이동생성자");


	}

	// 이동 할당 연산자 
	


	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}

	// gettor / settor
	string getString() const {
		return string(p, len);
	}

	// 그 외 함수  
	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	String a{ "12345" };
	String b = std::move( a );
	//String b = a;

	cout << sizeof(String) << endl;

	cout << " a : " << a << endl;
	cout << " b : " << b << endl;

	MySaveFileCode::Save_File("5주차_1.cpp", "5주차_1.txt");
}
#endif // FIFTH_FIRST

#define FIFTH_FIRST
#ifdef FIFTH_FIRST

/*
	2023_04_04(월)
	String Class file 분리 

*/
// --------------------------------------------------
//	2023 1 학기 STL 4월 03일 TUE 23 Tue 56 ( 5주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

/*
	class String {

		public:
		 === SPECIAL FUNCTION ===
		 / 프로그래머가 작성하지 않으면 컴파일러가 알아서 만들어주는 특징 / 
			* 생성자		,	소멸자
			* 복사생성자	,	복사할당연산자
			* 이동생성자 ,	이동할당연산자
		 ========================
			* 연산자 오버로딩
			* gettor  /  settor
			* 그 외 interface 함수  

	}

*/

#include <iostream>
#include <array>
#include <algorithm>
#include <string>

#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};		// 확보한 자원의 바이트 수  
	char* p{};			// 확보한 자원의 주소  
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;	// 클래스 스태틱

public:


	// 디폴트 생성자   
	String() {
		print("디폴트 생성");
	}

	// 생성자 
	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");
	}

	// 소멸자  
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	// 복사생성자
	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사할당 연산자
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}

	// 이동생성자  
	String(String&& other) {		// && - r_Value Reference  
		print("이동생성자");


	}

	// 이동 할당 연산자 
	


	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}

	// gettor / settor
	string getString() const {
		return string(p, len);
	}

	// 그 외 함수  
	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	string a{ "12345" };
	string b = std::move( a );
	//String b = a;

	cout << sizeof(String) << endl;

	cout << " a : " << a << endl;
	cout << " b : " << b << endl;

	MySaveFileCode::Save_File("5주차_1.cpp", "5주차_1.txt");
}
#endif // FIFTH_FIRST

#define FIFTH_FIRST
#ifdef FIFTH_FIRST

/*
	2023_04_04(월)
	String Class file 분리 

*/
// --------------------------------------------------
//	2023 1 학기 STL 4월 03일 TUE 23 Tue 56 ( 5주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

/*
	class String {

		public:
		 === SPECIAL FUNCTION ===
		 / 프로그래머가 작성하지 않으면 컴파일러가 알아서 만들어주는 특징 / 
			* 생성자		,	소멸자
			* 복사생성자	,	복사할당연산자
			* 이동생성자 ,	이동할당연산자
		 ========================
			* 연산자 오버로딩
			* gettor  /  settor
			* 그 외 interface 함수  

	}

*/

#include <iostream>
#include <array>
#include <algorithm>
#include <string>

#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};		// 확보한 자원의 바이트 수  
	char* p{};			// 확보한 자원의 주소  
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;	// 클래스 스태틱

public:


	// 디폴트 생성자   
	String() {
		print("디폴트 생성");
	}

	// 생성자 
	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");
	}

	// 소멸자  
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	// 복사생성자
	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사할당 연산자
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}

	// 이동생성자  
	String(String&& other) {		// && - r_Value Reference  
		len = other.len;
		p = other.p;

		// 정리 ( Other 를 정리한다 ) 
		// Other 를 정리하지 않으면 프로그램 사망  

		
		print("이동생성자");
	}

	// 이동 할당 연산자 
	


	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}

	// gettor / settor
	string getString() const {
		return string(p, len);
	}

	// 그 외 함수  
	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	String a{ "12345" };
	String b = std::move( a );
	//String b = a;

	cout << sizeof(String) << endl;

	cout << " a : " << a << endl;
	cout << " b : " << b << endl;

	MySaveFileCode::Save_File("5주차_1.cpp", "5주차_1.txt");

	// dangling pointer - static 포인터 가리킬때 댕글링 걸리면 프로그램 사망 

}
#endif // FIFTH_FIRST

#define FIFTH_FIRST
#ifdef FIFTH_FIRST

/*
	2023_04_04(월)
	String Class file 분리 

*/
// --------------------------------------------------
//	2023 1 학기 STL 4월 03일 TUE 23 Tue 56 ( 5주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

/*
	class String {

		public:
		 === SPECIAL FUNCTION ===
		 / 프로그래머가 작성하지 않으면 컴파일러가 알아서 만들어주는 특징 / 
			* 생성자		,	소멸자
			* 복사생성자	,	복사할당연산자
			* 이동생성자 ,	이동할당연산자
		 ========================
			* 연산자 오버로딩
			* gettor  /  settor
			* 그 외 interface 함수  

	}

*/

#include <iostream>
#include <array>
#include <algorithm>
#include <string>

#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};		// 확보한 자원의 바이트 수  
	char* p{};			// 확보한 자원의 주소  
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;	// 클래스 스태틱

public:


	// 디폴트 생성자   
	String() {
		print("디폴트 생성");
	}

	// 생성자 
	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");
	}

	// 소멸자  
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	// 복사생성자
	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사할당 연산자
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}

	// 이동생성자  
	String(String&& other) {		// && - r_Value Reference  
		len = other.len;
		p = other.p;

		// 정리 ( Other 를 정리한다 ) 
		// Other 를 정리하지 않으면 프로그램 사망  
		other.len = 0;
		other.p = nullptr; // 이거 안해주면 Dangleing Pointer 가 생겨서 프로그램이 죽는다. 


		print("이동생성자");
	}

	// 이동 할당 연산자 
	String& operator=(String&& other) {
		if (this == &other)
			return *this;

		// 확보한 자원을 해제  
		delete[] p;


		// Other 의 자원을 가져온다. 
		len = other.len;
		p = other.p;


		// Other 를 초기화한다.
		other.len = 0;
		other.p = nullptr;

		print("이동할당연산자");

		return *this;
	}



	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}

	// gettor / settor
	string getString() const {
		return string(p, len);
	}

	// 그 외 함수  
	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	관찰 = true;
	String a{ "12345" };
	String b = std::move( a );
	//String b = a;

	cout << sizeof(String) << endl;

	cout << " a : " << a << endl;
	cout << " b : " << b << endl;

	MySaveFileCode::Save_File("5주차_1.cpp", "5주차_1.txt");

	// dangling pointer - static 포인터 가리킬때 댕글링 걸리면 프로그램 사망 

}
#endif // FIFTH_FIRST

#define FIFTH_FIRST
#ifdef FIFTH_FIRST

/*
	2023_04_04(월)
	String Class file 분리 

*/
// --------------------------------------------------
//	2023 1 학기 STL 4월 03일 TUE 23 Tue 56 ( 5주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

/*
	class String {

		public:
		 === SPECIAL FUNCTION ===
		 / 프로그래머가 작성하지 않으면 컴파일러가 알아서 만들어주는 특징 / 
			* 생성자		,	소멸자
			* 복사생성자	,	복사할당연산자
			* 이동생성자 ,	이동할당연산자
		 ========================
			* 연산자 오버로딩
			* gettor  /  settor
			* 그 외 interface 함수  

	}

*/

#include <iostream>
#include <array>
#include <algorithm>
#include <string>

#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};		// 확보한 자원의 바이트 수  
	char* p{};			// 확보한 자원의 주소  
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;	// 클래스 스태틱

public:


	// 디폴트 생성자   
	String() {
		print("디폴트 생성");
	}

	// 생성자 
	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");
	}

	// 소멸자  
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	// 복사생성자
	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사할당 연산자
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}

	// 이동생성자  
	String(String&& other) {		// && - r_Value Reference  
		len = other.len;
		p = other.p;

		// 정리 ( Other 를 정리한다 ) 
		// Other 를 정리하지 않으면 프로그램 사망  
		other.len = 0;
		other.p = nullptr; // 이거 안해주면 Dangleing Pointer 가 생겨서 프로그램이 죽는다. 


		print("이동생성자");
	}

	// 이동 할당 연산자 
	String& operator=(String&& other) {
		if (this == &other)
			return *this;

		// 확보한 자원을 해제  
		delete[] p;


		// Other 의 자원을 가져온다. 
		len = other.len;
		p = other.p;


		// Other 를 초기화한다.
		other.len = 0;
		other.p = nullptr;

		print("이동할당연산자");

		return *this;
	}



	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}

	// gettor / settor
	string getString() const {
		return string(p, len);
	}

	// 그 외 함수  
	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{

	array<String, 3> a{ "345", "12", "7890" };

	sort(a.begin(), a.end(), [](const String& a, const String& b)
		{return a.getString() < b.getString();});

	for (const String& s : a)
		cout << s << endl;




	MySaveFileCode::Save_File("5주차_1.cpp", "5주차_1.txt");

	// dangling pointer - static 포인터 가리킬때 댕글링 걸리면 프로그램 사망 

}
#endif // FIFTH_FIRST

#define FIFTH_FIRST
#ifdef FIFTH_FIRST

/*
	2023_04_04(월)
	String Class file 분리 

*/
// --------------------------------------------------
//	2023 1 학기 STL 4월 03일 TUE 23 Tue 56 ( 5주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

/*
	class String {

		public:
		 === SPECIAL FUNCTION ===
		 / 프로그래머가 작성하지 않으면 컴파일러가 알아서 만들어주는 특징 / 
			* 생성자		,	소멸자
			* 복사생성자	,	복사할당연산자
			* 이동생성자 ,	이동할당연산자
		 ========================
			* 연산자 오버로딩
			* gettor  /  settor
			* 그 외 interface 함수  

	}

*/

#include <iostream>
#include <array>
#include <algorithm>
#include <string>

#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};		// 확보한 자원의 바이트 수  
	char* p{};			// 확보한 자원의 주소  
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;	// 클래스 스태틱

public:


	// 디폴트 생성자   
	String() {
		print("디폴트 생성");
	}

	// 생성자 
	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");
	}

	// 소멸자  
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	// 복사생성자
	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사할당 연산자
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}

	// 이동생성자  
	String(String&& other) {		// && - r_Value Reference  
		len = other.len;
		p = other.p;

		// 정리 ( Other 를 정리한다 ) 
		// Other 를 정리하지 않으면 프로그램 사망  
		other.len = 0;
		other.p = nullptr; // 이거 안해주면 Dangleing Pointer 가 생겨서 프로그램이 죽는다. 


		print("이동생성자");
	}

	// 이동 할당 연산자 
	String& operator=(String&& other) {
		if (this == &other)
			return *this;

		// 확보한 자원을 해제  
		delete[] p;


		// Other 의 자원을 가져온다. 
		len = other.len;
		p = other.p;


		// Other 를 초기화한다.
		other.len = 0;
		other.p = nullptr;

		print("이동할당연산자");

		return *this;
	}



	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}

	// gettor / settor
	string getString() const {
		return string(p, len);
	}

	// 그 외 함수  
	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	관찰 = true;
	array<String, 3> a{ "345", "12", "7890" };

	sort(a.begin(), a.end(), [](const String& a, const String& b)
		{return a.getString() < b.getString();});

	for (const String& s : a)
		cout << s << endl;




	MySaveFileCode::Save_File("5주차_1.cpp", "5주차_1.txt");

	// dangling pointer - static 포인터 가리킬때 댕글링 걸리면 프로그램 사망 

}
#endif // FIFTH_FIRST

#define FIFTH_FIRST
#ifdef FIFTH_FIRST

/*
	2023_04_04(월)
	String Class file 분리 

*/
// --------------------------------------------------
//	2023 1 학기 STL 4월 03일 TUE 23 Tue 56 ( 5주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

/*
	class String {

		public:
		 === SPECIAL FUNCTION ===
		 / 프로그래머가 작성하지 않으면 컴파일러가 알아서 만들어주는 특징 / 
			* 생성자		,	소멸자
			* 복사생성자	,	복사할당연산자
			* 이동생성자 ,	이동할당연산자
		 ========================
			* 연산자 오버로딩
			* gettor  /  settor
			* 그 외 interface 함수  

	}

*/

#include <iostream>
#include <array>
#include <algorithm>
#include <string>

#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};		// 확보한 자원의 바이트 수  
	char* p{};			// 확보한 자원의 주소  
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;	// 클래스 스태틱

public:


	// 디폴트 생성자   
	String() {
		print("디폴트 생성");
	}

	// 생성자 
	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");
	}

	// 소멸자  
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	// 복사생성자
	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사할당 연산자
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}

	// 이동생성자  
	String(String&& other) {		// && - r_Value Reference  
		len = other.len;
		p = other.p;

		// 정리 ( Other 를 정리한다 ) 
		// Other 를 정리하지 않으면 프로그램 사망  
		other.len = 0;
		other.p = nullptr; // 이거 안해주면 Dangleing Pointer 가 생겨서 프로그램이 죽는다. 


		print("이동생성자");
	}

	// 이동 할당 연산자 
	String& operator=(String&& other) {
		if (this == &other)
			return *this;

		// 확보한 자원을 해제  
		delete[] p;


		// Other 의 자원을 가져온다. 
		len = other.len;
		p = other.p;


		// Other 를 초기화한다.
		other.len = 0;
		other.p = nullptr;

		print("이동할당연산자");

		return *this;
	}



	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}

	// gettor / settor
	string getString() const {
		return string(p, len);
	}

	// 그 외 함수  
	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	관찰 = true;
	array<String, 3> a{ "345", "12", "7890" };

	sort(a.begin(), a.end(), [](const String& a, const String& b)
		{return a.getString() < b.getString();});

	for (const String& s : a)
		cout << s << endl;




	MySaveFileCode::Save_File("5주차_1.cpp", "5주차_1.txt");

	// dangling pointer - static 포인터 가리킬때 댕글링 걸리면 프로그램 사망 

}
#endif // FIFTH_FIRST

#define FIFTH_FIRST
#ifdef FIFTH_FIRST

/*
	2023_04_04(월)
	String Class file 분리 

*/
// --------------------------------------------------
//	2023 1 학기 STL 4월 03일 TUE 23 Tue 56 ( 5주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

/*
	class String {

		public:
		 === SPECIAL FUNCTION ===
		 / 프로그래머가 작성하지 않으면 컴파일러가 알아서 만들어주는 특징 / 
			* 생성자		,	소멸자
			* 복사생성자	,	복사할당연산자
			* 이동생성자 ,	이동할당연산자
		 ========================
			* 연산자 오버로딩
			* gettor  /  settor
			* 그 외 interface 함수  

	}

*/

#include <iostream>
#include <array>
#include <algorithm>

#include "String.h"
#include "save.h"

using namespace std;


// -------	
int main()
// -------
{
	extern bool 관찰; 
	관찰 = true;
	array<String, 3> a{ "345", "12", "7890" };

	sort(a.begin(), a.end(), [](const String& a, const String& b)
		{return a.getString() < b.getString();});

	for (const String& s : a)
		cout << s << endl;




	MySaveFileCode::Save_File("5주차_1.cpp", "5주차_1.txt");

	// dangling pointer - static 포인터 가리킬때 댕글링 걸리면 프로그램 사망 

}
#endif // FIFTH_FIRST

#define FIFTH_FIRST
#ifdef FIFTH_FIRST

/*
	2023_04_04(월)
	String Class file 분리 

*/
// --------------------------------------------------
//	2023 1 학기 STL 4월 03일 TUE 23 Tue 56 ( 5주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

/*
	class String {

		public:
		 === SPECIAL FUNCTION ===
		 / 프로그래머가 작성하지 않으면 컴파일러가 알아서 만들어주는 특징 / 
			* 생성자		,	소멸자
			* 복사생성자	,	복사할당연산자
			* 이동생성자 ,	이동할당연산자
		 ========================
			* 연산자 오버로딩
			* gettor  /  settor
			* 그 외 interface 함수  

	}

*/

#include <iostream>
#include <array>
#include <algorithm>

#include "String.h"
#include "save.h"

using namespace std;


// -------	
int main()
// -------
{
	extern bool 관찰; 
	관찰 = true;
	array<String, 3> a{ "345", "12", "7890" };

	sort(a.begin(), a.end(), [](const String& a, const String& b)
		{return a.getString() < b.getString();});

	for (const String& s : a)
		cout << s << endl;




	MySaveFileCode::Save_File("5주차_1.cpp", "5주차_1.txt");
	MySaveFileCode::Save_File("String.h", "String_Class.txt");
	MySaveFileCode::Save_File("String.cpp", "String_Class.txt");




	// dangling pointer - static 포인터 가리킬때 댕글링 걸리면 프로그램 사망 

}
#endif // FIFTH_FIRST

