
/*
		STL 
		2023 03 06 


		STL 
		C++ 표준라이브러리를 다룬다
		전공 선택과목이다, 
		
		정리된 자료는 없지만 써있는 순서에 따라서 
		설명하고 코딩하고 이게 왜 필요한가 
		이게 왜 만들어진건가를 배운다,
		이클래스 이메일을 활용하라.
		객체 지향 언어
		그것과는 전혀 다르다
		
		내가 만든 클래스가 기존의 객체와 같은 방식으로 움직일 수 있도록
		연산자 오버로딩을...
		덧셈 , 입출력


		C++ 언어는 메모리를 이해하지 못하면 안된다.
		4 주간에는 C++  복습을 할 것이다.
		ㅊ++ 20 코드가 어떻게 바뀌었는지

		객체간의 관계
		-> 상속관계
		객체와 객체간을 부모자식관계로 맺어주는 
		상속 이유 : 1, 코드 재사용, 2, 다형성을 구현하기 위해서,,,
		PolyMolpigion
		다형성 : 어떤 명령을 객체에게 내렸는데 각 객체마다 자기고유의 일을 한다,
		아 2거자거 개암애서는 필수이다.
		
		메모리에 어떻게 집어넣고 이 만마리의 개들에서 원하는 정보를 얼마나 잘 꺼낼 수 있을지.
		숫자가 상당히 크다.

		객체의 집합이 개수가 많지 않다면 어떤 자료구조를 쓰던 큰 차이가 없는데 
		
		STL 개빠름 - 원리를 공부한다.
		vector 가 가장 중요하다,

		템플릿 
		virtual 핵심 키워드를 넣는 순간 메모리가 늘어난다.
		virtual table 을 쫓아가려고.. 늘어난다.
		template

		교재 : https://en.cppreference.com/w/

		많은 수의 객체를 다룬다.
		파일을 읽어와야하는데 이해하지못하면 힘들다.
		txt 모드 binary 모드 2개만 있다. 
		많은 수의 자료를 전송하거나 할때는 바이너리 모드로 한다. 
	
		

*/

//
//	2023 1 학기 STL 3월 6일 Mon 23 Tue 56 ( 1주 1)
//	오늘의 주제 : 한학기 강의 저장 Save 코드 작성 
//
//	코딩 환경 통일 
//	VS Release/ X64 / Pointer 8 Byte 차지 
//	int : 4byte / 2byte이상 이 int 의 크기이다. 


#include <iostream>
#include <string>
#include <fstream>
#include <vector> // 밑바닥 까지 파헤칠 것이다. 


//using namespace std;


// const char* : 이건 사용하지 않는것을 권장한다. 

void save(const std::string& fileName); 


int main()
{
	std::cout << "2023 STL" << '\n';
	
	std::cout << sizeof std::string << '\n';


	// 단계를 쫓아가면서 이유를 설명할 수 있어야한다. 

	save("STL.cpp");



	// return 0; 은 자동으로 들어간다.
}

void save(const std::string& fileName)
{
	/*
		STL 내용으로 코딩할 것이다.
	*/

	// 읽기 모드로 fileName 을 연다. 
	// 각종 생성자가 오버로딩 되어있다. 
	std::ifstream InputFile{ fileName }; // uniform 초기화 InputFile.close() 할 필요가 없다.  RAII 개념과 엮여있다. 자원을 초기화 함과 동시에 
	// 메모리 관리에 들어간다. java 의 garbage collection 과는 비교할 수 없다. 알아서 삭제된다. 
	// FIle Pointer ( 파일 처음 ) 한글자를 읽어오면 글자를 계속 읽어들인다. 

	// if(InputFile.opne()) // 주의 ::이런거 쓰면 0 점이다. 
	// 시험에 파일 읽어오는거 잇따. 

	/*
		// 복습 
		char c;
		//InputFile >> c; // 파일에서 한 글자 읽어온다.
		InputFile >> std::noskipws;
		while (InputFile >> c) // 자동으로 EOF 까지 읽는다.  - 공백은 무시하고 글자만 읽어오라는 함수 오버로딩이다. ( >> ) InputFile.operator>> ( c)
		{

			std::cout << c;

		}

	*/
	


	
	
	// 저장할 파일을 덧붙여 쓰기 모드로 연다. 
	// 실행할때 마다 이 파일에 저장된다. ( 덧붙여 쓰인다. ) 
	std::ofstream outputFile{ "2023 1학기 STL 월23화56 강의저장.txt", std::ios::app }; // 확장자 없어도 여는데 문제 없다.  ( append )

	
	// fileName 을 읽어 저장할 파일에 쓴다.
	// STL 자료구조와 알고리즘을 이용하여 작성 
	
	// istream_iterator 공백 무시함 
	// istreambuf_iterator 공백 무시안함 
	std::vector<char> v{ std::istreambuf_iterator<char> { InputFile }, {} /*비어있는 중괄호 : EOF */}; /* v 가 데이터를 다읽음 */
	//std::copy(v.begin(), v.end(), std::ostream_iterator<char>{ std::cout /* 화면에 출력하라 ( std::cout*/}/* [ 목적지 ] - 어디로 복사하라 ,,, */); // concept range 
	std::copy(v.begin(), v.end(), std::ostream_iterator<char>{ outputFile /* 화면에 출력하라 ( std::cout*/}/* [ 목적지 ] - 어디로 복사하라 ,,, */); // concept range 


	

}//  EOF
/*
		STL 
		2023 03 06 


		STL 
		C++ 표준라이브러리를 다룬다
		전공 선택과목이다, 
		
		정리된 자료는 없지만 써있는 순서에 따라서 
		설명하고 코딩하고 이게 왜 필요한가 
		이게 왜 만들어진건가를 배운다,
		이클래스 이메일을 활용하라.
		객체 지향 언어
		그것과는 전혀 다르다
		
		내가 만든 클래스가 기존의 객체와 같은 방식으로 움직일 수 있도록
		연산자 오버로딩을...
		덧셈 , 입출력


		C++ 언어는 메모리를 이해하지 못하면 안된다.
		4 주간에는 C++  복습을 할 것이다.
		ㅊ++ 20 코드가 어떻게 바뀌었는지

		객체간의 관계
		-> 상속관계
		객체와 객체간을 부모자식관계로 맺어주는 
		상속 이유 : 1, 코드 재사용, 2, 다형성을 구현하기 위해서,,,
		PolyMolpigion
		다형성 : 어떤 명령을 객체에게 내렸는데 각 객체마다 자기고유의 일을 한다,
		아 2거자거 개암애서는 필수이다.
		
		메모리에 어떻게 집어넣고 이 만마리의 개들에서 원하는 정보를 얼마나 잘 꺼낼 수 있을지.
		숫자가 상당히 크다.

		객체의 집합이 개수가 많지 않다면 어떤 자료구조를 쓰던 큰 차이가 없는데 
		
		STL 개빠름 - 원리를 공부한다.
		vector 가 가장 중요하다,

		템플릿 
		virtual 핵심 키워드를 넣는 순간 메모리가 늘어난다.
		virtual table 을 쫓아가려고.. 늘어난다.
		template

		교재 : https://en.cppreference.com/w/

		많은 수의 객체를 다룬다.
		파일을 읽어와야하는데 이해하지못하면 힘들다.
		txt 모드 binary 모드 2개만 있다. 
		많은 수의 자료를 전송하거나 할때는 바이너리 모드로 한다. 
	
		

*/

//
//	2023 1 학기 STL 3월 6일 Mon 23 Tue 56 ( 1주 1)
//	오늘의 주제 : 한학기 강의 저장 Save 코드 작성 
//
//	코딩 환경 통일 
//	VS Release/ X64 / Pointer 8 Byte 차지 
//	int : 4byte / 2byte이상 이 int 의 크기이다. 


#include <iostream>
#include <string>
#include <fstream>
#include <vector> // 밑바닥 까지 파헤칠 것이다. 


//using namespace std;


// const char* : 이건 사용하지 않는것을 권장한다. 

void save(const std::string& fileName); 


int main()
{
	std::cout << "2023 STL" << '\n';
	
	std::cout << sizeof std::string << '\n';


	// 단계를 쫓아가면서 이유를 설명할 수 있어야한다. 

	save("STL.cpp");



	// return 0; 은 자동으로 들어간다.
}

void save(const std::string& fileName)
{
	/*
		STL 내용으로 코딩할 것이다.
	*/

	// 읽기 모드로 fileName 을 연다. 
	// 각종 생성자가 오버로딩 되어있다. 
	std::ifstream InputFile{ fileName }; // uniform 초기화 InputFile.close() 할 필요가 없다.  RAII 개념과 엮여있다. 자원을 초기화 함과 동시에 
	// 메모리 관리에 들어간다. java 의 garbage collection 과는 비교할 수 없다. 알아서 삭제된다. 
	// FIle Pointer ( 파일 처음 ) 한글자를 읽어오면 글자를 계속 읽어들인다. 

	// if(InputFile.opne()) // 주의 ::이런거 쓰면 0 점이다. 
	// 시험에 파일 읽어오는거 잇따. 

	/*
		// 복습 
		char c;
		//InputFile >> c; // 파일에서 한 글자 읽어온다.
		InputFile >> std::noskipws;
		while (InputFile >> c) // 자동으로 EOF 까지 읽는다.  - 공백은 무시하고 글자만 읽어오라는 함수 오버로딩이다. ( >> ) InputFile.operator>> ( c)
		{

			std::cout << c;

		}

	*/
	


	
	
	// 저장할 파일을 덧붙여 쓰기 모드로 연다. 
	// 실행할때 마다 이 파일에 저장된다. ( 덧붙여 쓰인다. ) 
	std::ofstream outputFile{ "2023 1학기 STL 월23화56 강의저장.txt", std::ios::app }; // 확장자 없어도 여는데 문제 없다.  ( append )

	
	// fileName 을 읽어 저장할 파일에 쓴다.
	// STL 자료구조와 알고리즘을 이용하여 작성 
	
	//istream_iterator 공백 무시함 
	// istreambuf_iterator 공백 무시안함 
	std::vector<char> v{ std::istreambuf_iterator<char> { InputFile }, {} /*비어있는 중괄호 : EOF */}; /* v 가 데이터를 다읽음 */
	//std::copy(v.begin(), v.end(), std::ostream_iterator<char>{ std::cout /* 화면에 출력하라 ( std::cout*/}/* [ 목적지 ] - 어디로 복사하라 ,,, */); // concept range 
	std::copy(v.begin(), v.end(), std::ostream_iterator<char>{ outputFile /* 화면에 출력하라 ( std::cout*/}/* [ 목적지 ] - 어디로 복사하라 ,,, */); // concept range 


	

}//  EOF


/*
		STL 
		2023 03 06 


		STL 
		C++ 표준라이브러리를 다룬다
		전공 선택과목이다, 
		
		정리된 자료는 없지만 써있는 순서에 따라서 
		설명하고 코딩하고 이게 왜 필요한가 
		이게 왜 만들어진건가를 배운다,
		이클래스 이메일을 활용하라.
		객체 지향 언어
		그것과는 전혀 다르다
		
		내가 만든 클래스가 기존의 객체와 같은 방식으로 움직일 수 있도록
		연산자 오버로딩을...
		덧셈 , 입출력


		C++ 언어는 메모리를 이해하지 못하면 안된다.
		4 주간에는 C++  복습을 할 것이다.
		ㅊ++ 20 코드가 어떻게 바뀌었는지

		객체간의 관계
		-> 상속관계
		객체와 객체간을 부모자식관계로 맺어주는 
		상속 이유 : 1, 코드 재사용, 2, 다형성을 구현하기 위해서,,,
		PolyMolpigion
		다형성 : 어떤 명령을 객체에게 내렸는데 각 객체마다 자기고유의 일을 한다,
		아 2거자거 개암애서는 필수이다.
		
		메모리에 어떻게 집어넣고 이 만마리의 개들에서 원하는 정보를 얼마나 잘 꺼낼 수 있을지.
		숫자가 상당히 크다.

		객체의 집합이 개수가 많지 않다면 어떤 자료구조를 쓰던 큰 차이가 없는데 
		
		STL 개빠름 - 원리를 공부한다.
		vector 가 가장 중요하다,

		템플릿 
		virtual 핵심 키워드를 넣는 순간 메모리가 늘어난다.
		virtual table 을 쫓아가려고.. 늘어난다.
		template

		교재 : https://en.cppreference.com/w/

		많은 수의 객체를 다룬다.
		파일을 읽어와야하는데 이해하지못하면 힘들다.
		txt 모드 binary 모드 2개만 있다. 
		많은 수의 자료를 전송하거나 할때는 바이너리 모드로 한다. 
	
		

*/

//
//	2023 1 학기 STL 3월 6일 Mon 23 Tue 56 ( 1주 1)
//	오늘의 주제 : 한학기 강의 저장 Save 코드 작성 
//
//	코딩 환경 통일 
//	VS Release/ X64 / Pointer 8 Byte 차지 
//	int : 4byte / 2byte이상 이 int 의 크기이다. 


#include <iostream>
#include <string>
#include <fstream>
#include <vector> // 밑바닥 까지 파헤칠 것이다. 


//using namespace std;


// const char* : 이건 사용하지 않는것을 권장한다. 

void save(const std::string& fileName); 


int main()
{
	std::cout << "2023 STL" << '\n';
	
	std::cout << sizeof std::string << '\n';


	// 단계를 쫓아가면서 이유를 설명할 수 있어야한다. 

	save("STL.cpp");



	// return 0; 은 자동으로 들어간다.
}

void save(const std::string& fileName)
{
	/*
		STL 내용으로 코딩할 것이다.
	*/

	// 읽기 모드로 fileName 을 연다. 
	// 각종 생성자가 오버로딩 되어있다. 
	std::ifstream InputFile{ fileName }; // uniform 초기화 InputFile.close() 할 필요가 없다.  RAII 개념과 엮여있다. 자원을 초기화 함과 동시에 
	// 메모리 관리에 들어간다. java 의 garbage collection 과는 비교할 수 없다. 알아서 삭제된다. 
	// FIle Pointer ( 파일 처음 ) 한글자를 읽어오면 글자를 계속 읽어들인다. 

	// if(InputFile.opne()) // 주의 ::이런거 쓰면 0 점이다. 
	// 시험에 파일 읽어오는거 잇따. 

	/*
		// 복습 
		char c;
		//InputFile >> c; // 파일에서 한 글자 읽어온다.
		InputFile >> std::noskipws;
		while (InputFile >> c) // 자동으로 EOF 까지 읽는다.  - 공백은 무시하고 글자만 읽어오라는 함수 오버로딩이다. ( >> ) InputFile.operator>> ( c)
		{

			std::cout << c;

		}

	*/
	


	
	
	// 저장할 파일을 덧붙여 쓰기 모드로 연다. 
	// 실행할때 마다 이 파일에 저장된다. ( 덧붙여 쓰인다. ) 
	std::ofstream outputFile{ "2023 1학기 STL 월23화56 강의저장.txt", std::ios::app }; // 확장자 없어도 여는데 문제 없다.  ( append )

	outputFile << '\n' << '\n';

	
	// fileName 을 읽어 저장할 파일에 쓴다.
	// STL 자료구조와 알고리즘을 이용하여 작성 
	
	//istream_iterator 공백 무시함 
	// istreambuf_iterator 공백 무시안함 
	std::vector<char> v{ std::istreambuf_iterator<char> { InputFile }, {} /*비어있는 중괄호 : EOF */}; /* v 가 데이터를 다읽음 */
	//std::copy(v.begin(), v.end(), std::ostream_iterator<char>{ std::cout /* 화면에 출력하라 ( std::cout*/}/* [ 목적지 ] - 어디로 복사하라 ,,, */); // concept range 
	std::copy(v.begin(), v.end(), std::ostream_iterator<char>{ outputFile /* 화면에 출력하라 ( std::cout*/}/* [ 목적지 ] - 어디로 복사하라 ,,, */); // concept range 


	

}//  EOF



/*
		STL 
		2023 03 06 


		STL 
		C++ 표준라이브러리를 다룬다
		전공 선택과목이다, 
		
		정리된 자료는 없지만 써있는 순서에 따라서 
		설명하고 코딩하고 이게 왜 필요한가 
		이게 왜 만들어진건가를 배운다,
		이클래스 이메일을 활용하라.
		객체 지향 언어
		그것과는 전혀 다르다
		
		내가 만든 클래스가 기존의 객체와 같은 방식으로 움직일 수 있도록
		연산자 오버로딩을...
		덧셈 , 입출력


		C++ 언어는 메모리를 이해하지 못하면 안된다.
		4 주간에는 C++  복습을 할 것이다.
		ㅊ++ 20 코드가 어떻게 바뀌었는지

		객체간의 관계
		-> 상속관계
		객체와 객체간을 부모자식관계로 맺어주는 
		상속 이유 : 1, 코드 재사용, 2, 다형성을 구현하기 위해서,,,
		PolyMolpigion
		다형성 : 어떤 명령을 객체에게 내렸는데 각 객체마다 자기고유의 일을 한다,
		아 2거자거 개암애서는 필수이다.
		
		메모리에 어떻게 집어넣고 이 만마리의 개들에서 원하는 정보를 얼마나 잘 꺼낼 수 있을지.
		숫자가 상당히 크다.

		객체의 집합이 개수가 많지 않다면 어떤 자료구조를 쓰던 큰 차이가 없는데 
		
		STL 개빠름 - 원리를 공부한다.
		vector 가 가장 중요하다,

		템플릿 
		virtual 핵심 키워드를 넣는 순간 메모리가 늘어난다.
		virtual table 을 쫓아가려고.. 늘어난다.
		template

		교재 : https://en.cppreference.com/w/

		많은 수의 객체를 다룬다.
		파일을 읽어와야하는데 이해하지못하면 힘들다.
		txt 모드 binary 모드 2개만 있다. 
		많은 수의 자료를 전송하거나 할때는 바이너리 모드로 한다. 
	
		

*/

//
//	2023 1 학기 STL 3월 6일 Mon 23 Tue 56 ( 1주 1)
//	오늘의 주제 : 한학기 강의 저장 Save 코드 작성 
//
//	코딩 환경 통일 
//	VS Release/ X64 / Pointer 8 Byte 차지 
//	int : 4byte / 2byte이상 이 int 의 크기이다. 


#include <iostream>
#include <string>
#include <fstream>
#include <vector> // 밑바닥 까지 파헤칠 것이다. 
#include <chrono>

//using namespace std;


// const char* : 이건 사용하지 않는것을 권장한다. 

void save(const std::string& fileName); 

// -------
int main()
// -------
{
	std::cout << "2023 STL" << '\n';
	
	std::cout << sizeof std::string << '\n';


	// 단계를 쫓아가면서 이유를 설명할 수 있어야한다. 

	save("STL.cpp");



	// return 0; 은 자동으로 들어간다.
}

void save(const std::string& fileName)
{
	/*
		STL 내용으로 코딩할 것이다.
	*/

	// 읽기 모드로 fileName 을 연다. 
	// 각종 생성자가 오버로딩 되어있다. 
	std::ifstream InputFile{ fileName }; // uniform 초기화 InputFile.close() 할 필요가 없다.  RAII 개념과 엮여있다. 자원을 초기화 함과 동시에 
	// 메모리 관리에 들어간다. java 의 garbage collection 과는 비교할 수 없다. 알아서 삭제된다. 
	// FIle Pointer ( 파일 처음 ) 한글자를 읽어오면 글자를 계속 읽어들인다. 

	// if(InputFile.opne()) // 주의 ::이런거 쓰면 0 점이다. 
	// 시험에 파일 읽어오는거 잇따. 

	/*
		// 복습 
		char c;
		//InputFile >> c; // 파일에서 한 글자 읽어온다.
		InputFile >> std::noskipws;
		while (InputFile >> c) // 자동으로 EOF 까지 읽는다.  - 공백은 무시하고 글자만 읽어오라는 함수 오버로딩이다. ( >> ) InputFile.operator>> ( c)
		{

			std::cout << c;

		}

	*/
	


	
	
	// 저장할 파일을 덧붙여 쓰기 모드로 연다. 
	// 실행할때 마다 이 파일에 저장된다. ( 덧붙여 쓰인다. ) 
	std::ofstream outputFile{ "2023 1학기 STL 월23화56 강의저장.txt", std::ios::app }; // 확장자 없어도 여는데 문제 없다.  ( append )

	outputFile << '\n' << '\n' << '\n';

	// 시간을 기록하는 코드 
	/*
		time points - epoch 이 단어에서 시작한다. ( 1월 1일 자정
		wlrma tlrksdl auctldi? zjavbxjsms 1970년 1월 1일 부터 말한다. - 이때부터 흘러간 시간을 대답한다 - time points
		( Duration )
	*/

	auto now = std::chrono::system_clock::now(); // 현재 시간  현재 Time Point 를 얻는다. 
	std::cout << now << '\n'; // C++ 17 에서 제공하는 기능이므로 언어표준을 최신을 ㅗ바꾸어야 힌다.


	/*
	auto
		
	*/

	
	
	// fileName 을 읽어 저장할 파일에 쓴다.
	// STL 자료구조와 알고리즘을 이용하여 작성 
	
	//istream_iterator 공백 무시함 
	// istreambuf_iterator 공백 무시안함 
	std::vector<char> v{ std::istreambuf_iterator<char> { InputFile }, {} /*비어있는 중괄호 : EOF */}; /* v 가 데이터를 다읽음 */
	//std::copy(v.begin(), v.end(), std::ostream_iterator<char>{ std::cout /* 화면에 출력하라 ( std::cout*/}/* [ 목적지 ] - 어디로 복사하라 ,,, */); // concept range 
	std::copy(v.begin(), v.end(), std::ostream_iterator<char>{ outputFile /* 화면에 출력하라 ( std::cout*/}/* [ 목적지 ] - 어디로 복사하라 ,,, */); // concept range 




	

}//  EOF



/*
		STL 
		2023 03 06 


		STL 
		C++ 표준라이브러리를 다룬다
		전공 선택과목이다, 
		
		정리된 자료는 없지만 써있는 순서에 따라서 
		설명하고 코딩하고 이게 왜 필요한가 
		이게 왜 만들어진건가를 배운다,
		이클래스 이메일을 활용하라.
		객체 지향 언어
		그것과는 전혀 다르다
		
		내가 만든 클래스가 기존의 객체와 같은 방식으로 움직일 수 있도록
		연산자 오버로딩을...
		덧셈 , 입출력


		C++ 언어는 메모리를 이해하지 못하면 안된다.
		4 주간에는 C++  복습을 할 것이다.
		ㅊ++ 20 코드가 어떻게 바뀌었는지

		객체간의 관계
		-> 상속관계
		객체와 객체간을 부모자식관계로 맺어주는 
		상속 이유 : 1, 코드 재사용, 2, 다형성을 구현하기 위해서,,,
		PolyMolpigion
		다형성 : 어떤 명령을 객체에게 내렸는데 각 객체마다 자기고유의 일을 한다,
		아 2거자거 개암애서는 필수이다.
		
		메모리에 어떻게 집어넣고 이 만마리의 개들에서 원하는 정보를 얼마나 잘 꺼낼 수 있을지.
		숫자가 상당히 크다.

		객체의 집합이 개수가 많지 않다면 어떤 자료구조를 쓰던 큰 차이가 없는데 
		
		STL 개빠름 - 원리를 공부한다.
		vector 가 가장 중요하다,

		템플릿 
		virtual 핵심 키워드를 넣는 순간 메모리가 늘어난다.
		virtual table 을 쫓아가려고.. 늘어난다.
		template

		교재 : https://en.cppreference.com/w/

		많은 수의 객체를 다룬다.
		파일을 읽어와야하는데 이해하지못하면 힘들다.
		txt 모드 binary 모드 2개만 있다. 
		많은 수의 자료를 전송하거나 할때는 바이너리 모드로 한다. 
	
		

*/

//
//	2023 1 학기 STL 3월 6일 Mon 23 Tue 56 ( 1주 1)
//	오늘의 주제 : 한학기 강의 저장 Save 코드 작성 
//
//	코딩 환경 통일 
//	VS Release/ X64 / Pointer 8 Byte 차지 
//	int : 4byte / 2byte이상 이 int 의 크기이다. 


#include <iostream>
#include <string>
#include <fstream>
#include <vector> // 밑바닥 까지 파헤칠 것이다. 
#include <chrono>

//using namespace std;


// const char* : 이건 사용하지 않는것을 권장한다. 

void save(const std::string& fileName); 

// -------
int main()
// -------
{
	std::cout << "2023 STL" << '\n';
	
	std::cout << sizeof std::string << '\n';


	// 단계를 쫓아가면서 이유를 설명할 수 있어야한다. 

	save("STL.cpp");



	// return 0; 은 자동으로 들어간다.
}

void save(const std::string& fileName)
{
	/*
		STL 내용으로 코딩할 것이다.
	*/

	// 읽기 모드로 fileName 을 연다. 
	// 각종 생성자가 오버로딩 되어있다. 
	std::ifstream InputFile{ fileName }; // uniform 초기화 InputFile.close() 할 필요가 없다.  RAII 개념과 엮여있다. 자원을 초기화 함과 동시에 
	// 메모리 관리에 들어간다. java 의 garbage collection 과는 비교할 수 없다. 알아서 삭제된다. 
	// FIle Pointer ( 파일 처음 ) 한글자를 읽어오면 글자를 계속 읽어들인다. 

	// if(InputFile.opne()) // 주의 ::이런거 쓰면 0 점이다. 
	// 시험에 파일 읽어오는거 잇따. 

	/*
		// 복습 
		char c;
		//InputFile >> c; // 파일에서 한 글자 읽어온다.
		InputFile >> std::noskipws;
		while (InputFile >> c) // 자동으로 EOF 까지 읽는다.  - 공백은 무시하고 글자만 읽어오라는 함수 오버로딩이다. ( >> ) InputFile.operator>> ( c)
		{

			std::cout << c;

		}

	*/
	


	
	
	// 저장할 파일을 덧붙여 쓰기 모드로 연다. 
	// 실행할때 마다 이 파일에 저장된다. ( 덧붙여 쓰인다. ) 
	std::ofstream outputFile{ "2023 1학기 STL 월23화56 강의저장.txt", std::ios::app }; // 확장자 없어도 여는데 문제 없다.  ( append )

	outputFile << '\n' << '\n' << '\n';

	// 시간을 기록하는 코드 
	/*
		time points - epoch 이 단어에서 시작한다. ( 1월 1일 자정
		wlrma tlrksdl auctldi? zjavbxjsms 1970년 1월 1일 부터 말한다. - 이때부터 흘러간 시간을 대답한다 - time points
		( Duration )
	*/

	auto now = std::chrono::system_clock::now(); // 현재 시간  현재 Time Point 를 얻는다. 
	std::cout << now << '\n'; // C++ 17 에서 제공하는 기능이므로 언어표준을 최신을 ㅗ바꾸어야 힌다. - ETC
	using namespace std::chrono;
	std::cout << now + 9h << '\n';

	

	/*
	auto
		
	*/

	
	
	// fileName 을 읽어 저장할 파일에 쓴다.
	// STL 자료구조와 알고리즘을 이용하여 작성 
	
	//istream_iterator 공백 무시함 
	// istreambuf_iterator 공백 무시안함 
	std::vector<char> v{ std::istreambuf_iterator<char> { InputFile }, {} /*비어있는 중괄호 : EOF */}; /* v 가 데이터를 다읽음 */
	//std::copy(v.begin(), v.end(), std::ostream_iterator<char>{ std::cout /* 화면에 출력하라 ( std::cout*/}/* [ 목적지 ] - 어디로 복사하라 ,,, */); // concept range 
	std::copy(v.begin(), v.end(), std::ostream_iterator<char>{ outputFile /* 화면에 출력하라 ( std::cout*/}/* [ 목적지 ] - 어디로 복사하라 ,,, */); // concept range 




	

}//  EOF



#define STL
#ifdef STL

//
//	2023 1 학기 STL 3월 6일 Mon 23 Tue 56 ( 1주 1)
//	오늘의 주제 : 한학기 강의 저장 Save 코드 작성 
//
//	코딩 환경 통일 
//	VS Release/ X64 / Pointer 8 Byte 차지 
//	int : 4byte / 2byte이상 이 int 의 크기이다. 


#include <iostream>
#include <string>
#include <fstream>
#include <vector> // 밑바닥 까지 파헤칠 것이다. 
#include <chrono>

//using namespace std;


// const char* : 이건 사용하지 않는것을 권장한다. 

void save(const std::string& fileName); 

// -------
int main()
// -------
{
	std::cout << "2023 STL" << '\n';
	std::cout << sizeof std::string << '\n';


	// 단계를 쫓아가면서 이유를 설명할 수 있어야한다. 
	save("STL.cpp");
	// return 0; 은 자동으로 들어간다.
}

void save(const std::string& fileName)
{
	/*
		STL 내용으로 코딩할 것이다.
	*/

	// 읽기 모드로 fileName 을 연다. 
	// 각종 생성자가 오버로딩 되어있다. 
	std::ifstream InputFile{ fileName }; // uniform 초기화 InputFile.close() 할 필요가 없다.  RAII 개념과 엮여있다. 자원을 초기화 함과 동시에 
	// 메모리 관리에 들어간다. java 의 garbage collection 과는 비교할 수 없다. 알아서 삭제된다. 
	// File Pointer ( 파일 처음 ) 한글자를 읽어오면 글자를 계속 읽어들인다. 

	// if(InputFile.opne()) // 주의 : 이런거 쓰면 0 점이다. 
	// 시험에 파일 읽어오는거 잇따. 
	
	// 저장할 파일을 덧붙여 쓰기 모드로 연다. 
	// 실행할때 마다 이 파일에 저장된다. ( 덧붙여 쓰인다. ) 
	std::ofstream outputFile{ "2023 1학기 STL 월23화56 강의저장.txt", std::ios::app }; // 확장자 없어도 여는데 문제 없다.  ( append  - ios::app -> 모든 출력은 파일의 끝에 추가된다. )

	outputFile << '\n' << '\n' << '\n';

	// 시간을 기록하는 코드 
	/*
		time points - epoch 이 단어에서 시작한다. ( 1월 1일 자정
		wlrma tlrksdl auctldi? zjavbxjsms 1970년 1월 1일 부터 말한다. - 이때부터 흘러간 시간을 대답한다 - time points
		( Duration )
	*/

	auto now = std::chrono::system_clock::now();	// 현재 시간  현재 Time Point 를 얻는다. 
	std::cout << now << '\n';						// C++ 17 에서 제공하는 기능이므로 언어표준을 최신을 ㅗ바꾸어야 힌다. - ETC
	//using namespace std::chrono;
	using namespace std::literals::chrono_literals;
	std::cout << now + 9h << '\n';

	// fileName 을 읽어 저장할 파일에 쓴다.
	// STL 자료구조와 알고리즘을 이용하여 작성 
	
	// istream_iterator 공백 무시함 
	// istreambuf_iterator 공백 무시안함 
	std::vector<char> v{ std::istreambuf_iterator<char> { InputFile }, {} /*비어있는 중괄호 : EOF */}; /* v 가 데이터를 다읽음 */
	//std::copy(v.begin(), v.end(), std::ostream_iterator<char>{ std::cout /* 화면에 출력하라 ( std::cout*/}/* [ 목적지 ] - 어디로 복사하라 ,,, */); // concept range 
	std::copy(v.begin(), v.end(), std::ostream_iterator<char>{ outputFile /* 화면에 출력하라 ( std::cout*/}/* [ 목적지 ] - 어디로 복사하라 ,,, */); // concept range 
	

}//  EOF

#endif // STL





#define STL
#ifdef STL

//
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
//	오늘의 주제 : 한학기 강의 저장 Save 코드 작성 
//
//	코딩 환경 통일 
//	VS Release/ X64 / Pointer 8 Byte 차지 
//	int : 4byte / 2byte이상 이 int 의 크기이다. 
//  속성 / SDL / 아니요 


#include <iostream>
#include <string>
#include <fstream>
#include <vector> // 밑바닥 까지 파헤칠 것이다. 
#include <chrono>

//using namespace std;


// const char* : 이건 사용하지 않는것을 권장한다. 

void save(const std::string& fileName); 

// -------
int main()
// -------
{
	std::cout << "2023 STL" << '\n';
	std::cout << sizeof std::string << '\n';


	using namespace	std::string_literals;
	// "STL.cpp"s : 임시 스트링이라고 지정해준다.
	save("STL.cpp"s);
}

void save(const std::string& fileName)
{
	std::ifstream InputFile{ fileName }; // uniform 초기화 InputFile.close() 할 필요가 없다.  RAII 개념과 엮여있다. 자원을 초기화 함과 동시에 
	std::ofstream outputFile{ "2023 1학기 STL 월23화56 강의저장.txt", std::ios::app }; // 확장자 없어도 여는데 문제 없다.  ( append  - ios::app -> 모든 출력은 파일의 끝에 추가된다. )
	outputFile << '\n' << '\n' << '\n';

	auto now = std::chrono::system_clock::now();	// 현재 시간  현재 Time Point 를 얻는다. 
	std::cout << now << '\n';						// C++ 17 에서 제공하는 기능이므로 언어표준을 최신을 ㅗ바꾸어야 힌다. - ETC

	auto utc = std::chrono::system_clock::to_time_t(now); // 06:24 // 현재 타임시간을 utc 로 바꾼다. UTC 시간을 ㅗ변경
	auto lt = std::localtime(&utc); // 한국시간을 찍을 수 있다.
	
	/*
		_s 를 써서 unsafe 경고 안나게 하는데 교슈님은 이렇게 하지 않으신다.

	
	*/
	std::cout.imbue(std::locale("ko_KR")); // 한국 데이터 형식을 바뀐다.
	std::cout << std::put_time(lt, "%x %A %X") << '\n';



	std::vector<char> v{ std::istreambuf_iterator<char> { InputFile }, {} /*비어있는 중괄호 : EOF */}; /* v 가 데이터를 다읽음 */
	std::copy(v.begin(), v.end(), std::ostream_iterator<char>{ outputFile /* 화면에 출력하라 ( std::cout*/}/* [ 목적지 ] - 어디로 복사하라 ,,, */); // concept range 
	

}//  EOF

#endif // STL




===============================================
STL.cpp저장시간 : 2023-03-07 화요일 오후 1:50:58
========================================


#define STL
#ifdef STL

//
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
//	오늘의 주제 : 한학기 강의 저장 Save 코드 작성 
//
//	코딩 환경 통일 
//	VS Release/ X64 / Pointer 8 Byte 차지 
//	int : 4byte / 2byte이상 이 int 의 크기이다. 
//  속성 / SDL / 아니요 


#include <iostream>
#include <string>
#include <fstream>
#include <vector> // 밑바닥 까지 파헤칠 것이다. 
#include <chrono>

//using namespace std;


// const char* : 이건 사용하지 않는것을 권장한다. 

void save(const std::string& fileName); 

// -------
int main()
// -------
{
	std::cout << "2023 STL" << '\n';
	std::cout << sizeof std::string << '\n';


	using namespace	std::string_literals;
	// "STL.cpp"s : 임시 스트링이라고 지정해준다.
	save("STL.cpp"s);
}

void save(const std::string& fileName)
{
	std::ifstream InputFile{ fileName }; // uniform 초기화 InputFile.close() 할 필요가 없다.  RAII 개념과 엮여있다. 자원을 초기화 함과 동시에 
	std::ofstream outputFile{ "2023 1학기 STL 월23화56 강의저장.txt", std::ios::app }; // 확장자 없어도 여는데 문제 없다.  ( append  - ios::app -> 모든 출력은 파일의 끝에 추가된다. )
	outputFile << '\n' << '\n' << '\n'; // 세줄 떼고 시작 

	auto now = std::chrono::system_clock::now();	// 현재 시간  현재 Time Point 를 얻는다. 
	std::cout << now << '\n';						// C++ 17 에서 제공하는 기능이므로 언어표준을 최신을 ㅗ바꾸어야 힌다. - ETC

	auto utc = std::chrono::system_clock::to_time_t(now); // 06:24 // 현재 타임시간을 utc 로 바꾼다. UTC 시간을 ㅗ변경
	auto lt = std::localtime(&utc); // 한국시간을 찍을 수 있다. -지역시간을 ㅗ변경 
	
	/*
		_s 를 써서 unsafe 경고 안나게 하는데 교슈님은 이렇게 하지 않으신다.

		다시한번 강조하지만 이런 코딩 할일은 없을거고 imbue 코딩 할일이 없다. 
		근데 알아는 둬야해
		변경하고서 터질 수 있으니 복구해야한다.

		원래 세팅을 저장해놓는 코딩ㅇ을 하고 내가 원하는 코딩을 한 이후에 되돌려놓는다,
		메모리 확보 릴리즈 하고 끝낸다. 
		원상복구 시킨다.
	
		imbue 를 숫자 찍을 때 , 한국은 네자리마다 찍는데 그렇게 찍고 싶을 때 한구긍로 바꾸고 찍는다.

	
	*/
	auto old = outputFile.imbue(std::locale("ko_KR")); // 대한민국으로 지역변경
	outputFile << "========================================" << '\n';
	outputFile << fileName << std::put_time(lt, "저장시간 : %x %A %X") << '\n'; // 한국 시간으로 파일에 출력 
	outputFile << "========================================" << '\n';
	outputFile << '\n';



	outputFile.imbue(old);							// 원래 지역으로 변경 


	std::vector<char> v{ std::istreambuf_iterator<char> { InputFile }, {} /*비어있는 중괄호 : EOF */}; /* v 가 데이터를 다읽음 */
	std::copy(v.begin(), v.end(), std::ostream_iterator<char>{ outputFile /* 화면에 출력하라 ( std::cout*/}/* [ 목적지 ] - 어디로 복사하라 ,,, */); // concept range 
	

}//  EOF

#endif // STL




===============================================
STL.cpp저장시간 : 2023-03-07 화요일 오후 1:55:19
===============================================


#define STL
#ifdef STL

//
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
//	오늘의 주제 : 한학기 강의 저장 Save 코드 작성 , SAve() 파일로 분리 
//
//	코딩 환경 통일 
//	VS Release/ X64 / Pointer 8 Byte 차지 
//	int : 4byte / 2byte이상 이 int 의 크기이다. 
//  속성 / SDL / 아니요 


#include <iostream>
#include <string>
#include <fstream>
#include <vector> // 밑바닥 까지 파헤칠 것이다. 
#include <chrono>

#include "save.h"


//using namespace std;


// const char* : 이건 사용하지 않는것을 권장한다. 

void save(const std::string& fileName); 

// -------
int main()
// -------
{
	std::cout << "2023 STL" << '\n';
	std::cout << sizeof std::string << '\n';


	using namespace	std::string_literals;
	// "STL.cpp"s : 임시 스트링이라고 지정해준다.
	save("STL.cpp"s);
}


#endif // STL




===============================================
STL.cpp저장시간 : 2023-03-07 화요일 오후 2:05:29
===============================================


#define STL
#ifdef STL

//
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
//	오늘의 주제 : 한학기 강의 저장 Save 코드 작성 , SAve() 파일로 분리 
//
//	코딩 환경 통일 
//	VS Release/ X64 / Pointer 8 Byte 차지 
//	int : 4byte / 2byte이상 이 int 의 크기이다. 
//  속성 / SDL / 아니요 


#include <iostream>
#include "save.h"

// -------
int main()
// -------
{
	std::cout << "2023 STL" << '\n';
	std::cout << sizeof std::string << '\n';


	using namespace	std::string_literals;
	// "STL.cpp"s : 임시 스트링이라고 지정해준다.
	save("STL.cpp"s);
}


#endif // STL




===============================================
save.h저장시간 : 2023-03-07 화요일 오후 2:07:08
===============================================


// -------------------------------------------------
// save.h : 한 학기 강의 저장하는 함수 
// -------------------------------------------------
//#pragma once 





#ifndef SAVE_FILE
#define SAVE_FILE



void save(const std::string& fileName);


#endif // SAVE_FILE





===============================================
save.cpp저장시간 : 2023-03-07 화요일 오후 2:07:08
===============================================



// -------------------------------------------------
// save.h : 한 학기 강의 저장하는 함수 
// -------------------------------------------------

#include <string>
#include <fstream>
#include <chrono>
#include <iostream>


#include "save.h"

void save(const std::string& fileName)
{
	std::ifstream InputFile{ fileName }; // uniform 초기화 InputFile.close() 할 필요가 없다.  RAII 개념과 엮여있다. 자원을 초기화 함과 동시에 
	std::ofstream outputFile{ "2023 1학기 STL 월23화56 강의저장.txt", std::ios::app }; // 확장자 없어도 여는데 문제 없다.  ( append  - ios::app -> 모든 출력은 파일의 끝에 추가된다. )
	outputFile << '\n' << '\n' << '\n'; // 세줄 떼고 시작 

	auto now = std::chrono::system_clock::now();	// 현재 시간  현재 Time Point 를 얻는다. 
	std::cout << now << '\n';						// C++ 17 에서 제공하는 기능이므로 언어표준을 최신을 ㅗ바꾸어야 힌다. - ETC

	auto utc = std::chrono::system_clock::to_time_t(now); // 06:24 // 현재 타임시간을 utc 로 바꾼다. UTC 시간을 ㅗ변경
	auto lt = std::localtime(&utc); // 한국시간을 찍을 수 있다. -지역시간을 ㅗ변경 

	/*
		_s 를 써서 unsafe 경고 안나게 하는데 교슈님은 이렇게 하지 않으신다.

		다시한번 강조하지만 이런 코딩 할일은 없을거고 imbue 코딩 할일이 없다.
		근데 알아는 둬야해
		변경하고서 터질 수 있으니 복구해야한다.

		원래 세팅을 저장해놓는 코딩ㅇ을 하고 내가 원하는 코딩을 한 이후에 되돌려놓는다,
		메모리 확보 릴리즈 하고 끝낸다.
		원상복구 시킨다.

		imbue 를 숫자 찍을 때 , 한국은 네자리마다 찍는데 그렇게 찍고 싶을 때 한구긍로 바꾸고 찍는다.


	*/
	auto old = outputFile.imbue(std::locale("ko_KR")); // 대한민국으로 지역변경
	outputFile << "===============================================" << '\n';
	outputFile << fileName << std::put_time(lt, "저장시간 : %x %A %X") << '\n'; // 한국 시간으로 파일에 출력 
	outputFile << "===============================================" << '\n';
	outputFile << '\n';



	outputFile.imbue(old);							// 원래 지역으로 변경 


	std::vector<char> v{ std::istreambuf_iterator<char> { InputFile }, {} /*비어있는 중괄호 : EOF */ }; /* v 가 데이터를 다읽음 */
	std::copy(v.begin(), v.end(), std::ostream_iterator<char>{ outputFile /* 화면에 출력하라 ( std::cout*/}/* [ 목적지 ] - 어디로 복사하라 ,,, */); // concept range 


}//  EOF


===============================================
STL.cpp저장시간 : 2023-03-07 화요일 오후 2:07:08
===============================================


#define STL
#ifdef STL

//
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
//	오늘의 주제 : 한학기 강의 저장 Save 코드 작성 , SAve() 파일로 분리 
//
//	코딩 환경 통일 
//	VS Release/ X64 / Pointer 8 Byte 차지 
//	int : 4byte / 2byte이상 이 int 의 크기이다. 
//  속성 / SDL / 아니요 


#include <iostream>
#include "save.h"

// -------
int main()
// -------
{
	std::cout << "2023 STL 강의할 준ㅂ가 되었다." << '\n';
	std::cout << sizeof std::string << '\n';


	using namespace	std::string_literals;

	save("save.h"s);
	save("save.cpp"s);
	save("STL.cpp"s);
}


#endif // STL




===============================================
STL.cpp저장시간 : 2023-03-07 화요일 오후 2:11:49
===============================================


#define STL
#ifdef STL

// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// C++ 복습 , template
// --------------------------------------------------

#include <iostream>
#include "save.h"


using namespace std;

// [ 문제 ]

// main ()을 고치지 말고 의도 대로 

void change(int& a, int& b)
{
	int tmp = b;
	b = a;
	a = tmp;
}

// -------
int main()
// -------
{
	int a{ 1 }, b{ 2 };

	change(a, b);
	cout << a << " , " << b << endl; // 2 , 1



	using namespace	std::string_literals;
	save("STL.cpp"s);

}


#endif // STL




===============================================
STL.cpp저장시간 : 2023-03-07 화요일 오후 2:12:50
===============================================


#define STL
#ifdef STL

// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// C++ 복습 , template
// --------------------------------------------------

#include <iostream>
#include "save.h"


using namespace std;

// [ 문제 ]

// main ()을 고치지 말고 의도 대로 

void change( int& a, int& b)
{
	int tmp = b;
	b = a;
	a = tmp;
}

// -------
int main()
// -------
{
	int a{ 1 }, b{ 2 };

	change(a, b);
	cout << a << " , " << b << endl; // 2 , 1



	using namespace	std::string_literals;
	save("STL.cpp"s);

}


#endif // STL




===============================================
STL.cpp저장시간 : 2023-03-07 화요일 오후 2:56:19
===============================================


#define STL
#ifdef STL

// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// C++ 복습 , template
// --------------------------------------------------

#include <iostream>
#include "save.h"


using namespace std;

// [ 문제 ]

// main ()을 고치지 말고 의도 대로 실행 하라.

/*
	선언과 정의를 분리해서 적자.



	Stack : [ a : 1 ]
			[ b : 2 ] 

	~~ free Store

	Data : 
	Code :			- main
					- save
					- change 


	원격조작 -> *  ( C )  *, & ( C++ )
	*	*(pointer) & ( Reference ) -> 완변하게 같다. 포장지만 다르다.
	* 레퍼런스 포인터 기호 없이 써리.
	* 원격 조작 얼마든지 가능하게 해줄게
	* 
	* 
	* main -> change 로 점프한다. 점프 가정이 가장 중요하다.
	* 스택 이용해서 점프하는 과정이 오버헤드가 크다.
	* Change 함수가 스택에서 가져온다.
	* 1,2 주소값 씨언어에서는 명시적으로 주소를 써서 전달한다.
	* 씨플플은 call by Reference를 지원한다.
	* 씨는 이런게 있지 않다. call by Value 
	* 따라서 씨언어는 절대 change(a,b) 로 바뀔 수 없다.
	* call by value 라서 주소값을 넘겨야 하기 때문이다. 
	* 씨플플에서는 change 정의에 따라 바뀔수도 아닐 수도 있따. 
	* 



*/

class Dog {
private:
	int n;
public:
	Dog(int a) : n{ a } {};
	~Dog() {};
	friend ostream& operator<<(ostream& os, const Dog& dog)
	{
		return os << dog.n;
	}
};

void change(int&, int&);
void change(Dog&, Dog&);


// -------
int main()
// -------
{

	{
		Dog a = 1, b = 2;

		change(a, b);
		cout << a << " , " << b << endl; // 2 , 1
	}



	{
		int a{ 1 }, b{ 2 };

		change(a, b);
		cout << a << " , " << b << endl; // 2 , 1
	}


	using namespace	std::string_literals;
	save("STL.cpp"s);

}




void change(int& a, int& b)
{
	int tmp{ b };
	b = a;
	a = tmp;
}

void change(Dog& a, Dog& b)
{
	Dog tmp{ a };
	a = b;
	b = tmp;
}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-07 화요일 오후 3:00:49
===============================================


#define STL
#ifdef STL

// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// C++ 복습 , template
// --------------------------------------------------

#include <iostream>
#include "save.h"


using namespace std;

// [ 문제 ]

// main ()을 고치지 말고 의도 대로 실행 하라.
// Change 함수를 한번만 코딩해서 하라.


/*
	선언과 정의를 분리해서 적자.



	Stack : [ a : 1 ]
			[ b : 2 ] 

	~~ free Store

	Data : 
	Code :			- main
					- save
					- change 


	원격조작 -> *  ( C )  *, & ( C++ )
	*	*(pointer) & ( Reference ) -> 완변하게 같다. 포장지만 다르다.
	* 레퍼런스 포인터 기호 없이 써리.
	* 원격 조작 얼마든지 가능하게 해줄게
	* 
	* 
	* main -> change 로 점프한다. 점프 가정이 가장 중요하다.
	* 스택 이용해서 점프하는 과정이 오버헤드가 크다.
	* Change 함수가 스택에서 가져온다.
	* 1,2 주소값 씨언어에서는 명시적으로 주소를 써서 전달한다.
	* 씨플플은 call by Reference를 지원한다.
	* 씨는 이런게 있지 않다. call by Value 
	* 따라서 씨언어는 절대 change(a,b) 로 바뀔 수 없다.
	* call by value 라서 주소값을 넘겨야 하기 때문이다. 
	* 씨플플에서는 change 정의에 따라 바뀔수도 아닐 수도 있따. 
	* 

	vlfdygks tnsrksdp zjavbxjdprp aksemfdjwnj


*/

class Dog {
private:
	int n;
public:
	Dog(int a) : n{ a } {};
	~Dog() {};
	friend ostream& operator<<(ostream& os, const Dog& dog)
	{
		return os << dog.n;
	}
};

template<typename T>
void change(T&, T &);
// -------
int main()
// -------
{

	{
		Dog a = 1, b = 2;

		change(a, b);
		cout << a << " , " << b << endl; // 2 , 1
	}



	{
		int a{ 1 }, b{ 2 };

		change(a, b);
		cout << a << " , " << b << endl; // 2 , 1
	}


	using namespace	std::string_literals;
	save("STL.cpp"s);

}



template<typename T>
void change(T& a, T& b)
{
	T tmp{ b };
	b = a;
	a = tmp;
}



#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오전 10:44:55
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
using namespace std;
/*
		시험 문제 1번은 파일을 읽는 것이다. 
		

		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	uniform_int_distribution uid; // 로또 뽑을 때 쓰는 코드 
	
	for (int i = 0; i < 1'000; ++i)
	{
		cout << uid(dre) << '\n';						// uniform 하게 가공한다. 
	
	}


	
	save("STL.cpp");
}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오전 10:45:28
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
using namespace std;
/*
		시험 문제 1번은 파일을 읽는 것이다. 
		

		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	uniform_int_distribution uid; // 로또 뽑을 때 쓰는 코드 
	
	for (int i = 0; i < 1'000; ++i)
	{
		cout << uid(dre) << '\n';						// uniform 하게 가공한다. 
	
	}


	
	save("STL.cpp");
}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오전 10:47:35
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
using namespace std;
/*
		시험 문제 1번은 파일을 읽는 것이다. 
		

		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	uniform_int_distribution<int> uid{1234} ; // 로또 뽑을 때 쓰는 코드 
	
	for (int i = 0; i < 1'000; ++i)
	{
		cout << uid(dre) << '\n';						// uniform 하게 가공한다. 
	
	}


	
	save("STL.cpp");
}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오전 10:47:50
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
using namespace std;
/*
		시험 문제 1번은 파일을 읽는 것이다. 
		

		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	uniform_int_distribution<int> uid{1234} ; // 로또 뽑을 때 쓰는 코드 
	
	for (int i = 0; i < 10; ++i)
	{
		cout << uid(dre) << '\n';						// uniform 하게 가공한다. 
	
	}


	
	save("STL.cpp");
}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오전 10:49:05
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
using namespace std;
/*
		시험 문제 1번은 파일을 읽는 것이다. 
		

		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	uniform_int_distribution<int> uid{1234} ; // 로또 뽑을 때 쓰는 코드 
	
	for (int i = 0; i < 10; ++i)
	{
		cout << uid(dre) << "";						// uniform 하게 가공한다. 
	
	}


	
	save("STL.cpp");
}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오전 10:50:36
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
using namespace std;
/*
		시험 문제 1번은 파일을 읽는 것이다. 
		

		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	// uniform_int_distribution<int> uid{0, 9999} -> 0 ~ 9999 사이의 랜덤한 값을 만들고 확률은 일정하게 해줘  
	uniform_int_distribution<int> uid{0, 9999}; // 로또 뽑을 때 쓰는 코드 
	
	for (int i = 0; i < 100; ++i)
	{
		// int 0 ~ intMax 까지 의 숫자중 랜덤한 값이 찍힌다. 
		// 
		// 칸 맞춰서 찍고 싶다면 ? -> 
		cout << uid(dre) << " ";						// uniform 하게 가공한다. 
	
	}


	
	save("STL.cpp");
}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오전 10:51:05
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
using namespace std;
/*
		시험 문제 1번은 파일을 읽는 것이다. 
		

		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	// uniform_int_distribution<int> uid{0, 9999} -> 0 ~ 9999 사이의 랜덤한 값을 만들고 확률은 일정하게 해줘  
	uniform_int_distribution<int> uid{0, 9999}; // 로또 뽑을 때 쓰는 코드 
	
	for (int i = 0; i < 100; ++i)
	{
		// int 0 ~ intMax 까지 의 숫자중 랜덤한 값이 찍힌다. 
		// 
		// 칸 맞춰서 찍고 싶다면 ? -> 
		cout << uid(dre) << " ";						// uniform 하게 가공한다. 
	
	}


	
	save("STL.cpp");
}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오전 10:51:28
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
using namespace std;
/*
		시험 문제 1번은 파일을 읽는 것이다. 
		

		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	// uniform_int_distribution<int> uid{0, 9999} -> 0 ~ 9999 사이의 랜덤한 값을 만들고 확률은 일정하게 해줘  
	uniform_int_distribution<int> uid{0, 9999}; // 로또 뽑을 때 쓰는 코드 
	
	for (int i = 0; i < 100; ++i)
	{
		// int 0 ~ intMax 까지 의 숫자중 랜덤한 값이 찍힌다. 
		// 
		// 칸 맞춰서 찍고 싶다면 ? -> 
		cout << uid(dre) << " ";						// uniform 하게 가공한다. 
	
	}


	
	save("STL.cpp");
}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오전 10:51:34
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
using namespace std;
/*
		시험 문제 1번은 파일을 읽는 것이다. 
		

		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	// uniform_int_distribution<int> uid{0, 9999} -> 0 ~ 9999 사이의 랜덤한 값을 만들고 확률은 일정하게 해줘  
	uniform_int_distribution<int> uid{0, 9999}; // 로또 뽑을 때 쓰는 코드 
	
	for (int i = 0; i < 100; ++i)
	{
		// int 0 ~ intMax 까지 의 숫자중 랜덤한 값이 찍힌다. 
		// 
		// 칸 맞춰서 찍고 싶다면 ? -> 
		cout << uid(dre) << " ";						// uniform 하게 가공한다. 
	
	}


	
	save("STL.cpp");
}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오전 10:51:38
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
using namespace std;
/*
		시험 문제 1번은 파일을 읽는 것이다. 
		

		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	// uniform_int_distribution<int> uid{0, 9999} -> 0 ~ 9999 사이의 랜덤한 값을 만들고 확률은 일정하게 해줘  
	uniform_int_distribution<int> uid{0, 9999}; // 로또 뽑을 때 쓰는 코드 
	
	for (int i = 0; i < 100; ++i)
	{
		// int 0 ~ intMax 까지 의 숫자중 랜덤한 값이 찍힌다. 
		// 
		// 칸 맞춰서 찍고 싶다면 ? -> 
		cout << uid(dre) << " ";						// uniform 하게 가공한다. 
	
	}


	
	save("STL.cpp");
}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오전 10:54:08
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>

using namespace std;
/*
		시험 문제 1번은 파일을 읽는 것이다. 
		

		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	// uniform_int_distribution<int> uid{0, 9999} -> 0 ~ 9999 사이의 랜덤한 값을 만들고 확률은 일정하게 해줘  
	uniform_int_distribution<int> uid{0, 9999}; // 로또 뽑을 때 쓰는 코드 
	
	for (int i = 0; i < 100; ++i)
	{
		// int 0 ~ intMax 까지 의 숫자중 랜덤한 값이 찍힌다. 
		// 
		// 칸 맞춰서 찍고 싶다면 ? -> format 함수 
		cout << format("{:0}",uid(dre));						// uniform 하게 가공한다. 
	
	}


	
	save("STL.cpp");
}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오전 10:54:33
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>

using namespace std;
/*
		시험 문제 1번은 파일을 읽는 것이다. 
		

		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	// uniform_int_distribution<int> uid{0, 9999} -> 0 ~ 9999 사이의 랜덤한 값을 만들고 확률은 일정하게 해줘  
	uniform_int_distribution<int> uid{0, 9999}; // 로또 뽑을 때 쓰는 코드 
	
	for (int i = 0; i < 100; ++i)
	{
		// int 0 ~ intMax 까지 의 숫자중 랜덤한 값이 찍힌다. 
		// 
		// 칸 맞춰서 찍고 싶다면 ? -> format 함수 
		cout << format("{:0}",uid(dre));						// uniform 하게 가공한다. 
	
	}


	
	save("STL.cpp");
}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오전 10:54:48
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>

using namespace std;
/*
		시험 문제 1번은 파일을 읽는 것이다. 
		

		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	// uniform_int_distribution<int> uid{0, 9999} -> 0 ~ 9999 사이의 랜덤한 값을 만들고 확률은 일정하게 해줘  
	uniform_int_distribution<int> uid{0, 9999}; // 로또 뽑을 때 쓰는 코드 
	
	for (int i = 0; i < 100; ++i)
	{
		// int 0 ~ intMax 까지 의 숫자중 랜덤한 값이 찍힌다. 
		// 
		// 칸 맞춰서 찍고 싶다면 ? -> format 함수 
		cout << format("{:8}",uid(dre));						// uniform 하게 가공한다. 
	
	}


	
	save("STL.cpp");
}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오전 10:54:58
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>

using namespace std;
/*
		시험 문제 1번은 파일을 읽는 것이다. 
		

		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	// uniform_int_distribution<int> uid{0, 9999} -> 0 ~ 9999 사이의 랜덤한 값을 만들고 확률은 일정하게 해줘  
	uniform_int_distribution<int> uid{0, 9999}; // 로또 뽑을 때 쓰는 코드 
	
	for (int i = 0; i < 100; ++i)
	{
		// int 0 ~ intMax 까지 의 숫자중 랜덤한 값이 찍힌다. 
		// 
		// 칸 맞춰서 찍고 싶다면 ? -> format 함수 
		cout << format("{:<8}",uid(dre));						// uniform 하게 가공한다. 
	
	}


	
	save("STL.cpp");
}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오전 10:55:29
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>

using namespace std;
/*
		시험 문제 1번은 파일을 읽는 것이다. 
		

		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	// uniform_int_distribution<int> uid{0, 9999} -> 0 ~ 9999 사이의 랜덤한 값을 만들고 확률은 일정하게 해줘  
	uniform_int_distribution<int> uid{0, 9999}; // 로또 뽑을 때 쓰는 코드 
	
	for (int i = 0; i < 100; ++i)
	{
		// int 0 ~ intMax 까지 의 숫자중 랜덤한 값이 찍힌다. 
		// 
		// 칸 맞춰서 찍고 싶다면 ? -> format 함수 
		cout << format("{:<80}",uid(dre));						// uniform 하게 가공한다. 
	
	}


	
	save("STL.cpp");
}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오전 10:55:56
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>

using namespace std;
/*
		시험 문제 1번은 파일을 읽는 것이다. 
		

		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	// uniform_int_distribution<int> uid{0, 9999} -> 0 ~ 9999 사이의 랜덤한 값을 만들고 확률은 일정하게 해줘  
	uniform_int_distribution<int> uid{0, 9999}; // 로또 뽑을 때 쓰는 코드 
	
	for (int i = 0; i < 100; ++i)
	{
		// int 0 ~ intMax 까지 의 숫자중 랜덤한 값이 찍힌다. 
		// 
		// 칸 맞춰서 찍고 싶다면 ? -> format 함수 
		
		// < 왼쪽으로 / ^ 위로 
		cout << format("{:^80}",uid(dre));						// uniform 하게 가공한다. 
	
	}


	
	save("STL.cpp");
}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오전 10:57:34
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>

using namespace std;
/*
		시험 문제 1번은 파일을 읽는 것이다. 
		

		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	// uniform_int_distribution<int> uid{0, 9999} -> 0 ~ 9999 사이의 랜덤한 값을 만들고 확률은 일정하게 해줘  
	uniform_int_distribution<int> uid{0, 9999}; // 로또 뽑을 때 쓰는 코드 
	
	for (int i = 0; i < 1'000; ++i)
	{
		// int 0 ~ intMax 까지 의 숫자중 랜덤한 값이 찍힌다. 
		// 
		// 칸 맞춰서 찍고 싶다면 ? -> format 함수 
		
		int num = uid(dre);
		// < 왼쪽으로 / ^ 위로 
		cout << format("{:8}", num);						// uniform 하게 가공한다. 
	
	}


	
	save("STL.cpp");
}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오전 11:00:13
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>

using namespace std;
/*
* [Q] : 램던 int 1000개 중 가장 큰 값을 찾아 화면에 출력하라 
		시험 문제 1번은 파일을 읽는 것이다. 
		

		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	// uniform_int_distribution<int> uid{0, 9999} -> 0 ~ 9999 사이의 랜덤한 값을 만들고 확률은 일정하게 해줘  
	uniform_int_distribution<int> uid{0, 9999}; // 로또 뽑을 때 쓰는 코드 
	int Max = -1;


	for (int i = 0; i < 1'000; ++i)
	{
		// int 0 ~ intMax 까지 의 숫자중 랜덤한 값이 찍힌다. 
		// 
		// 칸 맞춰서 찍고 싶다면 ? -> format 함수 
		
		int num = uid(dre);
		// < 왼쪽으로 / ^ 위로 
		cout << format("{:8}", num);						// uniform 하게 가공한다. 
		if (Max < num)
			Max = num;
	
	}

	cout << "Max : " << Max << '\n';


	
	save("STL.cpp");
}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오전 11:00:28
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>

using namespace std;
/*
* [Q] : 램던 int 1000개 중 가장 큰 값을 찾아 화면에 출력하라 
		시험 문제 1번은 파일을 읽는 것이다. 
		

		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	// uniform_int_distribution<int> uid{0, 9999} -> 0 ~ 9999 사이의 랜덤한 값을 만들고 확률은 일정하게 해줘  
	uniform_int_distribution<int> uid{0, 9999}; // 로또 뽑을 때 쓰는 코드 
	int Max = -1;


	for (int i = 0; i < 1'000; ++i)
	{
		// int 0 ~ intMax 까지 의 숫자중 랜덤한 값이 찍힌다. 
		// 
		// 칸 맞춰서 찍고 싶다면 ? -> format 함수 
		
		int num = uid(dre);
		// < 왼쪽으로 / ^ 위로 
		cout << format("{:8}", num);						// uniform 하게 가공한다. 
		if (Max < num)
			Max = num;
	
	}

	cout << '\n\n' << "Max : " << Max << '\n';


	
	save("STL.cpp");
}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오전 11:00:35
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>

using namespace std;
/*
* [Q] : 램던 int 1000개 중 가장 큰 값을 찾아 화면에 출력하라 
		시험 문제 1번은 파일을 읽는 것이다. 
		

		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	// uniform_int_distribution<int> uid{0, 9999} -> 0 ~ 9999 사이의 랜덤한 값을 만들고 확률은 일정하게 해줘  
	uniform_int_distribution<int> uid{0, 9999}; // 로또 뽑을 때 쓰는 코드 
	int Max = -1;
	for (int i = 0; i < 1'000; ++i)
	{
		// int 0 ~ intMax 까지 의 숫자중 랜덤한 값이 찍힌다. 
		// 
		// 칸 맞춰서 찍고 싶다면 ? -> format 함수 
		
		int num = uid(dre);
		// < 왼쪽으로 / ^ 위로 
		cout << format("{:8}", num);						// uniform 하게 가공한다. 
		if (Max < num)
			Max = num;
	
	}

	cout << '\n\n' << "Max : " << Max << '\n';


	
	save("STL.cpp");
}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오전 11:01:04
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>

using namespace std;
/*
* [Q] : 램던 int 1000개 중 가장 큰 값을 찾아 화면에 출력하라 
		시험 문제 1번은 파일을 읽는 것이다. 
		

		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	// uniform_int_distribution<int> uid{0, 9999} -> 0 ~ 9999 사이의 랜덤한 값을 만들고 확률은 일정하게 해줘  
	uniform_int_distribution<int> uid{0, 9999}; // 로또 뽑을 때 쓰는 코드 
	int Max = -1;


	for (int i = 0; i < 1'000; ++i)
	{
		// int 0 ~ intMax 까지 의 숫자중 랜덤한 값이 찍힌다. 
		// 
		// 칸 맞춰서 찍고 싶다면 ? -> format 함수 
		
		int num = uid(dre);
		// < 왼쪽으로 / ^ 위로 
		cout << format("{:8}", num);						// uniform 하게 가공한다. 
		if (Max < num)
			Max = num;
	
	}

	cout << '\n\n' << "Max : " << Max << '\n';


	
	save("STL.cpp");
}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오전 11:09:28
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>
#include <limits>


using namespace std;
/*
* [Q] : 램던 int 1000개 중 가장 큰 값을 찾아 화면에 출력하라 
		시험 문제 1번은 파일을 읽는 것이다. 
		

		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	// uniform_int_distribution<int> uid{0, 9999} -> 0 ~ 9999 사이의 랜덤한 값을 만들고 확률은 일정하게 해줘  
	uniform_int_distribution<int> uid{0, 9999}; // 로또 뽑을 때 쓰는 코드 
	//int MaxValue = INT_MIN;  // int 가 가질 수 있는 최솟값 
	int MaxValue = numeric_limits<int>::min();

	for (int i = 0; i < 1'000'00; ++i)
	{
		// int 0 ~ intMax 까지 의 숫자중 랜덤한 값이 찍힌다. 
		// 칸 맞춰서 찍고 싶다면 ? -> format 함수 
		
		int num = uid(dre);
		// < 왼쪽으로 / ^ 위로 
		//cout << format("{:8}", num);						// uniform 하게 가공한다. 
		if (MaxValue < num)
			MaxValue = num;
	
		/*
			가장 큰 값을 찾기 위해서는 기준점이 필요하다.
			기준점을 뭘로 잡을 수가 있을까?

		*/
	}

	cout << "최댓값 : " << MaxValue << endl;
	save("STL.cpp");
}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오전 11:17:33
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>
#include <limits>
#include <fstream>


using namespace std;
/*
* [Q] : 램던 int 1000개 중 가장 큰 값을 찾아 화면에 출력하라 
		시험 문제 1번은 파일을 읽는 것이다. 
	[Q] : 램던 int 1000 개를 생성하여 파일 int 천개에 저장하라  


		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	// uniform_int_distribution<int> uid{0, 9999} -> 0 ~ 9999 사이의 랜덤한 값을 만들고 확률은 일정하게 해줘  
	uniform_int_distribution<int> uid{0, 9999}; // 로또 뽑을 때 쓰는 코드 
	//int MaxValue = INT_MIN;  // int 가 가질 수 있는 최솟값 
	int MaxValue = numeric_limits<int>::min();

	for (int i = 0; i < 1'000; ++i)
	{
		// int 0 ~ intMax 까지 의 숫자중 랜덤한 값이 찍힌다. 
		// 칸 맞춰서 찍고 싶다면 ? -> format 함수 
		
		int num = uid(dre);
		// < 왼쪽으로 / ^ 위로 
		//cout << format("{:8}", num);						// uniform 하게 가공한다. 
		if (MaxValue < num)
			MaxValue = num;
	
		/*
			가장 큰 값을 찾기 위해서는 기준점이 필요하다.
			기준점을 뭘로 잡을 수가 있을까?

		*/

		// 가장 중요한 개념 : RAII : Resource Acquisition Is Initialization
		// 만듦과 동시에 초기화 
		std::ofstream	OutFile{ "int 천개", std::ios::app };						// 쓰기모드로 파일을 연다 ( app : 덧붙여 쓰기 모드 )
		OutFile << num;


		// OutFIle.close() 같은 코딩은 하면 안된다. 
		// 자동으로 자원이 닫히고 반환된더ㅏ. ( RAII에 의해서... ) 

	}

	cout << "최댓값 : " << MaxValue << endl;
	save("STL.cpp");
}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오전 11:18:15
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>
#include <limits>
#include <fstream>


using namespace std;
/*
* [Q] : 램던 int 1000개 중 가장 큰 값을 찾아 화면에 출력하라 
		시험 문제 1번은 파일을 읽는 것이다. 
	[Q] : 램던 int 1000 개를 생성하여 파일 int 천개에 저장하라  


		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	// uniform_int_distribution<int> uid{0, 9999} -> 0 ~ 9999 사이의 랜덤한 값을 만들고 확률은 일정하게 해줘  
	uniform_int_distribution<int> uid{0, 9999}; // 로또 뽑을 때 쓰는 코드 
	//int MaxValue = INT_MIN;  // int 가 가질 수 있는 최솟값 
	int MaxValue = numeric_limits<int>::min();

	for (int i = 0; i < 1'000; ++i)
	{
		// int 0 ~ intMax 까지 의 숫자중 랜덤한 값이 찍힌다. 
		// 칸 맞춰서 찍고 싶다면 ? -> format 함수 
		
		int num = uid(dre);
		// < 왼쪽으로 / ^ 위로 
		//cout << format("{:8}", num);						// uniform 하게 가공한다. 
		if (MaxValue < num)
			MaxValue = num;
	
		/*
			가장 큰 값을 찾기 위해서는 기준점이 필요하다.
			기준점을 뭘로 잡을 수가 있을까?

		*/

		// 가장 중요한 개념 : RAII : Resource Acquisition Is Initialization
		// 만듦과 동시에 초기화 
		std::ofstream	OutFile{ "int 천개", std::ios::app };						// 쓰기모드로 파일을 연다 ( app : 덧붙여 쓰기 모드 )
		OutFile << format("{:8}", num);


		// OutFIle.close() 같은 코딩은 하면 안된다. 
		// 자동으로 자원이 닫히고 반환된더ㅏ. ( RAII에 의해서... ) 

	}

	cout << "최댓값 : " << MaxValue << endl;
	save("STL.cpp");
}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오전 11:18:37
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>
#include <limits>
#include <fstream>


using namespace std;
/*
* [Q] : 램던 int 1000개 중 가장 큰 값을 찾아 화면에 출력하라 
		시험 문제 1번은 파일을 읽는 것이다. 
	[Q] : 램던 int 1000 개를 생성하여 파일 int 천개에 저장하라  


		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	// uniform_int_distribution<int> uid{0, 9999} -> 0 ~ 9999 사이의 랜덤한 값을 만들고 확률은 일정하게 해줘  
	uniform_int_distribution<int> uid{0, 9999}; // 로또 뽑을 때 쓰는 코드 
	//int MaxValue = INT_MIN;  // int 가 가질 수 있는 최솟값 
	int MaxValue = numeric_limits<int>::min();

	for (int i = 0; i < 1'000; ++i)
	{
		// int 0 ~ intMax 까지 의 숫자중 랜덤한 값이 찍힌다. 
		// 칸 맞춰서 찍고 싶다면 ? -> format 함수 
		
		int num = uid(dre);
		// < 왼쪽으로 / ^ 위로 
		//cout << format("{:8}", num);						// uniform 하게 가공한다. 
		if (MaxValue < num)
			MaxValue = num;
	
		/*
			가장 큰 값을 찾기 위해서는 기준점이 필요하다.
			기준점을 뭘로 잡을 수가 있을까?

		*/

		// 가장 중요한 개념 : RAII : Resource Acquisition Is Initialization
		// 만듦과 동시에 초기화 
		std::ofstream	OutFile{ "int 천개", std::ios::app };						// 쓰기모드로 파일을 연다 ( app : 덧붙여 쓰기 모드 )
		OutFile << format("{:8}", num);
		if (i % 8 == 0)
			OutFile << '\n';


		// OutFIle.close() 같은 코딩은 하면 안된다. 
		// 자동으로 자원이 닫히고 반환된더ㅏ. ( RAII에 의해서... ) 

	}

	cout << "최댓값 : " << MaxValue << endl;
	save("STL.cpp");
}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오전 11:19:07
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>
#include <limits>
#include <fstream>


using namespace std;
/*
* [Q] : 램던 int 1000개 중 가장 큰 값을 찾아 화면에 출력하라 
		시험 문제 1번은 파일을 읽는 것이다. 
	[Q] : 램던 int 1000 개를 생성하여 파일 int 천개에 저장하라  


		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	// uniform_int_distribution<int> uid{0, 9999} -> 0 ~ 9999 사이의 랜덤한 값을 만들고 확률은 일정하게 해줘  
	uniform_int_distribution<int> uid{0, 9999}; // 로또 뽑을 때 쓰는 코드 
	//int MaxValue = INT_MIN;  // int 가 가질 수 있는 최솟값 
	int MaxValue = numeric_limits<int>::min();

	for (int i = 0; i < 1'000; ++i)
	{
		// int 0 ~ intMax 까지 의 숫자중 랜덤한 값이 찍힌다. 
		// 칸 맞춰서 찍고 싶다면 ? -> format 함수 
		
		int num = uid(dre);
		// < 왼쪽으로 / ^ 위로 
		//cout << format("{:8}", num);						// uniform 하게 가공한다. 
		if (MaxValue < num)
			MaxValue = num;
	
		/*
			가장 큰 값을 찾기 위해서는 기준점이 필요하다.
			기준점을 뭘로 잡을 수가 있을까?

		*/

		// 가장 중요한 개념 : RAII : Resource Acquisition Is Initialization
		// 만듦과 동시에 초기화 
		std::ofstream	OutFile{ "int 천개", std::ios::app };						// 쓰기모드로 파일을 연다 ( app : 덧붙여 쓰기 모드 )
		OutFile << format("{:8}", num);
		if (i % 8 == 0)
			OutFile << '\n';


		// OutFIle.close() 같은 코딩은 하면 안된다. 
		// 자동으로 자원이 닫히고 반환된더ㅏ. ( RAII에 의해서... ) 

	}

	cout << "최댓값 : " << MaxValue << endl;
	save("STL.cpp");
}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오전 11:23:52
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>
#include <limits>
#include <fstream>


using namespace std;
/*
* [Q] : 램던 int 1000개 중 가장 큰 값을 찾아 화면에 출력하라 
		시험 문제 1번은 파일을 읽는 것이다. 
	[Q] : 램던 int 1000 개를 생성하여 파일 int 천개에 저장하라  
	[Q] : 파일'int 천개' 에 있는 int 1000 개를 메모리에 저장하라. 


		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	// uniform_int_distribution<int> uid{0, 9999} -> 0 ~ 9999 사이의 랜덤한 값을 만들고 확률은 일정하게 해줘  
	uniform_int_distribution<int> uid{0, 9999}; // 로또 뽑을 때 쓰는 코드 
	//int MaxValue = INT_MIN;  // int 가 가질 수 있는 최솟값 
	int MaxValue = numeric_limits<int>::min();

	for (int i = 0; i < 1'000; ++i)
	{
		// int 0 ~ intMax 까지 의 숫자중 랜덤한 값이 찍힌다. 
		// 칸 맞춰서 찍고 싶다면 ? -> format 함수 
		
		int num = uid(dre);
		// < 왼쪽으로 / ^ 위로 
		//cout << format("{:8}", num);						// uniform 하게 가공한다. 
		if (MaxValue < num)
			MaxValue = num;
	
		/*
			가장 큰 값을 찾기 위해서는 기준점이 필요하다.
			기준점을 뭘로 잡을 수가 있을까?

		*/

		// 가장 중요한 개념 : RAII : Resource Acquisition Is Initialization
		// 만듦과 동시에 초기화 
		std::ofstream	OutFile{ "int 천개", std::ios::app };						// 쓰기모드로 파일을 연다 ( app : 덧붙여 쓰기 모드 )
		OutFile << format("{:8}", num);
		if (i % 8 == 0)
			OutFile << '\n';


		// OutFIle.close() 같은 코딩은 하면 안된다. 
		// 자동으로 자원이 닫히고 반환된더ㅏ. ( RAII에 의해서... ) 

	}

	{
		std::ifstream inFile{"int 천개"};
		std::vector<char> vWords{ std::istreambuf_iterator<char> { inFile}, {} };
		for (int i = 0 ; i < vWords.size(); ++i)
		{
			cout << vWords[i] << "\n";
		}

	}

	cout << "최댓값 : " << MaxValue << endl;
	save("STL.cpp");
}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오전 11:24:31
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>
#include <limits>
#include <fstream>


using namespace std;
/*
* [Q] : 램던 int 1000개 중 가장 큰 값을 찾아 화면에 출력하라 
		시험 문제 1번은 파일을 읽는 것이다. 
	[Q] : 램던 int 1000 개를 생성하여 파일 int 천개에 저장하라  
	[Q] : 파일'int 천개' 에 있는 int 1000 개를 메모리에 저장하라. 


		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	// uniform_int_distribution<int> uid{0, 9999} -> 0 ~ 9999 사이의 랜덤한 값을 만들고 확률은 일정하게 해줘  
	uniform_int_distribution<int> uid{0, 9999}; // 로또 뽑을 때 쓰는 코드 
	//int MaxValue = INT_MIN;  // int 가 가질 수 있는 최솟값 
	int MaxValue = numeric_limits<int>::min();

	for (int i = 0; i < 1'000; ++i)
	{
		// int 0 ~ intMax 까지 의 숫자중 랜덤한 값이 찍힌다. 
		// 칸 맞춰서 찍고 싶다면 ? -> format 함수 
		
		int num = uid(dre);
		// < 왼쪽으로 / ^ 위로 
		//cout << format("{:8}", num);						// uniform 하게 가공한다. 
		if (MaxValue < num)
			MaxValue = num;
	
		/*
			가장 큰 값을 찾기 위해서는 기준점이 필요하다.
			기준점을 뭘로 잡을 수가 있을까?

		*/

		// 가장 중요한 개념 : RAII : Resource Acquisition Is Initialization
		// 만듦과 동시에 초기화 
		std::ofstream	OutFile{ "int 천개", std::ios::app };						// 쓰기모드로 파일을 연다 ( app : 덧붙여 쓰기 모드 )
		OutFile << format("{:8}", num);
		if (i % 8 == 0)
			OutFile << '\n';


		// OutFIle.close() 같은 코딩은 하면 안된다. 
		// 자동으로 자원이 닫히고 반환된더ㅏ. ( RAII에 의해서... ) 

	}

	{
		std::ifstream inFile{"int 천개"};
		std::vector<int> vWords{ std::istream_iterator<int> { inFile}, {} };
		for (int i = 0 ; i < vWords.size(); ++i)
		{
			cout << vWords[i] << "\n";
		}

	}

	cout << "최댓값 : " << MaxValue << endl;
	save("STL.cpp");
}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오전 11:42:13
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>
#include <limits>
#include <fstream>


using namespace std;
/*
		[Q] :	램던 int 1000개 중 가장 큰 값을 찾아 화면에 출력하라 
				시험 문제 1번은 파일을 읽는 것이다. 
		[Q] :	램던 int 1000 개를 생성하여 파일 int 천개에 저장하라  
		[Q] :	파일'int 천개' 에 있는 int 1000 개를 메모리에 저장하라. 

		int 는 텍스트 형식으로 공백으로 분리되어 저장되어 있다. 
		File : txt 냐 ? Binary 냐 ? 두 가지만 고려하면 된다 


		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	std::ifstream in("int 천개"); // 왜 뒤의 확장자를 안써도 될까? 
	int num;

	for (int i = 0; i < 1'000; ++i)
	{
		in >> num;
		cout << format("{:8}", num);

	}


	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오전 11:45:05
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>
#include <limits>
#include <fstream>


using namespace std;
/*
		[Q] :	램던 int 1000개 중 가장 큰 값을 찾아 화면에 출력하라 
				시험 문제 1번은 파일을 읽는 것이다. 
		[Q] :	램던 int 1000 개를 생성하여 파일 int 천개에 저장하라  
		[Q] :	파일'int 천개' 에 있는 int 1000 개를 메모리에 저장하라. 

		int 는 텍스트 형식으로 공백으로 분리되어 저장되어 있다. 
		File : txt 냐 ? Binary 냐 ? 두 가지만 고려하면 된다 


		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	std::ifstream in("int 천개"); // 왜 뒤의 확장자를 안써도 될까? 
	int num;

	while (in >> num) // int 형 자료가 몇개 인지 모를 때 
	{
		in >> num;
		cout << format("{:8}", num);

	}


	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오전 11:55:41
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>
#include <limits>
#include <fstream>


using namespace std;
/*
		[Q] :	램던 int 1000개 중 가장 큰 값을 찾아 화면에 출력하라 
				시험 문제 1번은 파일을 읽는 것이다. 
		[Q] :	램던 int 1000 개를 생성하여 파일 int 천개에 저장하라  
		[Q] :	파일'int 천개' 에 있는 int 1000 개를 메모리에 저장하라. 

		int 는 텍스트 형식으로 공백으로 분리되어 저장되어 있다. 
		File : txt 냐 ? Binary 냐 ? 두 가지만 고려하면 된다 


		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	// 코딩 스타일 읽어보기 - 구글  
	// https://google.github.io/styleguide/cppguide.html
	// 
	// 코딩 컨벤션 : 
	std::ifstream in("int 천개"); // 왜 뒤의 확장자를 안써도 될까? 
	
	/*
		1.
		int num;
	while (in >> num) { // int 형 자료가 몇개 인지 모를 때 
		cout << format("{:8}", num);

	}

	*/

	int Max = INT_MIN;
	int a[1'000];
	for (int i = 0; i < 1'000; ++i){ 
		in >> a[i];
	
		if (Max < a[i])
			Max = a[i];
	}

	// int a[ ] 에 있는 값 중 가장 큰 값을 화면에 출력하라. 
	cout << Max << endl;


	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오후 12:04:38
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>
#include <limits>
#include <fstream>
#include <array>



using namespace std;
/*
		[Q] :	램던 int 1000개 중 가장 큰 값을 찾아 화면에 출력하라 
				시험 문제 1번은 파일을 읽는 것이다. 
		[Q] :	램던 int 1000 개를 생성하여 파일 int 천개에 저장하라  
		[Q] :	파일'int 천개' 에 있는 int 1000 개를 메모리에 저장하라. 

		int 는 텍스트 형식으로 공백으로 분리되어 저장되어 있다. 
		File : txt 냐 ? Binary 냐 ? 두 가지만 고려하면 된다 


		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	// 코딩 스타일 읽어보기 - 구글  
	// https://google.github.io/styleguide/cppguide.html
	// 
	// 코딩 컨벤션 : 
	std::ifstream in("int 천개"); // 왜 뒤의 확장자를 안써도 될까? 
	
	/*
		1.
		int num;
	while (in >> num) { // int 형 자료가 몇개 인지 모를 때 
		cout << format("{:8}", num);

	}

	*/

	/*
		2. 직접 배열 쓴 방법 :
		// 이것을 쓰지 않는다 : CPP 에서 권장한다.
	int a[1'000]; // 왜 쓰지 말라고 할까? -> array 때문에 생기는 문제가 아주 많다.
	// a 가 몇개인지 전체 모른다. sizeof() 로 찾는건 좋은 코드가 아니다.
	// 똑똑하게 랩핑한 걸로 쓴다.

	for (int i = 0; i < 1'000; ++i){
		in >> a[i];
	}

	// int a[ ] 에 있는 값 중 가장 큰 값을 화면에 출력하라.
	int MaxValue = a[0];

	for (int num : a) {
		if (MaxValue < num) {
			MaxValue = num;
		}
	}

	cout << " 최댓값 : " << MaxValue << endl;

	*/

	array<int, 1'000> a;	 // 앞으로 int[] 사용하지 않는다. 
	cout << sizeof(a) << endl;

	for (int i = 0; i < 1'000; ++i) {

	}
	

	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오후 12:09:27
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>
#include <limits>
#include <fstream>
#include <array>



using namespace std;
/*
		[Q] :	램던 int 1000개 중 가장 큰 값을 찾아 화면에 출력하라 
				시험 문제 1번은 파일을 읽는 것이다. 
		[Q] :	램던 int 1000 개를 생성하여 파일 int 천개에 저장하라  
		[Q] :	파일'int 천개' 에 있는 int 1000 개를 메모리에 저장하라. 

		int 는 텍스트 형식으로 공백으로 분리되어 저장되어 있다. 
		File : txt 냐 ? Binary 냐 ? 두 가지만 고려하면 된다 


		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	// 코딩 스타일 읽어보기 - 구글  
	// https://google.github.io/styleguide/cppguide.html
	// 
	// 코딩 컨벤션 : 
	std::ifstream in("int 천개"); // 왜 뒤의 확장자를 안써도 될까? 
	
	/*
		1.
		int num;
	while (in >> num) { // int 형 자료가 몇개 인지 모를 때 
		cout << format("{:8}", num);

	}

	*/

	/*
		2. 직접 배열 쓴 방법 :
		// 이것을 쓰지 않는다 : CPP 에서 권장한다.
	int a[1'000]; // 왜 쓰지 말라고 할까? -> array 때문에 생기는 문제가 아주 많다.
	// a 가 몇개인지 전체 모른다. sizeof() 로 찾는건 좋은 코드가 아니다.
	// 똑똑하게 랩핑한 걸로 쓴다.

	for (int i = 0; i < 1'000; ++i){
		in >> a[i];
	}

	// int a[ ] 에 있는 값 중 가장 큰 값을 화면에 출력하라.
	int MaxValue = a[0];

	for (int num : a) {
		if (MaxValue < num) {
			MaxValue = num;
		}
	}

	cout << " 최댓값 : " << MaxValue << endl;

	*/

	array<int, 1'000> a;	 // 앞으로 int[] 사용하지 않는다. 
	cout << sizeof(a) << endl;
	auto p = std::max_element(a.begin(), a.end());
	cout << " 최댓값 : " << *p << endl;


	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오후 12:09:52
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>
#include <limits>
#include <fstream>
#include <array>



using namespace std;
/*
		[Q] :	램던 int 1000개 중 가장 큰 값을 찾아 화면에 출력하라 
				시험 문제 1번은 파일을 읽는 것이다. 
		[Q] :	램던 int 1000 개를 생성하여 파일 int 천개에 저장하라  
		[Q] :	파일'int 천개' 에 있는 int 1000 개를 메모리에 저장하라. 

		int 는 텍스트 형식으로 공백으로 분리되어 저장되어 있다. 
		File : txt 냐 ? Binary 냐 ? 두 가지만 고려하면 된다 


		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	// 코딩 스타일 읽어보기 - 구글  
	// https://google.github.io/styleguide/cppguide.html
	// 
	// 코딩 컨벤션 : 
	std::ifstream in("int 천개"); // 왜 뒤의 확장자를 안써도 될까? 
	
	/*
		1.
		int num;
	while (in >> num) { // int 형 자료가 몇개 인지 모를 때 
		cout << format("{:8}", num);

	}

	*/

	/*
		2. 직접 배열 쓴 방법 :
		// 이것을 쓰지 않는다 : CPP 에서 권장한다.
	int a[1'000]; // 왜 쓰지 말라고 할까? -> array 때문에 생기는 문제가 아주 많다.
	// a 가 몇개인지 전체 모른다. sizeof() 로 찾는건 좋은 코드가 아니다.
	// 똑똑하게 랩핑한 걸로 쓴다.

	for (int i = 0; i < 1'000; ++i){
		in >> a[i];
	}

	// int a[ ] 에 있는 값 중 가장 큰 값을 화면에 출력하라.
	int MaxValue = a[0];

	for (int num : a) {
		if (MaxValue < num) {
			MaxValue = num;
		}
	}

	cout << " 최댓값 : " << MaxValue << endl;

	*/

	array<int, 1'000> a;	 // 앞으로 int[] 사용하지 않는다. 

	for (int i = 0; i < 1'000; ++i) {
		in >> a[i];
	}

	cout << sizeof(a) << endl;
	auto p = std::max_element(a.begin(), a.end());
	cout << " 최댓값 : " << *p << endl;


	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오후 12:10:00
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>
#include <limits>
#include <fstream>
#include <array>



using namespace std;
/*
		[Q] :	램던 int 1000개 중 가장 큰 값을 찾아 화면에 출력하라 
				시험 문제 1번은 파일을 읽는 것이다. 
		[Q] :	램던 int 1000 개를 생성하여 파일 int 천개에 저장하라  
		[Q] :	파일'int 천개' 에 있는 int 1000 개를 메모리에 저장하라. 

		int 는 텍스트 형식으로 공백으로 분리되어 저장되어 있다. 
		File : txt 냐 ? Binary 냐 ? 두 가지만 고려하면 된다 


		Random 값을 갖는 int 1'000 개를 생성하고 값을 화면에 출력한다. 

*/
default_random_engine dre; // 5'000 byte 이다.  


// -------
int main()
// -------
{
	// 코딩 스타일 읽어보기 - 구글  
	// https://google.github.io/styleguide/cppguide.html
	// 
	// 코딩 컨벤션 : 
	std::ifstream in("int 천개"); // 왜 뒤의 확장자를 안써도 될까? 
	
	/*
		1.
		int num;
	while (in >> num) { // int 형 자료가 몇개 인지 모를 때 
		cout << format("{:8}", num);

	}

	*/

	/*
		2. 직접 배열 쓴 방법 :
		// 이것을 쓰지 않는다 : CPP 에서 권장한다.
	int a[1'000]; // 왜 쓰지 말라고 할까? -> array 때문에 생기는 문제가 아주 많다.
	// a 가 몇개인지 전체 모른다. sizeof() 로 찾는건 좋은 코드가 아니다.
	// 똑똑하게 랩핑한 걸로 쓴다.

	for (int i = 0; i < 1'000; ++i){
		in >> a[i];
	}

	// int a[ ] 에 있는 값 중 가장 큰 값을 화면에 출력하라.
	int MaxValue = a[0];

	for (int num : a) {
		if (MaxValue < num) {
			MaxValue = num;
		}
	}

	cout << " 최댓값 : " << MaxValue << endl;

	*/

	array<int, 1'000> a;	 // 앞으로 int[] 사용하지 않는다. 

	for (int i = 0; i < 1'000; ++i) {
		in >> a[i];
	}

	cout << sizeof(a) << endl;
	auto p = std::max_element(a.begin(), a.end());
	cout << " 최댓값 : " << *p << endl;


	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오후 12:13:04
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>
#include <limits>
#include <fstream>
#include <array>

using namespace std;

// -------
int main()
// -------
{
	array<int, 1'000> a;
	cout << sizeof(a) << endl;


	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오후 12:15:22
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>
#include <limits>
#include <fstream>
#include <array>

using namespace std;

array<int, 1'000> ga; // DATA 
int gn;				// DATA  



// -------
int main()
// -------
{
	array<int, 1'000> a; // STACK   
	int n;				// STACK

	cout << "STACK 에 있는 a의 번지 : " << addressof(a) << endl;;
	cout << "STACK 에 있는 n의 번지 : " << addressof(n) << endl;;

	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오후 12:16:28
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>
#include <limits>
#include <fstream>
#include <array>

using namespace std;

array<int, 1'000> ga; // DATA 
int gn;				// DATA  



// -------
int main()
// -------
{
	array<int, 1'000> a; // STACK   
	int n;				// STACK

	cout << "STACK 에 있는 a의 번지 : " << addressof(a) << endl;;
	cout << "STACK 에 있는 n의 번지 : " << addressof(n) << endl;;
	cout << endl;


	cout << "DATA에 있는 ga의 번지  : " << addressof(ga) << endl;
	cout << "DATA에 있는 gn의 번지  : " << addressof(gn) << endl;


	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오후 12:17:00
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>
#include <limits>
#include <fstream>
#include <array>

using namespace std;

array<int, 1'000> ga; // DATA 
int gn;				// DATA  



// -------
int main()
// -------
{
	array<int, 1'000> a; // STACK   
	int n;				// STACK

	// 번지수가 가까울 것이다. 
	cout << "STACK 에 있는 a의 번지 : " << addressof(a) << endl;;
	cout << "STACK 에 있는 n의 번지 : " << addressof(n) << endl;;
	cout << endl;

	// 번지가 상당한 격차가 날 것이다. 
	cout << "DATA에 있는 ga의 번지  : " << addressof(ga) << endl;
	cout << "DATA에 있는 gn의 번지  : " << addressof(gn) << endl;


	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오후 12:18:41
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>
#include <limits>
#include <fstream>
#include <array>

using namespace std;

array<int, 1'000> ga; // DATA 
int gn;				// DATA  



// -------
int main()
// -------
{
	array<int, 1'000> a; // STACK   
	int n;				// STACK

	// 번지수가 가까울 것이다. 
	cout << "STACK 에 있는 a의 번지 : " << addressof(a) << endl;;
	cout << "STACK 에 있는 n의 번지 : " << addressof(n) << endl;;
	cout << endl;

	// 번지가 상당한 격차가 날 것이다. 
	cout << "DATA에 있는 ga의 번지  : " << addressof(ga) << endl;
	cout << "DATA에 있는 gn의 번지  : " << addressof(gn) << endl;

	cout << "CODE에 있는main의 번지 : " << addressof(main) << endl;
	cout << "CODE에 있는Save의 번지 : " << addressof(save) << endl;

 

	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오후 12:18:55
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>
#include <limits>
#include <fstream>
#include <array>

using namespace std;

array<int, 1'000> ga; // DATA 
int gn;				// DATA  



// -------
int main()
// -------
{
	array<int, 1'000> a; // STACK   
	int n;				// STACK

	// 번지수가 가까울 것이다. 
	cout << "STACK 에 있는 a의 번지 : " << addressof(a) << endl;;
	cout << "STACK 에 있는 n의 번지 : " << addressof(n) << endl;;
	cout << endl;

	// 번지가 상당한 격차가 날 것이다. 
	cout << "DATA에 있는 ga의 번지  : " << addressof(ga) << endl;
	cout << "DATA에 있는 gn의 번지  : " << addressof(gn) << endl;
	cout << endl;

	cout << "CODE에 있는main의 번지 : " << addressof(main) << endl;
	cout << "CODE에 있는Save의 번지 : " << addressof(save) << endl;

 

	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-13 월요일 오후 12:19:16
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>
#include <limits>
#include <fstream>
#include <array>

using namespace std;

array<int, 1'000> ga; // DATA 
int gn;				// DATA  



// -------
int main()
// -------
{
	array<int, 1'000> a; // STACK   
	int n;				// STACK

	// 번지수가 가까울 것이다. 
	cout << "STACK 에 있는 a의 번지 : " << addressof(a) << endl;;
	cout << "STACK 에 있는 n의 번지 : " << addressof(n) << endl;;
	cout << endl;

	cout << "CODE에 있는main의 번지 : " << addressof(main) << endl;
	cout << "CODE에 있는Save의 번지 : " << addressof(save) << endl;
	cout << endl;


	// 번지가 상당한 격차가 날 것이다. 
	cout << "DATA에 있는 ga의 번지  : " << addressof(ga) << endl;
	cout << "DATA에 있는 gn의 번지  : " << addressof(gn) << endl;




 

	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-14 화요일 오후 1:37:40
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>
#include <limits>
#include <fstream>
#include <array>

using namespace std;

/*
	DATA 와 STACK 은 아주 않이 떨어져있다 .


*/
array<int, 1'000> ga;	// DATA SEGMENT
int gn;					// DATA SEGMENT



// -------	
int main()				// CODE / TEXT SEGMENT
// -------
{
	array<int, 10> a;	// STACK   
	int n;				// STACK

	// 번지수가 가까울 것이다. 
	cout << "STACK 에 있는 a의 번지 : " << addressof(a) << endl;;
	cout << "STACK 에 있는 n의 번지 : " << addressof(n) << endl;;
	cout << endl;

	cout << "CODE에 있는main의 번지 : " << addressof(main) << endl;
	cout << "CODE에 있는Save의 번지 : " << addressof(save) << endl;
	cout << endl;

	cout << "Free -> 다음시간에..";



	// 번지가 상당한 격차가 날 것이다. 
	cout << "DATA에 있는 ga의 번지  : " << addressof(ga) << endl;
	cout << "DATA에 있는 gn의 번지  : " << addressof(gn) << endl;


	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-14 화요일 오후 1:37:53
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>
#include <limits>
#include <fstream>
#include <array>

using namespace std;

/*
	DATA 와 STACK 은 아주 않이 떨어져있다 .


*/
array<int, 1'000> ga;	// DATA SEGMENT
int gn;					// DATA SEGMENT



// -------	
int main()				// CODE / TEXT SEGMENT
// -------
{
	array<int, 10> a;	// STACK   
	int n;				// STACK

	// 번지수가 가까울 것이다. 
	cout << "STACK 에 있는 a의 번지 : " << addressof(a) << endl;;
	cout << "STACK 에 있는 n의 번지 : " << addressof(n) << endl;;
	cout << endl;

	cout << "CODE에 있는main의 번지 : " << addressof(main) << endl;
	cout << "CODE에 있는Save의 번지 : " << addressof(save) << endl;
	cout << endl;

	cout << "Free -> 다음시간에.." << endl;



	// 번지가 상당한 격차가 날 것이다. 
	cout << "DATA에 있는 ga의 번지  : " << addressof(ga) << endl;
	cout << "DATA에 있는 gn의 번지  : " << addressof(gn) << endl;


	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-14 화요일 오후 1:39:37
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>
#include <limits>
#include <fstream>
#include <array>

using namespace std;

/*
	DATA 와 STACK 은 아주 않이 떨어져있다 .


*/
array<int, 1'000> ga;	// DATA SEGMENT
int gn;					// DATA SEGMENT



// -------	
int main()				// CODE / TEXT SEGMENT
// -------
{
	array<int, 10> a;	// STACK   
	int n;				// STACK

	// 번지수가 가까울 것이다. 
	cout << "STACK 에 있는 a의 번지 : " << addressof(a) << endl;;
	cout << "STACK 에 있는 n의 번지 : " << addressof(n) << endl;;
	cout << endl;

	cout << "CODE에 있는main의 번지 : " << addressof(main) << endl;
	cout << "CODE에 있는Save의 번지 : " << addressof(save) << endl;
	cout << endl;

	int* p = new int{};
	cout << "Free Store 에 있는번지 : " << p << endl;
	delete p;


	// 번지가 상당한 격차가 날 것이다. 
	cout << "DATA에 있는 ga의 번지  : " << addressof(ga) << endl;
	cout << "DATA에 있는 gn의 번지  : " << addressof(gn) << endl;


	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-14 화요일 오후 1:41:55
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
#include <random>
#include <format>
#include <limits>
#include <fstream>
#include <array>

using namespace std;

/*
	DATA 와 STACK 은 아주 않이 떨어져있다 .


*/
array<int, 1'000> ga;	// DATA SEGMENT
int gn;					// DATA SEGMENT



// -------	
int main()				// CODE / TEXT SEGMENT
// -------
{
	array<int, 10> a;	// STACK   
	int n;				// STACK

	// 번지수가 가까울 것이다. 
	cout << "STACK 에 있는 a의 번지 : " << addressof(a) << endl;;
	cout << "STACK 에 있는 n의 번지 : " << addressof(n) << endl;;
	cout << endl;

	int* p = new int{};
	cout << "Free Store 에 있는번지 : " << p << endl;
	delete p;


	cout << "CODE에 있는main의 번지 : " << addressof(main) << endl;
	cout << "CODE에 있는Save의 번지 : " << addressof(save) << endl;
	cout << endl;



	// 번지가 상당한 격차가 날 것이다. - 면접에서 질문 많이한다.  
	cout << "DATA에 있는 ga의 번지  : " << addressof(ga) << endl;
	cout << "DATA에 있는 gn의 번지  : " << addressof(gn) << endl;


	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-14 화요일 오후 1:46:43
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// 많은 수의 수의 자료 다루기 - int  
// --------------------------------------------------

#include <iostream>
#include "save.h"
using namespace std;


// -------	
int main()				// CODE / TEXT SEGMENT
// -------
{
	int n;	// int 의 메모리 크기는 4 byte 가 아니고 sizeof int 가 정답이다. 
	cout << "int 의 크기 : " << sizeof(int) << endl; // C Stack 마다 달라진다 메모리 크기가..
	// int 의 크기가 몇바이트니? 물어본다면 시스템 마다 다른데 sizeof(int)로 해보면 나옵니다. 표준에는 sizeof(int) >= 2byte 이다.
	// 누군가 int 의 크기를 묻는다면 시스템 마다 다르고 2byte 보다 크다가 정답이다. 

	cout << "int 의 최솟값 :  " << std::numeric_limits<int>::min() << endl;
	cout << "int 의 최댓값 :  " << std::numeric_limits<int>::max() << endl;



	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-14 화요일 오후 2:09:40
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// int 한개를 저장하는데 필요한 메모리 공간은 ? - 4
// 파일에 기록한다면 1(+1) ~ 11(1) -> 평균 6바이트  // 19분 - 녹음  ( 빈칸이 있으므로 이렇게 됐구나.. ) 
// --------------------------------------------------

#include <iostream>
#include <numeric>
#include <array>
#include <fstream>

#include "save.h"
using namespace std;

// Q : int 1000개를 파일 "int 천개 메모리"에 메모리 그대로 저장하라. 

// -------	
int main()				// CODE / TEXT SEGMENT
// -------
{

	array<int, 1'000> a;
	std::iota(a.begin(), a.end(), 1);

	std::ofstream out{ "int 천개 메모리" };
	// 저수준 입출력은 멤버함수로 쓸 수 있다. 
	//out.write(reinterpret_cast<char*>(a.data()), 4'000); // a 라는 메모리를 4000 바이트로 쓰고 싶다. a.data() -> 시작 포인터   
	out.write((char*)&a, a.size() * sizeof(int)); // 숫자를 다 없앴다. 
	// reinterpret_cast : 임의의 포인터 타입끼리 변환을 허용하는 캐스트 연산자 입니다.
	// 숫자로 코딩하는게 가장 후진 코드이다. 


	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-14 화요일 오후 2:16:25
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// int 한개를 저장하는데 필요한 메모리 공간은 ? - 4
// 파일에 기록한다면 1(+1) ~ 11(1) -> 평균 6바이트  // 19분 - 녹음  ( 빈칸이 있으므로 이렇게 됐구나.. ) 
// --------------------------------------------------

#include <iostream>
#include <numeric>
#include <array>
#include <fstream>

#include "save.h"
using namespace std;

// Q : int 1000개를 파일 "int 천개 메모리"에 메모리 그대로 저장하라. 

// -------	
int main()				// CODE / TEXT SEGMENT
// -------
{

	array<int, 1'000> a;
	std::iota(a.begin(), a.end(), 1);

	std::ofstream out{ "int 천개 메모리", ios::binary };
	// 저수준 입출력은 멤버함수로 쓸 수 있다. 
	//out.write(reinterpret_cast<char*>(a.data()), 4'000); // a 라는 메모리를 4000 바이트로 쓰고 싶다. a.data() -> 시작 포인터   
	out.write((char*)&a, a.size() * sizeof(int)); // 숫자를 다 없앴다. 
	// reinterpret_cast : 임의의 포인터 타입끼리 변환을 허용하는 캐스트 연산자 입니다.
	// 숫자로 코딩하는게 가장 후진 코드이다. 


	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-14 화요일 오후 2:27:27
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// int 한개를 저장하는데 필요한 메모리 공간은 ? - 4
// 파일에 기록한다면 1(+1) ~ 11(1) -> 평균 6바이트  // 19분 - 녹음  ( 빈칸이 있으므로 이렇게 됐구나.. ) 
// --------------------------------------------------

#include <iostream>
#include <numeric>
#include <array>
#include <fstream>

#include "save.h"

#include <fstream>
#include <vector>

using namespace std;

// Q :	"int 천개 메모리"에 
//		int 값 1'000 개를 메모리에 저장한 후 화면에 출력하라. 


// -------	
int main()				
// -------
{
	std::ifstream inFile{ "int 천개 메모리", ios::binary };
	std::vector<int> vWords{ std::istream_iterator<int> { inFile}, {} };
	
	for (int i = 0; i < vWords.size(); ++i)
		cout << vWords[i] << endl;


	

	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-14 화요일 오후 2:28:26
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// int 한개를 저장하는데 필요한 메모리 공간은 ? - 4
// 파일에 기록한다면 1(+1) ~ 11(1) -> 평균 6바이트  // 19분 - 녹음  ( 빈칸이 있으므로 이렇게 됐구나.. ) 
// --------------------------------------------------

#include <iostream>
#include <numeric>
#include <array>
#include <fstream>

#include "save.h"

#include <fstream>
#include <vector>

using namespace std;

// Q :	"int 천개 메모리"에 
//		int 값 1'000 개를 메모리에 저장한 후 화면에 출력하라. 


// -------	
int main()				
// -------
{
	std::ifstream inFile{ "int 천개 메모리"};
	std::vector<int> vWords{ std::istream_iterator<int> { inFile}, {} };
	
	for (int i = 0; i < vWords.size(); ++i)
		cout << vWords[i] << endl;


	

	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-14 화요일 오후 2:36:08
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// int 한개를 저장하는데 필요한 메모리 공간은 ? - 4
// 파일에 기록한다면 1(+1) ~ 11(1) -> 평균 6바이트  // 19분 - 녹음  ( 빈칸이 있으므로 이렇게 됐구나.. ) 
// 파일을 binary mode 로 열기 - (문자변환이 일어나지 않음)
// --------------------------------------------------

#include <iostream>
#include <numeric>
#include <array>
#include <fstream>

#include "save.h"

#include <fstream>
#include <vector>
#include <format>

using namespace std;

// Q :	"int 천개 메모리"에 
//		int 값 1'000 개를 메모리에 저장한 후 화면에 출력하라. 


// -------	
int main()				
// -------
{
	std::ifstream inFile{ "int 천개 메모리"};
	// 읽을 는 항상 확인하라..
	if (!inFile) {
		cout << "파일에 문제가 있다." << endl;
		return 0;
	}

	// . 찍으면 저수준 가능하다는 것을 명심하라. 
	
	array<int, 1'000> a;
	inFile.read((char*)&a, a.size() * sizeof(int)); // 어디로 몇 바이트를 읽을 거냐 

	for (int num : a)
		cout << format("{:8}", num);


	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-14 화요일 오후 2:37:30
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// int 한개를 저장하는데 필요한 메모리 공간은 ? - 4
// 파일에 기록한다면 1(+1) ~ 11(1) -> 평균 6바이트  // 19분 - 녹음  ( 빈칸이 있으므로 이렇게 됐구나.. ) 
// 파일을 binary mode 로 열기 - (문자변환이 일어나지 않음)
// --------------------------------------------------

#include <iostream>
#include <numeric>
#include <array>
#include <fstream>

#include "save.h"

#include <fstream>
#include <vector>
#include <format>

using namespace std;

// Q :	"int 천개 메모리"에 
//		int 값 1'000 개를 메모리에 저장한 후 화면에 출력하라. 


// -------	
int main()				
// -------
{
	array<int, 1'000> a;
	std::iota(a.begin(), a.end(), 1);

	std::ofstream out{ "int 천개 메모리", ios::binary };
	// 저수준 입출력은 멤버함수로 쓸 수 있다. 
	//out.write(reinterpret_cast<char*>(a.data()), 4'000); // a 라는 메모리를 4000 바이트로 쓰고 싶다. a.data() -> 시작 포인터   
	out.write((char*)&a, a.size() * sizeof(int)); // 숫자를 다 없앴다. 
	// reinterpret_cast : 임의의 포인터 타입끼리 변환을 허용하는 캐스트 연산자 입니다.
	// 숫자로 코딩하는게 가장 후진 코드이다. 

	//std::ifstream inFile{ "int 천개 메모리"};
	//// 읽을 는 항상 확인하라..
	//if (!inFile) {
	//	cout << "파일에 문제가 있다." << endl;
	//	return 0;
	//}

	//// . 찍으면 저수준 가능하다는 것을 명심하라. 
	//
	//array<int, 1'000> a;
	//inFile.read((char*)&a, a.size() * sizeof(int)); // 어디로 몇 바이트를 읽을 거냐 

	//for (int num : a)
	//	cout << format("{:8}", num);


	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-14 화요일 오후 2:37:43
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// int 한개를 저장하는데 필요한 메모리 공간은 ? - 4
// 파일에 기록한다면 1(+1) ~ 11(1) -> 평균 6바이트  // 19분 - 녹음  ( 빈칸이 있으므로 이렇게 됐구나.. ) 
// 파일을 binary mode 로 열기 - (문자변환이 일어나지 않음)
// --------------------------------------------------

#include <iostream>
#include <numeric>
#include <array>
#include <fstream>

#include "save.h"

#include <fstream>
#include <vector>
#include <format>

using namespace std;

// Q :	"int 천개 메모리"에 
//		int 값 1'000 개를 메모리에 저장한 후 화면에 출력하라. 


// -------	
int main()				
// -------
{


	std::ifstream inFile{ "int 천개 메모리"};
	// 읽을 는 항상 확인하라..
	if (!inFile) {
		cout << "파일에 문제가 있다." << endl;
		return 0;
	}

	// . 찍으면 저수준 가능하다는 것을 명심하라. 
	
	array<int, 1'000> a;
	inFile.read((char*)&a, a.size() * sizeof(int)); // 어디로 몇 바이트를 읽을 거냐 

	for (int num : a)
		cout << format("{:8}", num);


	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-14 화요일 오후 2:38:12
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// int 한개를 저장하는데 필요한 메모리 공간은 ? - 4
// 파일에 기록한다면 1(+1) ~ 11(1) -> 평균 6바이트  // 19분 - 녹음  ( 빈칸이 있으므로 이렇게 됐구나.. ) 
// 파일을 binary mode 로 열기 - (문자변환이 일어나지 않음)
// --------------------------------------------------

#include <iostream>
#include <numeric>
#include <array>
#include <fstream>

#include "save.h"

#include <fstream>
#include <vector>
#include <format>

using namespace std;

// Q :	"int 천개 메모리"에 
//		int 값 1'000 개를 메모리에 저장한 후 화면에 출력하라. 


// -------	
int main()				
// -------
{

	std::ifstream inFile{ "int 천개 메모리", ios::binary};
	// 읽을 는 항상 확인하라..
	if (!inFile) {
		cout << "파일에 문제가 있다." << endl;
		return 0;
	}

	// . 찍으면 저수준 가능하다는 것을 명심하라. 
	
	array<int, 1'000> a;
	inFile.read((char*)&a, a.size() * sizeof(int)); // 어디로 몇 바이트를 읽을 거냐 

	for (int num : a)
		cout << format("{:8}", num);


	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-14 화요일 오후 2:39:10
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// int 한개를 저장하는데 필요한 메모리 공간은 ? - 4
// 파일에 기록한다면 1(+1) ~ 11(1) -> 평균 6바이트  // 19분 - 녹음  ( 빈칸이 있으므로 이렇게 됐구나.. ) 
// 파일을 binary mode 로 열기 - (문자변환이 일어나지 않음)
// --------------------------------------------------

#include <iostream>
#include <numeric>
#include <array>
#include <fstream>

#include "save.h"

#include <fstream>
#include <vector>
#include <format>

using namespace std;

// Q :	"int 천개 메모리"에 
//		int 값 1'000 개를 메모리에 저장한 후 화면에 출력하라. 


// -------	
int main()				
// -------
{

	// 파일 열 때 형식
	std::ifstream inFile{ "int 천개 메모리", ios::binary};
	// 읽을 는 항상 확인하라..
	if (!inFile) {
		cout << "파일에 문제가 있다." << endl;
		return 0;
	}

	// . 찍으면 저수준 가능하다는 것을 명심하라. 
	
	array<int, 1'000> a;
	inFile.read((char*)&a, a.size() * sizeof(int)); // 어디로 몇 바이트를 읽을 거냐 

	for (int num : a)
		cout << format("{:8}", num);


	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-14 화요일 오후 3:04:09
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// --------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <fstream>

#include "save.h"
using namespace std;
default_random_engine dre;
uniform_int_distribution<int> uidChar{ 'a', 'z' };
uniform_int_distribution uidNum{ 1, 10'000 };

// Coding Convention  
// Google C++ Style Guide  
class Dog {
	char c;
	int n;
	// 5 byte 인데 왜 8 byte 가 나오지 ?   - 자원을 더 써서 속도를 얻는다. 
public:
	Dog() {
		c = uidChar(dre);		// [ 'a', 'z' ] 
		n = uidNum(dre);		// [ 1 , 10'000 ]
	}

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << "글자 - " << dog.c << ", 숫자 - " << dog.n;
	}

};

// [ 문제 ] :  Dog 1'000 객체를 파일 "Dog 천마리"를 binary mode 로 열고 
//			   메모리 그대로 파일에 기록하라. 



// -------	
int main()				
// -------
{

	array<Dog, 1'000> dogs; // 자동으로 천마리를 생성한다.

	std::ofstream outFile{ "Dog 천마리" , ios::binary};
	outFile.write((char*)&dogs, dogs.size() * sizeof(Dog));


	for (Dog& dog : dogs)
		cout << dog << endl;


	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-14 화요일 오후 3:06:07
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 7일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// --------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <fstream>

#include "save.h"
using namespace std;
default_random_engine dre;
uniform_int_distribution<int> uidChar{ 'a', 'z' };
uniform_int_distribution uidNum{ 1, 10'000 };

// Coding Convention  
// Google C++ Style Guide  
class Dog {
	char c;
	int n;
	// 5 byte 인데 왜 8 byte 가 나오지 ?   - 자원을 더 써서 속도를 얻는다. 
public:
	Dog() {
		c = uidChar(dre);		// [ 'a', 'z' ] 
		n = uidNum(dre);		// [ 1 , 10'000 ]
	}

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << "글자 - " << dog.c << ", 숫자 - " << dog.n;
	}

};

// [ 문제 ] :  Dog 1'000 객체를 파일 "Dog 천마리"를 binary mode 로 열고 
//			   메모리 그대로 파일에 기록하라. 



// -------	
int main()				
// -------
{

	array<Dog, 1'000> dogs; // 자동으로 천마리를 생성한다.

	// binary 로 하면 8'000 버아트가 저장된다.
	// binary 로 안하면 8'024 바이트가 나온다. 
	std::ofstream outFile{ "Dog 천마리" , ios::binary};
	outFile.write((char*)&dogs, dogs.size() * sizeof(Dog));


	for (Dog& dog : dogs)
		cout << dog << endl;


	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-14 화요일 오후 3:12:20
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 14일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// --------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <fstream>

#include "save.h"
using namespace std;
default_random_engine dre;
uniform_int_distribution<int> uidChar{ 'a', 'z' };
uniform_int_distribution uidNum{ 1, 10'000 };

// Coding Convention  
// Google C++ Style Guide  
class Dog {
	char c;
	int n;
	// 5 byte 인데 왜 8 byte 가 나오지 ?   - 자원을 더 써서 속도를 얻는다. 
public:
	Dog() {
		c = uidChar(dre);		// [ 'a', 'z' ] 
		n = uidNum(dre);		// [ 1 , 10'000 ]
	}

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << "글자 - " << dog.c << ", 숫자 - " << dog.n;
	}

	friend istream& operator>>(istream& is, Dog& dog) {
		is.read((char*)&dog, sizeof(Dog));
		return is;
	}
};

// [ 문제 ] :  Dog 1'000 객체가 파일 "Dog 천마리"에 binary mode 로 연파일에  write 함수로  
//			   메모리 그대로 기록되어있다.
// Dog 의 정보를 화면에 cout 으로 출력하라.



// -------	
int main()				
// -------
{

	array<Dog, 1'000> dogs; // 자동으로 천마리를 생성한다.

	// binary 로 하면 8'000 버아트가 저장된다.
	// binary 로 안하면 8'024 바이트가 나온다. 
	//std::ofstream outFile{ "Dog 천마리" , ios::binary};
	//outFile.write((char*)&dogs, dogs.size() * sizeof(Dog));

	ifstream in{ "Dog 천마리", ios::binary };

	if (!in) {
		return 0;
	}

	Dog dog;
	int cnt{};
	while (in >> dog) { // 고수준 입출력인데 멤버함수가 없어서 빨간 줄인데..  
		cout << dog << endl;
	}

	cout << "모두 " << cnt << "개 객체를 읽음 " << endl;

	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-14 화요일 오후 3:12:35
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 14일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// --------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <fstream>

#include "save.h"
using namespace std;
default_random_engine dre;
uniform_int_distribution<int> uidChar{ 'a', 'z' };
uniform_int_distribution uidNum{ 1, 10'000 };

// Coding Convention  
// Google C++ Style Guide  
class Dog {
	char c;
	int n;
	// 5 byte 인데 왜 8 byte 가 나오지 ?   - 자원을 더 써서 속도를 얻는다. 
public:
	Dog() {
		c = uidChar(dre);		// [ 'a', 'z' ] 
		n = uidNum(dre);		// [ 1 , 10'000 ]
	}

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << "글자 - " << dog.c << ", 숫자 - " << dog.n;
	}

	friend istream& operator>>(istream& is, Dog& dog) {
		is.read((char*)&dog, sizeof(Dog));
		return is;
	}
};

// [ 문제 ] :  Dog 1'000 객체가 파일 "Dog 천마리"에 binary mode 로 연파일에  write 함수로  
//			   메모리 그대로 기록되어있다.
// Dog 의 정보를 화면에 cout 으로 출력하라.



// -------	
int main()				
// -------
{

	array<Dog, 1'000> dogs; // 자동으로 천마리를 생성한다.

	// binary 로 하면 8'000 버아트가 저장된다.
	// binary 로 안하면 8'024 바이트가 나온다. 
	//std::ofstream outFile{ "Dog 천마리" , ios::binary};
	//outFile.write((char*)&dogs, dogs.size() * sizeof(Dog));

	ifstream in{ "Dog 천마리", ios::binary };

	if (!in) {
		return 0;
	}

	Dog dog;
	int cnt{};
	while (in >> dog) { // 고수준 입출력인데 멤버함수가 없어서 빨간 줄인데..  
		cout << dog << endl;
		cnt++;
	}

	cout << "모두 " << cnt << "개 객체를 읽음 " << endl;

	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-14 화요일 오후 3:12:50
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 14일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// --------------------------------------------------

#include <iostream>
#include <random>
#include <array>
#include <fstream>

#include "save.h"
using namespace std;
default_random_engine dre;
uniform_int_distribution<int> uidChar{ 'a', 'z' };
uniform_int_distribution uidNum{ 1, 10'000 };

// Coding Convention  
// Google C++ Style Guide  
class Dog {
	char c;
	int n;
	// 5 byte 인데 왜 8 byte 가 나오지 ?   - 자원을 더 써서 속도를 얻는다. 
public:
	Dog() {
		c = uidChar(dre);		// [ 'a', 'z' ] 
		n = uidNum(dre);		// [ 1 , 10'000 ]
	}

	friend ostream& operator<<(ostream& os, const Dog& dog) {
		return os << "글자 - " << dog.c << ", 숫자 - " << dog.n;
	}

	friend istream& operator>>(istream& is, Dog& dog) {
		is.read((char*)&dog, sizeof(Dog));
		return is;
	}
};

// [ 문제 ] :  Dog 1'000 객체가 파일 "Dog 천마리"에 binary mode 로 연파일에  write 함수로  
//			   메모리 그대로 기록되어있다.
// Dog 의 정보를 화면에 cout 으로 출력하라.



// -------	
int main()				
// -------
{

	array<Dog, 1'000> dogs; // 자동으로 천마리를 생성한다.

	// binary 로 하면 8'000 버아트가 저장된다.
	// binary 로 안하면 8'024 바이트가 나온다. 
	//std::ofstream outFile{ "Dog 천마리" , ios::binary};
	//outFile.write((char*)&dogs, dogs.size() * sizeof(Dog));

	ifstream in{ "Dog 천마리", ios::binary };

	if (!in) {
		return 0;
	}

	Dog dog;
	int cnt{};
	while (in >> dog) { // 고수준 입출력인데 멤버함수가 없어서 빨간 줄인데..  
		cout << dog << endl;
		++cnt;
	}

	cout << "모두 " << cnt << "개 객체를 읽음 " << endl;

	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-20 월요일 오전 10:34:37
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 14일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// --------------------------------------------------

#include <iostream>
#include <array>


#include "save.h"
using namespace std;

// -------	
int main()				
// -------
{
	// 여기에서 객체를 생성한다. - STACK에 생성 
	//int a[]; // 앞으로 이런건 쓰지 말자 .
	array<int, 1000> a;
	cout << sizeof(a) << endl;


	save("STL.cpp");

}

#endif // STL





===============================================
STL.cpp저장시간 : 2023-03-20 월요일 오전 10:59:28
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 20일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// STACK 의 한계 : 1MB 가 default( 컴파일러가 코드 생성하지 않는 것 주의 )  
// 더 큰 데이터 사용 : DATA 와 Free Store ( HEAP )
// --------------------------------------------------

#include <iostream>
#include <array>
#include <numeric>
#include <format>
#include <ranges>			// C++ 20 Lib



#include "save.h"
using namespace std;


array<int, 260'000> a; // DATA Segment



// -------	
int main()				
// -------
{
	// STACK 은 1MB 까지 쓸 수 있다. 
	// 여기에서 객체를 생성한다. - STACK에 생성 
	//int a[]; // 앞으로 이런건 쓰지 말자 .
	//array<int, 1'000'000'000> a; // 경고창 뜬다 . 이 전체 블록의 크기는 INT_MAX 로 제한한다. 0x7fffff
	//array<int, 1'000'000> b; // 1MB 를 스택에 잡겠다.
	//array<int, 10'000'000> a; // Stack 에 메모리를 잡겠다고 하지만 사용하지않으면 컴파일러가 알아서 메모리를 생성하지 않아서 프로그램이 돌아간다. 

	//array<int, 260'000> a; // STACK 에 하면 안되지만 HEAP 에 하면 된다. 

	iota(a.begin(), a.end(), 1);

	for (int num : a |
			views::drop(a.size() - 100))
		cout << format("{:20}", num);


	// 마지막 100개 전에서 100개만 출력 
	//for (int num : a)
	//	cout << format("{:20}", num); //-> 코드가 안돌아간다. 
	/*
		STACK 에 경계를 넘어서 메모리를 읽으려는 시도를 했기 때문에
		스택오버플로우가 나오면서 프로그램이 죽는다.
		스택오버플로우는 경고가 없고 그냥 프로그램이 죽는다. 

	*/

	//cout << sizeof(a) << endl;


	save("STL.cpp");

}

#endif // STL




/*
	array<int, 260'000> a; // stack 의 1MB의 크기를 넘는다. ( 배열은 직렬 메모리 )  
	iota(a.begin(), a.end(), 1); // 배열공간에 쓰는 순간 스택오버플로우로 프로그램이 죽는다. 

	for (int num : a |	# 자료구조에서 한번에 하나씩 데이터를 꺼내라 : 컴파일러가 for(auto p = a.begin(); p != a.end(); ++p) 로 번역한다. 
						# 이렇게 번역하는 것을 syntatic sugar 이라고 한다. 
						# for( int num : a )
			views::drop(a.size() - 100)) // 259900 개를 날려버려랴?
		cout << format("{:20}", num);




*/


===============================================
STL.cpp저장시간 : 2023-03-20 월요일 오전 11:00:22
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 20일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// STACK 의 한계 : 1MB 가 default( 컴파일러가 코드 생성하지 않는 것 주의 )  
// 더 큰 데이터 사용 : DATA 와 Free Store ( HEAP )
// --------------------------------------------------

#include <iostream>
#include <array>
#include <numeric>
#include <format>
#include <ranges>			// C++ 20 Lib



#include "save.h"
using namespace std;


array<int, 200'600'000> a; // DATA Segment



// -------	
int main()				
// -------
{
	// STACK 은 1MB 까지 쓸 수 있다. 
	// 여기에서 객체를 생성한다. - STACK에 생성 
	//int a[]; // 앞으로 이런건 쓰지 말자 .
	//array<int, 1'000'000'000> a; // 경고창 뜬다 . 이 전체 블록의 크기는 INT_MAX 로 제한한다. 0x7fffff
	//array<int, 1'000'000> b; // 1MB 를 스택에 잡겠다.
	//array<int, 10'000'000> a; // Stack 에 메모리를 잡겠다고 하지만 사용하지않으면 컴파일러가 알아서 메모리를 생성하지 않아서 프로그램이 돌아간다. 

	//array<int, 260'000> a; // STACK 에 하면 안되지만 HEAP 에 하면 된다. 

	iota(a.begin(), a.end(), 1);

	for (int num : a |
			views::drop(a.size() - 100))
		cout << format("{:20}", num);


	// 마지막 100개 전에서 100개만 출력 
	//for (int num : a)
	//	cout << format("{:20}", num); //-> 코드가 안돌아간다. 
	/*
		STACK 에 경계를 넘어서 메모리를 읽으려는 시도를 했기 때문에
		스택오버플로우가 나오면서 프로그램이 죽는다.
		스택오버플로우는 경고가 없고 그냥 프로그램이 죽는다. 

	*/

	//cout << sizeof(a) << endl;


	save("STL.cpp");

}

#endif // STL




/*
	array<int, 260'000> a; // stack 의 1MB의 크기를 넘는다. ( 배열은 직렬 메모리 )  
	iota(a.begin(), a.end(), 1); // 배열공간에 쓰는 순간 스택오버플로우로 프로그램이 죽는다. 

	for (int num : a |	# 자료구조에서 한번에 하나씩 데이터를 꺼내라 : 컴파일러가 for(auto p = a.begin(); p != a.end(); ++p) 로 번역한다. 
						# 이렇게 번역하는 것을 syntatic sugar 이라고 한다. 
						# for( int num : a )
			views::drop(a.size() - 100)) // 259900 개를 날려버려랴?
		cout << format("{:20}", num);




*/


===============================================
STL.cpp저장시간 : 2023-03-20 월요일 오전 11:01:48
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 20일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// STACK 의 한계 : 1MB 가 default( 컴파일러가 코드 생성하지 않는 것 주의 )  
// 더 큰 데이터 사용 : DATA 와 Free Store ( HEAP )
// --------------------------------------------------

#include <iostream>
#include <array>
#include <numeric>
#include <format>
#include <ranges>			// C++ 20 Lib



#include "save.h"
using namespace std;


array<int, 100'600'000> a; // DATA Segment



// -------	
int main()				
// -------
{
	// STACK 은 1MB 까지 쓸 수 있다. 
	// 여기에서 객체를 생성한다. - STACK에 생성 
	//int a[]; // 앞으로 이런건 쓰지 말자 .
	//array<int, 1'000'000'000> a; // 경고창 뜬다 . 이 전체 블록의 크기는 INT_MAX 로 제한한다. 0x7fffff
	//array<int, 1'000'000> b; // 1MB 를 스택에 잡겠다.
	//array<int, 10'000'000> a; // Stack 에 메모리를 잡겠다고 하지만 사용하지않으면 컴파일러가 알아서 메모리를 생성하지 않아서 프로그램이 돌아간다. 

	//array<int, 260'000> a; // STACK 에 하면 안되지만 HEAP 에 하면 된다. 

	iota(a.begin(), a.end(), 1);

	for (int num : a |
			views::drop(a.size() - 100))
		cout << format("{:20}", num);


	// 마지막 100개 전에서 100개만 출력 
	//for (int num : a)
	//	cout << format("{:20}", num); //-> 코드가 안돌아간다. 
	/*
		STACK 에 경계를 넘어서 메모리를 읽으려는 시도를 했기 때문에
		스택오버플로우가 나오면서 프로그램이 죽는다.
		스택오버플로우는 경고가 없고 그냥 프로그램이 죽는다. 

	*/

	//cout << sizeof(a) << endl;


	save("STL.cpp");

}

#endif // STL




/*
	array<int, 260'000> a; // stack 의 1MB의 크기를 넘는다. ( 배열은 직렬 메모리 )  
	iota(a.begin(), a.end(), 1); // 배열공간에 쓰는 순간 스택오버플로우로 프로그램이 죽는다. 

	for (int num : a |	# 자료구조에서 한번에 하나씩 데이터를 꺼내라 : 컴파일러가 for(auto p = a.begin(); p != a.end(); ++p) 로 번역한다. 
						# 이렇게 번역하는 것을 syntatic sugar 이라고 한다. 
						# for( int num : a )
			views::drop(a.size() - 100)) // 259900 개를 날려버려랴?
		cout << format("{:20}", num);




*/


===============================================
STL.cpp저장시간 : 2023-03-20 월요일 오전 11:03:51
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 20일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// STACK 의 한계 : 1MB 가 default( 컴파일러가 코드 생성하지 않는 것 주의 )  
// 더 큰 데이터 사용 : DATA 와 Free Store ( HEAP )
// --------------------------------------------------

#include <iostream>
#include <array>
#include <numeric>
#include <format>
#include <ranges>			// C++ 20 Lib



#include "save.h"
using namespace std;


//array<int, 2'600'000> a; // DATA Segment


// 200'000'000/sizeof(int) : 200MB  
//array<int, 200'000'000/ sizeof(int)> a; // DATA Segment 200 MB 
array<int, 1'000'000'000 / sizeof(int)> a; // DATA Segment 1 GB



// -------	
int main()				
// -------
{
	// STACK 은 1MB 까지 쓸 수 있다. 
	// 여기에서 객체를 생성한다. - STACK에 생성 
	//int a[]; // 앞으로 이런건 쓰지 말자 .
	//array<int, 1'000'000'000> a; // 경고창 뜬다 . 이 전체 블록의 크기는 INT_MAX 로 제한한다. 0x7fffff
	//array<int, 1'000'000> b; // 1MB 를 스택에 잡겠다.
	//array<int, 10'000'000> a; // Stack 에 메모리를 잡겠다고 하지만 사용하지않으면 컴파일러가 알아서 메모리를 생성하지 않아서 프로그램이 돌아간다. 

	//array<int, 260'000> a; // STACK 에 하면 안되지만 HEAP 에 하면 된다. 

	iota(a.begin(), a.end(), 1);

	for (int num : a |
			views::drop(a.size() - 100))
		cout << format("{:20}", num);


	// 마지막 100개 전에서 100개만 출력 
	//for (int num : a)
	//	cout << format("{:20}", num); //-> 코드가 안돌아간다. 
	/*
		STACK 에 경계를 넘어서 메모리를 읽으려는 시도를 했기 때문에
		스택오버플로우가 나오면서 프로그램이 죽는다.
		스택오버플로우는 경고가 없고 그냥 프로그램이 죽는다. 

	*/

	//cout << sizeof(a) << endl;


	save("STL.cpp");

}

#endif // STL




/*
	array<int, 260'000> a; // stack 의 1MB의 크기를 넘는다. ( 배열은 직렬 메모리 )  
	iota(a.begin(), a.end(), 1); // 배열공간에 쓰는 순간 스택오버플로우로 프로그램이 죽는다. 

	for (int num : a |	# 자료구조에서 한번에 하나씩 데이터를 꺼내라 : 컴파일러가 for(auto p = a.begin(); p != a.end(); ++p) 로 번역한다. 
						# 이렇게 번역하는 것을 syntatic sugar 이라고 한다. 
						# for( int num : a )
			views::drop(a.size() - 100)) // 259900 개를 날려버려랴?
		cout << format("{:20}", num);




*/


===============================================
STL.cpp저장시간 : 2023-03-20 월요일 오전 11:08:37
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 20일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// STACK 의 한계 : 1MB 가 default( 컴파일러가 코드 생성하지 않는 것 주의 )  
// 더 큰 데이터 사용 : DATA 와 Free Store ( HEAP )
// --------------------------------------------------

#include <iostream>
#include <array>
#include <numeric>
#include <format>
#include <ranges>			// C++ 20 Lib



#include "save.h"
using namespace std;


//array<int, 2'600'000> a; // DATA Segment

// 200'000'000/sizeof(int) : 200MB  
//array<int, 200'000'000/ sizeof(int)> a; // DATA Segment 200 MB 
//array<int, 1'000'000'000 / sizeof(int)> a; // DATA Segment 1 GB
//array<int, 2'000'000'000 / sizeof(int)> a; // DATA Segment 2 GB -> 올바른 애플리케이션이 아니라고 뜨네? - 메모리를 통째로 잡을 때 
array<int, 1'990'000'000 / sizeof(int)> a; // DATA Segment 2 GB -> 
//array<int, 4'000'000'000 / sizeof(int)> a; // DATA Segment 4 GB -> 2기가 넘어가면 안된다. 




// -------	
int main()				
// -------
{
	// STACK 은 1MB 까지 쓸 수 있다. 
	// 여기에서 객체를 생성한다. - STACK에 생성 
	//int a[]; // 앞으로 이런건 쓰지 말자 .
	//array<int, 1'000'000'000> a; // 경고창 뜬다 . 이 전체 블록의 크기는 INT_MAX 로 제한한다. 0x7fffff
	//array<int, 1'000'000> b; // 1MB 를 스택에 잡겠다.
	//array<int, 10'000'000> a; // Stack 에 메모리를 잡겠다고 하지만 사용하지않으면 컴파일러가 알아서 메모리를 생성하지 않아서 프로그램이 돌아간다. 

	//array<int, 260'000> a; // STACK 에 하면 안되지만 HEAP 에 하면 된다. 

	iota(a.begin(), a.end(), 1);

	for (int num : a |
			views::drop(a.size() - 100))
		cout << format("{:20}", num);


	// 마지막 100개 전에서 100개만 출력 
	//for (int num : a)
	//	cout << format("{:20}", num); //-> 코드가 안돌아간다. 
	/*
		STACK 에 경계를 넘어서 메모리를 읽으려는 시도를 했기 때문에
		스택오버플로우가 나오면서 프로그램이 죽는다.
		스택오버플로우는 경고가 없고 그냥 프로그램이 죽는다. 

	*/

	//cout << sizeof(a) << endl;


	save("STL.cpp");

}

#endif // STL




/*
	array<int, 260'000> a; // stack 의 1MB의 크기를 넘는다. ( 배열은 직렬 메모리 )  
	iota(a.begin(), a.end(), 1); // 배열공간에 쓰는 순간 스택오버플로우로 프로그램이 죽는다. 

	for (int num : a |	# 자료구조에서 한번에 하나씩 데이터를 꺼내라 : 컴파일러가 for(auto p = a.begin(); p != a.end(); ++p) 로 번역한다. 
						# 이렇게 번역하는 것을 syntatic sugar 이라고 한다. 
						# for( int num : a )
			views::drop(a.size() - 100)) // 259900 개를 날려버려랴?
		cout << format("{:20}", num);




*/


===============================================
STL.cpp저장시간 : 2023-03-20 월요일 오전 11:12:08
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 20일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// STACK 의 한계 : 1MB 가 default( 컴파일러가 코드 생성하지 않는 것 주의 )  
// 더 큰 데이터 사용 : DATA 와 Free Store ( HEAP )
// --------------------------------------------------

#include <iostream>
#include <array>
#include <numeric>
#include <format>
#include <ranges>			// C++ 20 Lib



#include "save.h"
using namespace std;


//array<int, 2'600'000> a; // DATA Segment

// 200'000'000/sizeof(int) : 200MB  
//array<int, 200'000'000/ sizeof(int)> a; // DATA Segment 200 MB 
//array<int, 1'000'000'000 / sizeof(int)> a; // DATA Segment 1 GB
//array<int, 2'000'000'000 / sizeof(int)> a; // DATA Segment 2 GB -> 올바른 애플리케이션이 아니라고 뜨네? - 메모리를 통째로 잡을 때 
//array<int, 4'000'000'000 / sizeof(int)> a; // DATA Segment 4 GB -> 2기가 넘어가면 안된다. 
//array<int, 1'990'000'000 / sizeof(int)> a; // DATA Segment 
//array<int, 1'990'000'000 / sizeof(int)> a{}; // DATA Segment  다 0
array<int, 1'990'000'000 / sizeof(int)> a{1}; // DATA Segment  첫번째껏는 1 



// 전역메모리르 초기화 하지 않으면 모든 메모리 비트를 default 초기화로 잡는다. 반드시 0 이 나온다?




// -------	
int main()				
// -------
{
	// STACK 은 1MB 까지 쓸 수 있다. 
	// 여기에서 객체를 생성한다. - STACK에 생성 
	//int a[]; // 앞으로 이런건 쓰지 말자 .
	//array<int, 1'000'000'000> a; // 경고창 뜬다 . 이 전체 블록의 크기는 INT_MAX 로 제한한다. 0x7fffff
	//array<int, 1'000'000> b; // 1MB 를 스택에 잡겠다.
	//array<int, 10'000'000> a; // Stack 에 메모리를 잡겠다고 하지만 사용하지않으면 컴파일러가 알아서 메모리를 생성하지 않아서 프로그램이 돌아간다. 

	//array<int, 260'000> a; // STACK 에 하면 안되지만 HEAP 에 하면 된다. 

	iota(a.begin(), a.end(), 1);

	for (int num : a |
			views::drop(a.size() - 100))
		cout << format("{:20}", num);


	// 마지막 100개 전에서 100개만 출력 
	//for (int num : a)
	//	cout << format("{:20}", num); //-> 코드가 안돌아간다. 
	/*
		STACK 에 경계를 넘어서 메모리를 읽으려는 시도를 했기 때문에
		스택오버플로우가 나오면서 프로그램이 죽는다.
		스택오버플로우는 경고가 없고 그냥 프로그램이 죽는다. 

	*/

	//cout << sizeof(a) << endl;


	save("STL.cpp");

}

#endif // STL




/*
	array<int, 260'000> a; // stack 의 1MB의 크기를 넘는다. ( 배열은 직렬 메모리 )  
	iota(a.begin(), a.end(), 1); // 배열공간에 쓰는 순간 스택오버플로우로 프로그램이 죽는다. 

	for (int num : a |	# 자료구조에서 한번에 하나씩 데이터를 꺼내라 : 컴파일러가 for(auto p = a.begin(); p != a.end(); ++p) 로 번역한다. 
						# 이렇게 번역하는 것을 syntatic sugar 이라고 한다. 
						# for( int num : a )
			views::drop(a.size() - 100)) // 259900 개를 날려버려랴?
		cout << format("{:20}", num);




*/


===============================================
STL.cpp저장시간 : 2023-03-20 월요일 오전 11:15:12
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 20일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// STACK 의 한계 : 1MB 가 default( 컴파일러가 코드 생성하지 않는 것 주의 )  
// 더 큰 데이터 사용 : DATA 와 Free Store ( HEAP )
// --------------------------------------------------

#include <iostream>
#include <array>
#include <numeric>
#include <format>
#include <ranges>			// C++ 20 Lib



#include "save.h"
using namespace std;


//array<int, 2'600'000> a; // DATA Segment

// 200'000'000/sizeof(int) : 200MB  
//array<int, 200'000'000/ sizeof(int)> a; // DATA Segment 200 MB 
//array<int, 1'000'000'000 / sizeof(int)> a; // DATA Segment 1 GB
//array<int, 2'000'000'000 / sizeof(int)> a; // DATA Segment 2 GB -> 올바른 애플리케이션이 아니라고 뜨네? - 메모리를 통째로 잡을 때 
//array<int, 4'000'000'000 / sizeof(int)> a; // DATA Segment 4 GB -> 2기가 넘어가면 안된다. 
//array<int, 1'990'000'000 / sizeof(int)> a; // DATA Segment 
//array<int, 1'990'000'000 / sizeof(int)> a{}; // DATA Segment  다 0
//array<int, 1'990'000'000 / sizeof(int)> a{1}; // DATA Segment  첫번째껏는 1 -> 실행파일 크기가 2기가



// 전역메모리르 초기화 하지 않으면 모든 메모리 비트를 default 초기화로 잡는다. 반드시 0 이 나온다?


array<int, 1'990'000'000 / sizeof(int)> a{ 1 };

// -------	
int main()				
// -------
{
	// STACK 은 1MB 까지 쓸 수 있다. 
	// 여기에서 객체를 생성한다. - STACK에 생성 
	//int a[]; // 앞으로 이런건 쓰지 말자 .
	//array<int, 1'000'000'000> a; // 경고창 뜬다 . 이 전체 블록의 크기는 INT_MAX 로 제한한다. 0x7fffff
	//array<int, 1'000'000> b; // 1MB 를 스택에 잡겠다.
	//array<int, 10'000'000> a; // Stack 에 메모리를 잡겠다고 하지만 사용하지않으면 컴파일러가 알아서 메모리를 생성하지 않아서 프로그램이 돌아간다. 

	//array<int, 260'000> a; // STACK 에 하면 안되지만 HEAP 에 하면 된다. 

	//iota(a.begin(), a.end(), 1);

	//for (int num : a |
	//		views::drop(a.size() - 100))
	//	cout << format("{:20}", num);

	for (int num : a |
		views::take(100))
		cout << format(" {:10}", num);


	// 마지막 100개 전에서 100개만 출력 
	//for (int num : a)
	//	cout << format("{:20}", num); //-> 코드가 안돌아간다. 
	/*
		STACK 에 경계를 넘어서 메모리를 읽으려는 시도를 했기 때문에
		스택오버플로우가 나오면서 프로그램이 죽는다.
		스택오버플로우는 경고가 없고 그냥 프로그램이 죽는다. 

	*/

	//cout << sizeof(a) << endl;


	save("STL.cpp");

}

#endif // STL




/*
	array<int, 260'000> a; // stack 의 1MB의 크기를 넘는다. ( 배열은 직렬 메모리 )  
	iota(a.begin(), a.end(), 1); // 배열공간에 쓰는 순간 스택오버플로우로 프로그램이 죽는다. 

	for (int num : a |	# 자료구조에서 한번에 하나씩 데이터를 꺼내라 : 컴파일러가 for(auto p = a.begin(); p != a.end(); ++p) 로 번역한다. 
						# 이렇게 번역하는 것을 syntatic sugar 이라고 한다. 
						# for( int num : a )
			views::drop(a.size() - 100)) // 259900 개를 날려버려랴?
		cout << format("{:20}", num);




*/


===============================================
STL.cpp저장시간 : 2023-03-20 월요일 오전 11:38:42
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 20일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// STACK 의 한계 : 1MB 가 default( 컴파일러가 코드 생성하지 않는 것 주의 ) - 아무런 경고가 없다.   
// 더 큰 데이터 사용 : DATA 와 Free Store ( HEAP )
// --------------------------------------------------

#include <iostream>
#include <array>


#include "save.h"
using namespace std;

// -------	
int main()				
// -------
{
	
	// 어떻게 하면 스택오버플로우를 발생시킬건가? : 재귀호출 
	array<int, 1000> a;
	a[0] = 123;
	a[999] = 456;
	cout << a[0] << ", " << a[999] << endl;



	save("STL.cpp");

}

#endif // STL




/*
	array<int, 260'000> a; // stack 의 1MB의 크기를 넘는다. ( 배열은 직렬 메모리 )  
	iota(a.begin(), a.end(), 1); // 배열공간에 쓰는 순간 스택오버플로우로 프로그램이 죽는다. 

	for (int num : a |	# 자료구조에서 한번에 하나씩 데이터를 꺼내라 : 컴파일러가 for(auto p = a.begin(); p != a.end(); ++p) 로 번역한다. 
						# 이렇게 번역하는 것을 syntatic sugar 이라고 한다. 
						# for( int num : a )
			views::drop(a.size() - 100)) // 259900 개를 날려버려랴?
		cout << format("{:20}", num);




*/


===============================================
STL.cpp저장시간 : 2023-03-20 월요일 오전 11:54:02
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 20일 Mon 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// STACK 의 한계 : 1MB 가 default( 컴파일러가 코드 생성하지 않는 것 주의 ) - 아무런 경고가 없다.   
// 더 큰 데이터 사용 : DATA 와 Free Store ( HEAP )
// --------------------------------------------------

#include <iostream>
#include <array>


#include "save.h"
using namespace std;


// -------	
int main()				
// -------
{

	/*
			Q :  사용자가 입력한 숫자만큼 int 를 저장할 메모리를 생성하라.
			값을 1 부터 시작하는 정수로 채워나가라.
			합계를 화면에 출력하라.

				예) 10 을 입력하였다.
					-> int 10개가 들어갈 공간을 확보하고 -> 1 2 3 4 5 6 7 ... 10
					합계는 55 입니다 라고 화면에 출력
	*/

	/*
		** 내가 직접 짠 코드 **
		
		cout << "int를 몇 개 만들까요? : ";
		int num;
		cin >> num;

		int* p = new int[num];
		int sum = 0;

		for (int i = 1; i < num; ++i){
			p[i - 1] = i;
			cout << i << " ";
			sum += i;

		}
		cout << "합계는 " << sum << " 입니다." << endl;

	*/

	/*
		
			** 교수님 코드 
			
	*/
	cout << "int를 몇 개 만들까요? : ";
	int num;
	cin >> num;

	//array<int, num > a; // 상수로 넣어야 해! ( 컴파일러가 기계어로 바꿔나가는 동안 이 크기를 결정할 수 있어야해 ) - 컴파일 타임 콘스탄트
	
	//int* p = new int[num]; // default 생성자를 부르나 ? ㄴㄴ 초기화 안됨 쓰레기값 들어감 
	
	int* p = new int[num] {};

	for (int i = 0; i < num; ++i){
		cout << p[i] << " ";
	}



	//cout << "합계는 " << sum << " 입니다." << endl;


	
	save("STL.cpp");

}

#endif // STL




/*
	array<int, 260'000> a; // stack 의 1MB의 크기를 넘는다. ( 배열은 직렬 메모리 )  
	iota(a.begin(), a.end(), 1); // 배열공간에 쓰는 순간 스택오버플로우로 프로그램이 죽는다. 

	for (int num : a |	# 자료구조에서 한번에 하나씩 데이터를 꺼내라 : 컴파일러가 for(auto p = a.begin(); p != a.end(); ++p) 로 번역한다. 
						# 이렇게 번역하는 것을 syntatic sugar 이라고 한다. 
						# for( int num : a )
			views::drop(a.size() - 100)) // 259900 개를 날려버려랴?
		cout << format("{:20}", num);




*/


===============================================
STL.cpp저장시간 : 2023-03-21 화요일 오후 1:39:47
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 21일 TUE 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// STACK 의 한계 : 1MB 가 default( 컴파일러가 코드 생성하지 않는 것 주의 ) - 아무런 경고가 없다.   
// 더 큰 데이터 사용 : DATA 와 Free Store ( HEAP )
// --------------------------------------------------

#include <iostream>
#include <array>
#include <ranges>
#include <numeric>

#include "save.h"
using namespace std;

class Dog {
private:



public:
	Dog() { cout << "생성 " << endl; }
	~Dog() { cout << "소멸 " << endl; }
	
	
};

// -------	
int main()				
// -------
{


	save("STL.cpp");

	Dog* p = new Dog;

	// TODO 
	

	delete p;


}

#endif // STL




===============================================
STL.cpp저장시간 : 2023-03-21 화요일 오후 1:40:02
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 21일 TUE 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// STACK 의 한계 : 1MB 가 default( 컴파일러가 코드 생성하지 않는 것 주의 ) - 아무런 경고가 없다.   
// 더 큰 데이터 사용 : DATA 와 Free Store ( HEAP )
// --------------------------------------------------

#include <iostream>
#include <array>
#include <ranges>
#include <numeric>

#include "save.h"
using namespace std;

class Dog {
private:



public:
	Dog() { cout << "생성 " << endl; }
	~Dog() { cout << "소멸 " << endl; }
	
	
};

// -------	
int main()				
// -------
{


	save("STL.cpp");

	Dog* p = new Dog;

	// TODO 
	throw 1;


	delete p;


}

#endif // STL




===============================================
STL.cpp저장시간 : 2023-03-21 화요일 오후 1:42:03
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 21일 TUE 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// STACK 의 한계 : 1MB 가 default( 컴파일러가 코드 생성하지 않는 것 주의 ) - 아무런 경고가 없다.   
// 더 큰 데이터 사용 : DATA 와 Free Store ( HEAP )
// --------------------------------------------------

#include <iostream>
#include <array>
#include <ranges>
#include <numeric>

#include "save.h"
using namespace std;

class Dog {
private:



public:
	Dog() { cout << "생성 " << endl; }
	~Dog() { cout << "소멸 " << endl; }
	
	
};

void f()
{
	Dog* p = new Dog;

	// TODO 
	/*
		예외를 날리는 순간 아래 코드가 실행이 안되고 
		이 함수를 불렀던 곳으로 돌아간다. 

	*/
	throw 1;


	delete p;


}

// -------	
int main()				
// -------
{


	save("STL.cpp");
	
	f();

	cout << " asdf" << endl;


}

#endif // STL




===============================================
STL.cpp저장시간 : 2023-03-21 화요일 오후 1:43:15
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 21일 TUE 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// STACK 의 한계 : 1MB 가 default( 컴파일러가 코드 생성하지 않는 것 주의 ) - 아무런 경고가 없다.   
// 더 큰 데이터 사용 : DATA 와 Free Store ( HEAP )
// --------------------------------------------------

#include <iostream>
#include <array>
#include <ranges>
#include <numeric>

#include "save.h"
using namespace std;

class Dog {
private:



public:
	Dog() { cout << "생성 " << endl; }
	~Dog() { cout << "소멸 " << endl; }
	
	
};

void f()
{
	Dog* p = new Dog;

	// TODO 
	/*
		예외를 날리는 순간 아래 코드가 실행이 안되고 
		이 함수를 불렀던 곳으로 돌아간다. 

	*/
	throw 1;


	delete p;


}

// -------	
int main()				
// -------
{


	save("STL.cpp");
	
	f(); // f 에서 예외가 처리되지 못했기 때문에 아래 코드들도 정상 작동 되지 않는다. 
	try {
		f();

	}
	catch (int) {
		cout << " 예외를 잡았다." << endl;

	}


}

#endif // STL




===============================================
STL.cpp저장시간 : 2023-03-21 화요일 오후 1:43:26
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 21일 TUE 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// STACK 의 한계 : 1MB 가 default( 컴파일러가 코드 생성하지 않는 것 주의 ) - 아무런 경고가 없다.   
// 더 큰 데이터 사용 : DATA 와 Free Store ( HEAP )
// --------------------------------------------------

#include <iostream>
#include <array>
#include <ranges>
#include <numeric>

#include "save.h"
using namespace std;

class Dog {
private:



public:
	Dog() { cout << "생성 " << endl; }
	~Dog() { cout << "소멸 " << endl; }
	
	
};

void f()
{
	Dog* p = new Dog;

	// TODO 
	/*
		예외를 날리는 순간 아래 코드가 실행이 안되고 
		이 함수를 불렀던 곳으로 돌아간다. 

	*/
	throw 1;


	delete p;


}

// -------	
int main()				
// -------
{


	save("STL.cpp");
	
	//f(); // f 에서 예외가 처리되지 못했기 때문에 아래 코드들도 정상 작동 되지 않는다. 
	try {
		f();

	}
	catch (int) {
		cout << " 예외를 잡았다." << endl;

	}


}

#endif // STL




===============================================
STL.cpp저장시간 : 2023-03-21 화요일 오후 1:48:02
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 21일 TUE 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// STACK 의 한계 : 1MB 가 default( 컴파일러가 코드 생성하지 않는 것 주의 ) - 아무런 경고가 없다.   
// 더 큰 데이터 사용 : DATA 와 Free Store ( HEAP )
// --------------------------------------------------

#include <iostream>
#include <array>
#include <ranges>
#include <numeric>
#include <memory>

#include "save.h"
using namespace std;

class Dog {
private:



public:
	Dog() { cout << "생성 " << endl; }
	~Dog() { cout << "소멸 " << endl; }
	
	
};

void f()
{
	/*
	
		앞으로 쓰지 말아야할것 
		1. []
		2. * ( raw Pointer ) 를 쓰지 말 것 -> Smart Pointer 를 사용하라. 
			- unique_ptr<타입>

		*/
	//Dog* p = new Dog;
	unique_ptr<Dog> p{new Dog}; // RAII 자원을 할당하고 해제하는 것을 자동화 하는 패턴이다. 


	// TODO 
	/*
		예외를 날리는 순간 아래 코드가 실행이 안되고 
		이 함수를 불렀던 곳으로 돌아간다. 

	*/
	throw 1; // 예외 발생 

}

// -------	
int main()				
// -------
{


	save("STL.cpp");
	
	//f(); // f 에서 예외가 처리되지 못했기 때문에 아래 코드들도 정상 작동 되지 않는다. 
	try {
		f();

	}
	catch (int) {
		cout << " 예외를 잡았다." << endl;

	}


}

#endif // STL




===============================================
STL.cpp저장시간 : 2023-03-21 화요일 오후 1:50:16
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 21일 TUE 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// STACK 의 한계 : 1MB 가 default( 컴파일러가 코드 생성하지 않는 것 주의 ) - 아무런 경고가 없다.   
// 더 큰 데이터 사용 : DATA 와 Free Store ( HEAP )
// --------------------------------------------------

#include <iostream>
#include <array>
#include <ranges>
#include <numeric>
#include <memory>

#include "save.h"
using namespace std;

class Dog {
private:



public:
	Dog() { cout << "생성 " << endl; }
	~Dog() { cout << "소멸 " << endl; }
	
	
};

void f()
{
	/*
	
		앞으로 쓰지 말아야할것 
		1. []
		2. * ( raw Pointer ) 를 쓰지 말 것 -> Smart Pointer 를 사용하라. 
			- unique_ptr<타입>

		*/
	//Dog* p = new Dog;
	unique_ptr<Dog[]> p{new Dog[5]}; // RAII 자원을 할당하고 해제하는 것을 자동화 하는 패턴이다. 
	// new Dog : 생성 
	// 나가서 catch 가 들어가는데 그 전에 지역개체인 p메모리를 삭제한다. 
	
	/*
		예외를 날리는 순간 아래 코드가 실행이 안되고 
		이 함수를 불렀던 곳으로 돌아간다. 

	*/
	throw 1; // 예외 발생 

}

// -------	
int main()				
// -------
{


	save("STL.cpp");
	
	//f(); // f 에서 예외가 처리되지 못했기 때문에 아래 코드들도 정상 작동 되지 않는다. 
	try {
		f();

	}
	catch (int) {
		cout << " 예외를 잡았다." << endl;

	}


}

#endif // STL




===============================================
STL.cpp저장시간 : 2023-03-21 화요일 오후 1:53:02
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 21일 TUE 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// STACK 의 한계 : 1MB 가 default( 컴파일러가 코드 생성하지 않는 것 주의 ) - 아무런 경고가 없다.   
// 더 큰 데이터 사용 : DATA 와 Free Store ( HEAP )
// --------------------------------------------------

#include <iostream>
#include <array>
#include <ranges>
#include <numeric>
#include <memory>

#include "save.h"
using namespace std;

class Dog {
private:



public:
	Dog() { cout << "생성 " << endl; }
	~Dog() { cout << "소멸 " << endl; }
	
	
};

void f()
{
	/*
	
		앞으로 쓰지 말아야할것 
		1. []
		2. * ( raw Pointer ) 를 쓰지 말 것 -> Smart Pointer 를 사용하라. 
			- unique_ptr<타입>
		- 예외가 발생하더라도 STACK 에 생성된 지역객체가 소멸됨을 보증한다. - STACK UNWINDING 
		


		*/
	//Dog* p = new Dog;
	unique_ptr<Dog> p{new Dog[5]}; // RAII 자원을 할당하고 해제하는 것을 자동화 하는 패턴이다. 
	// new Dog : 생성 
	// 나가서 catch 가 들어가는데 그 전에 지역개체인 p메모리를 삭제한다. 
	/// 반드시 예외를 집어넣기 전에 내 스택에 있던 지역개체의 소멸을 보장한다. 
	/// Stack Unwinding -> 아주 중요하니까 꼭 찾아보자 
	/// 
	
	/*
		예외를 날리는 순간 아래 코드가 실행이 안되고 
		이 함수를 불렀던 곳으로 돌아간다. 

	*/
	throw 1; // 예외 발생 

}

// -------	
int main()				
// -------
{


	save("STL.cpp");
	
	//f(); // f 에서 예외가 처리되지 못했기 때문에 아래 코드들도 정상 작동 되지 않는다. 
	try {
		f();

	}
	catch (int) {
		cout << " 예외를 잡았다." << endl;

	}


}

#endif // STL




===============================================
STL.cpp저장시간 : 2023-03-21 화요일 오후 2:00:30
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 21일 TUE 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// STACK 의 한계 : 1MB 가 default( 컴파일러가 코드 생성하지 않는 것 주의 ) - 아무런 경고가 없다.   
// 더 큰 데이터 사용 : DATA 와 Free Store ( HEAP )
// --------------------------------------------------

#include <iostream>
#include <array>
#include <ranges>
#include <numeric>
#include <memory>

#include "save.h"
using namespace std;

class Dog {
private:



public:
	Dog() { cout << "생성 " << endl; }
	~Dog() { cout << "소멸 " << endl; }
	
	
};

void f()
{
	/*
	
		앞으로 쓰지 말아야할것 
		1. []
		2. * ( raw Pointer ) 를 쓰지 말 것 -> Smart Pointer 를 사용하라. 
			- unique_ptr<타입>
		- 예외가 발생하더라도 STACK 에 생성된 지역객체가 소멸됨을 보증한다. - STACK UNWINDING 
		


		*/
	//Dog* p = new Dog;
	unique_ptr<Dog[]> p{new Dog[5]}; // RAII 자원을 할당하고 해제하는 것을 자동화 하는 패턴이다. 
	// new Dog : 생성 
	// 나가서 catch 가 들어가는데 그 전에 지역개체인 p메모리를 삭제한다. 
	/// 반드시 예외를 집어넣기 전에 내 스택에 있던 지역개체의 소멸을 보장한다. 
	/// Stack Unwinding -> 아주 중요하니까 꼭 찾아보자 
	/// 
	
	/*
		예외를 날리는 순간 아래 코드가 실행이 안되고 
		이 함수를 불렀던 곳으로 돌아간다. 

	*/
	throw 1; // 예외 발생 

}

// -------	
int main()
// -------
{


	save("STL.cpp");

	int cnt{};
	while (true) {
		new char[1'000'000'000]; // 메모리 1기가 달라 
		cout << ++cnt << " 할당 성공 " << endl;

	}

}
#endif // STL




===============================================
STL.cpp저장시간 : 2023-03-21 화요일 오후 2:02:43
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 21일 TUE 23 Tue 56 ( 1주 1)
// --------------------------------------------------
// STACK 의 한계 : 1MB 가 default( 컴파일러가 코드 생성하지 않는 것 주의 ) - 아무런 경고가 없다.   
// 더 큰 데이터 사용 : DATA 와 Free Store ( HEAP )
// --------------------------------------------------

#include <iostream>
#include <array>
#include <ranges>
#include <numeric>
#include <memory>

#include "save.h"
using namespace std;

class Dog {
private:



public:
	Dog() { cout << "생성 " << endl; }
	~Dog() { cout << "소멸 " << endl; }
	
	
};

void f()
{
	/*
	
		앞으로 쓰지 말아야할것 
		1. []
		2. * ( raw Pointer ) 를 쓰지 말 것 -> Smart Pointer 를 사용하라. 
			- unique_ptr<타입>
		- 예외가 발생하더라도 STACK 에 생성된 지역객체가 소멸됨을 보증한다. - STACK UNWINDING 
		


		*/
	//Dog* p = new Dog;
	unique_ptr<Dog[]> p{new Dog[5]}; // RAII 자원을 할당하고 해제하는 것을 자동화 하는 패턴이다. 
	// new Dog : 생성 
	// 나가서 catch 가 들어가는데 그 전에 지역개체인 p메모리를 삭제한다. 
	/// 반드시 예외를 집어넣기 전에 내 스택에 있던 지역개체의 소멸을 보장한다. 
	/// Stack Unwinding -> 아주 중요하니까 꼭 찾아보자 
	/// 
	
	/*
		예외를 날리는 순간 아래 코드가 실행이 안되고 
		이 함수를 불렀던 곳으로 돌아간다. 

	*/
	throw 1; // 예외 발생 

}

// -------	
int main()
// -------
{


	save("STL.cpp");

	int cnt{};
	while (true) {
		try {
			new char[1'000'000'000]; // 메모리 1기가 달라 
		}
		catch (exception& e) {
			cout << e.what() << endl;
			return 0;
		}
		cout << ++cnt << " 할당 성공 " << endl;

	}
	/*
		메모리 할당 실패하면 nullptr 을 주지않는다. 

	
	*/



}
#endif // STL




===============================================
STL.cpp저장시간 : 2023-03-21 화요일 오후 2:11:48
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 21일 TUE 23 Tue 56 ( 1주 1)
// --------------------------------------------------
//	파일 예제
// --------------------------------------------------

#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <chrono>


#include "save.h"

using namespace std;

/*
	[문제] "STL.cpp"를 읽어 소문자는 대문자로 변환하여 
	"STL대문자.cpp" 에 저장하라. 
*/


std::vector<char> GetWords(const std::string& ReadFileName)
{
	std::ifstream InFile{ ReadFileName };
	std::vector<char> vWords{ std::istreambuf_iterator<char> { InFile}, {} };
	return vWords;
}

// -------	
int main()
// -------
{
	save("STL.cpp");

	std:vector<char> vWords = GetWords("STL.cpp");
	for (int i = 0; i < vWords.size(); ++i)
		cout << vWords[i] << endl;

	

}
#endif // STL




===============================================
STL.cpp저장시간 : 2023-03-21 화요일 오후 2:17:49
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 21일 TUE 23 Tue 56 ( 1주 1)
// --------------------------------------------------
//	파일 예제
// --------------------------------------------------

#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <chrono>


#include "save.h"

using namespace std;

/*
	[문제] "STL.cpp"를 읽어 소문자는 대문자로 변환하여 
	"STL대문자.cpp" 에 저장하라. 

	*
	* 문제 해결 - 교수님 
	* 
*/


std::vector<char> GetWords(const std::string& ReadFileName)
{
	std::ifstream InFile{ ReadFileName };
	std::vector<char> vWords{ std::istreambuf_iterator<char> { InFile}, {} };
	return vWords;
}

// -------	
int main()
// -------
{
	save("STL.cpp");


	// STL.cpp 에서 한 글자를 읽는다. 
	// 글자가 소문자라면 대문자로 바꾼다. 
	// 글자를 저장한다.
	// 소스 대문자.cpp 글자를 저장한다. 

	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	// 다른 코드 쓰면 다 0 점 나온다 
	char c;
	while (in >> c) {
		
		// 'a' ~ 'c'이런식으로
		if (islower(c)) { // 가독성이 좋은 코드다. 
			c = toupper(c);
		}

		cout << c;



	}
	


	std:vector<char> vWords = GetWords("STL.cpp");


}
#endif // STL




===============================================
STL.cpp저장시간 : 2023-03-21 화요일 오후 2:18:56
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 21일 TUE 23 Tue 56 ( 1주 1)
// --------------------------------------------------
//	파일 예제
// --------------------------------------------------

#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <chrono>


#include "save.h"

using namespace std;

/*
	[문제] "STL.cpp"를 읽어 소문자는 대문자로 변환하여 
	"STL대문자.cpp" 에 저장하라. 

	*
	* 문제 해결 - 교수님 
	* 
*/


std::vector<char> GetWords(const std::string& ReadFileName)
{
	std::ifstream InFile{ ReadFileName };
	std::vector<char> vWords{ std::istreambuf_iterator<char> { InFile}, {} };
	return vWords;
}

// -------	
int main()
// -------
{
	save("STL.cpp");


	// STL.cpp 에서 한 글자를 읽는다. 
	// 글자가 소문자라면 대문자로 바꾼다. 
	// 글자를 저장한다.
	// 소스 대문자.cpp 글자를 저장한다. 

	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	// 다른 코드 쓰면 다 0 점 나온다 
	char c;
	in >> noskipws; // 공백을 무시하지 말도록 지시한다. 
	while (in >> c) { // in >> c 때문에 글자만 읽어오라고 시키니 공백을 건너뛰었다. 
		
		// 'a' ~ 'c'이런식으로
		if (islower(c)) { // 가독성이 좋은 코드다. 
			c = toupper(c);
		}

		cout << c;



	}
	


	std:vector<char> vWords = GetWords("STL.cpp");


}
#endif // STL




===============================================
STL.cpp저장시간 : 2023-03-21 화요일 오후 2:19:24
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 21일 TUE 23 Tue 56 ( 1주 1)
// --------------------------------------------------
//	파일 예제
// --------------------------------------------------

#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <chrono>


#include "save.h"

using namespace std;

/*
	[문제] "STL.cpp"를 읽어 소문자는 대문자로 변환하여 
	"STL대문자.cpp" 에 저장하라. 

	*
	* 문제 해결 - 교수님 
	* 
*/


std::vector<char> GetWords(const std::string& ReadFileName)
{
	std::ifstream InFile{ ReadFileName };
	std::vector<char> vWords{ std::istreambuf_iterator<char> { InFile}, {} };
	return vWords;
}

// -------	
int main()
// -------
{
	save("STL.cpp");


	// STL.cpp 에서 한 글자를 읽는다. 
	// 글자가 소문자라면 대문자로 바꾼다. 
	// 글자를 저장한다.
	// 소스 대문자.cpp 글자를 저장한다. 

	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	// 다른 코드 쓰면 다 0 점 나온다 
	char c;
	in >> noskipws; // 공백을 무시하지 말도록 지시한다. 
	while (in >> c) { // in >> c 때문에 글자만 읽어오라고 시키니 공백을 건너뛰었다. 
		
		// 'a' ~ 'c'이런식으로
		if (islower(c)) { // 가독성이 좋은 코드다. 
			c = toupper(c);
		}
		out << c;

	}
	


	std:vector<char> vWords = GetWords("STL.cpp");


}
#endif // STL




===============================================
STL.cpp저장시간 : 2023-03-21 화요일 오후 2:27:10
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 21일 TUE 23 Tue 56 ( 1주 1)
// --------------------------------------------------
//	파일 예제
// --------------------------------------------------

#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <chrono>
#include <algorithm>


#include "save.h"

using namespace std;

/*
	[문제] "STL.cpp"를 읽어 소문자는 대문자로 변환하여 
	"STL대문자.cpp" 에 저장하라. 

	*
	* 문제 해결 - 교수님 
	* 
*/



// -------	
int main()
// -------
{
	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	//transform(이걸, 저걸로, 이런방식으로);
	transform(std::istreambuf_iterator<char>{in}
	, {}
		, std::ostreambuf_iterator<char>{out}/* lambda ( Collable 함수 ? )*/
	, [](char c) {
		return c = toupper(c);
	}
	);

	save("STL.cpp");

}
#endif // STL



	/*
	
	
	// STL.cpp 에서 한 글자를 읽는다. 
	// 글자가 소문자라면 대문자로 바꾼다. 
	// 글자를 저장한다.
	// 소스 대문자.cpp 글자를 저장한다. 

	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	
		프로그램의 문제점 : islower(c) 체크할 이유가 전혀 없다? 
		touppper 에서 알아서 체크
		삽질 하는 것이다. 
	
	
	// 다른 코드 쓰면 다 0 점 나온다 
	char c;
	in >> noskipws; // 공백을 무시하지 말도록 지시한다. 
	while (in >> c) { // in >> c 때문에 글자만 읽어오라고 시키니 공백을 건너뛰었다. 

		// 'a' ~ 'c'이런식으로
		//if (islower(c))  // 가독성이 좋은 코드다. 
		c = toupper(c);
		out << c;

	}



std:vector<char> vWords = GetWords("STL.cpp");


}
	
*/


===============================================
STL.cpp저장시간 : 2023-03-21 화요일 오후 2:42:21
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 21일 TUE 23 Tue 56 ( 1주 1)
// --------------------------------------------------
//	파일 예제
// --------------------------------------------------

#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <chrono>
#include <algorithm>


#include "save.h"

using namespace std;

/*
	[문제] "STL.cpp"를 읽어 소문자는 대문자로 변환하여 
	"STL대문자.cpp" 에 저장하라. 

	*
	* 문제 해결 - 교수님 
	* 
*/



// -------	
int main()
// -------
{
	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	//transform(이걸, 저걸로, 이런방식으로);
	transform(
	  std::istreambuf_iterator<char>{in}
	, {}
	, std::ostreambuf_iterator<char>{out}/* lambda ( Collable 함수 ? )*/
	, [](char c) {
		if (isdigit(c)) c = '*';
		return c;
	}
	);

	save("STL.cpp");

}
#endif // STL



	/*
	
	
	// STL.cpp 에서 한 글자를 읽는다. 
	// 글자가 소문자라면 대문자로 바꾼다. 
	// 글자를 저장한다.
	// 소스 대문자.cpp 글자를 저장한다. 

	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	
		프로그램의 문제점 : islower(c) 체크할 이유가 전혀 없다? 
		touppper 에서 알아서 체크
		삽질 하는 것이다. 
	
	
	// 다른 코드 쓰면 다 0 점 나온다 
	char c;
	in >> noskipws; // 공백을 무시하지 말도록 지시한다. 
	while (in >> c) { // in >> c 때문에 글자만 읽어오라고 시키니 공백을 건너뛰었다. 

		// 'a' ~ 'c'이런식으로
		//if (islower(c))  // 가독성이 좋은 코드다. 
		c = toupper(c);
		out << c;

	}



std:vector<char> vWords = GetWords("STL.cpp");


}
	
*/


===============================================
STL.cpp저장시간 : 2023-03-21 화요일 오후 2:42:35
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 21일 TUE 23 Tue 56 ( 1주 1)
// --------------------------------------------------
//	파일 예제
// --------------------------------------------------

#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <chrono>
#include <algorithm>


#include "save.h"

using namespace std;

/*
	[문제] "STL.cpp"를 읽어 소문자는 대문자로 변환하여 
	"STL대문자.cpp" 에 저장하라. 

	*
	* 문제 해결 - 교수님 
	* 
*/



// -------	
int main()
// -------
{
	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	//transform(이걸, 저걸로, 이런방식으로);
	transform(
	  std::istreambuf_iterator<char>{in}
	, {}
	, std::ostreambuf_iterator<char>{cout}/* lambda ( Collable 함수 ? )*/
	, [](char c) {
		if (isdigit(c)) c = '*';
		return c;
	}
	);

	save("STL.cpp");

}
#endif // STL



	/*
	
	
	// STL.cpp 에서 한 글자를 읽는다. 
	// 글자가 소문자라면 대문자로 바꾼다. 
	// 글자를 저장한다.
	// 소스 대문자.cpp 글자를 저장한다. 

	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	
		프로그램의 문제점 : islower(c) 체크할 이유가 전혀 없다? 
		touppper 에서 알아서 체크
		삽질 하는 것이다. 
	
	
	// 다른 코드 쓰면 다 0 점 나온다 
	char c;
	in >> noskipws; // 공백을 무시하지 말도록 지시한다. 
	while (in >> c) { // in >> c 때문에 글자만 읽어오라고 시키니 공백을 건너뛰었다. 

		// 'a' ~ 'c'이런식으로
		//if (islower(c))  // 가독성이 좋은 코드다. 
		c = toupper(c);
		out << c;

	}



std:vector<char> vWords = GetWords("STL.cpp");


}
	
*/


===============================================
STL.cpp저장시간 : 2023-03-21 화요일 오후 3:06:13
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 21일 TUE 23 Tue 56 ( 1주 1)
// --------------------------------------------------
//	정렬( sort ) - Callable Type ( 호출가능타입 ) 
// --------------------------------------------------

/*
	2.문제 
		int 10'000'000개를 생성하라. 랜덤값으로 채운다. 
		오른차순으로 정렬한다. 
		끝에서 뒷부분 100개만 찍자. 
*/


#include <iostream>
#include <array>
#include <algorithm>
#include <format>
#include <ranges>
#include <random>
#include <format>



#include "save.h"

using namespace std;

array<int, 10'000'000> numbers;
default_random_engine dre;
uniform_int_distribution uid{ 1, 10'000'000 };

int how( const void * a, const void* b )
{
	return *(int*)a - *(int*)b;

}

// -------	
int main()
// -------
{
	for (int& num : numbers) {
		num = uid(dre); 
	}

	// 오름 차순 정렬 - qsort 와 sort 
	qsort((void*)&numbers, numbers.size(), sizeof(int), /*어떻게 정렬할까?*/how); // Generic 함수  -	아무거나 다 정렬한다. 



	// 뒤에서 부터 100 개 찍기
	for (int num : numbers |
		views::drop(numbers.size() - 100))
	cout << format("{:10}", num);


	cout << "qsort 네번째 인자의 타입 " << typeid(how).name() << endl;

		
	save("STL.cpp");

}
#endif // STL



	/*
	
	
	// STL.cpp 에서 한 글자를 읽는다. 
	// 글자가 소문자라면 대문자로 바꾼다. 
	// 글자를 저장한다.
	// 소스 대문자.cpp 글자를 저장한다. 

	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	
		프로그램의 문제점 : islower(c) 체크할 이유가 전혀 없다? 
		touppper 에서 알아서 체크
		삽질 하는 것이다. 
	
	
	// 다른 코드 쓰면 다 0 점 나온다 
	char c;
	in >> noskipws; // 공백을 무시하지 말도록 지시한다. 
	while (in >> c) { // in >> c 때문에 글자만 읽어오라고 시키니 공백을 건너뛰었다. 

		// 'a' ~ 'c'이런식으로
		//if (islower(c))  // 가독성이 좋은 코드다. 
		c = toupper(c);
		out << c;

	}



std:vector<char> vWords = GetWords("STL.cpp");


}
	
*/


===============================================
STL.cpp저장시간 : 2023-03-21 화요일 오후 3:07:01
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 21일 TUE 23 Tue 56 ( 1주 1)
// --------------------------------------------------
//	정렬( sort ) - Callable Type ( 호출가능타입 ) 
// --------------------------------------------------

/*
	2.문제 
		int 10'000'000개를 생성하라. 랜덤값으로 채운다. 
		오른차순으로 정렬한다. 
		끝에서 뒷부분 100개만 찍자. 
*/


#include <iostream>
#include <array>
#include <algorithm>
#include <format>
#include <ranges>
#include <random>
#include <format>



#include "save.h"

using namespace std;

array<int, 10'000'000> numbers;
default_random_engine dre;
uniform_int_distribution uid{ 1, 10'000'000 };

int 어떻게( const void * a, const void* b )
{
	return *(int*)a - *(int*)b;

}

// -------	
int main()
// -------
{
	for (int& num : numbers) {
		num = uid(dre); 
	}

	// 오름 차순 정렬 - qsort 와 sort 
	qsort((void*)&numbers, numbers.size(), sizeof(int), /*어떻게 정렬할까?*/어떻게); // Generic 함수  -	아무거나 다 정렬한다. 



	// 뒤에서 부터 100 개 찍기
	for (int num : numbers |
		views::drop(numbers.size() - 100))
	cout << format("{:10}", num);

	cout << endl;
	cout << "qsort 네번째 인자의 타입 " << typeid(어떻게).name() << endl;

		
	save("STL.cpp");

}
#endif // STL



	/*
	
	
	// STL.cpp 에서 한 글자를 읽는다. 
	// 글자가 소문자라면 대문자로 바꾼다. 
	// 글자를 저장한다.
	// 소스 대문자.cpp 글자를 저장한다. 

	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	
		프로그램의 문제점 : islower(c) 체크할 이유가 전혀 없다? 
		touppper 에서 알아서 체크
		삽질 하는 것이다. 
	
	
	// 다른 코드 쓰면 다 0 점 나온다 
	char c;
	in >> noskipws; // 공백을 무시하지 말도록 지시한다. 
	while (in >> c) { // in >> c 때문에 글자만 읽어오라고 시키니 공백을 건너뛰었다. 

		// 'a' ~ 'c'이런식으로
		//if (islower(c))  // 가독성이 좋은 코드다. 
		c = toupper(c);
		out << c;

	}



std:vector<char> vWords = GetWords("STL.cpp");


}
	
*/


===============================================
STL.cpp저장시간 : 2023-03-21 화요일 오후 3:09:58
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 21일 TUE 23 Tue 56 ( 1주 1)
// --------------------------------------------------
//	정렬( sort ) - Callable Type ( 호출가능타입 ) 
// --------------------------------------------------

/*
	2.문제 
		int 10'000'000개를 생성하라. 랜덤값으로 채운다. 
		오른차순으로 정렬한다. 
		끝에서 뒷부분 100개만 찍자. 
*/


#include <iostream>
#include <array>
#include <algorithm>
#include <format>
#include <ranges>
#include <random>
#include <format>



#include "save.h"

using namespace std;

array<int, 10'000'000> numbers;
default_random_engine dre;
uniform_int_distribution uid{ 1, 10'000'000 };

int 어떻게( const void * a, const void* b )
{
	return *(int*)a - *(int*)b; // 오름차순 
	//return *(int*)b - *(int*)a; // 내림차순 
}


// -------	
int main()
// -------
{
	for (int& num : numbers) {
		num = uid(dre); 
	}


	int a[100];

	// 오름 차순 정렬 - qsort 와 sort 
	int (*comp)(const void*, const void*) = 어떻게;

	qsort((void*)&numbers, numbers.size(), sizeof(int), /*어떻게 정렬할까?*/어떻게); // Generic 함수  -	아무거나 다 정렬한다. 



	// 뒤에서 부터 100 개 찍기
	for (int num : numbers |
		views::drop(numbers.size() - 100))
	cout << format("{:10}", num);

	cout << endl;
	cout << "qsort 네번째 인자의 타입 " << typeid(어떻게).name() << endl;

		
	save("STL.cpp");

}
#endif // STL



	/*
	
	
	// STL.cpp 에서 한 글자를 읽는다. 
	// 글자가 소문자라면 대문자로 바꾼다. 
	// 글자를 저장한다.
	// 소스 대문자.cpp 글자를 저장한다. 

	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	
		프로그램의 문제점 : islower(c) 체크할 이유가 전혀 없다? 
		touppper 에서 알아서 체크
		삽질 하는 것이다. 
	
	
	// 다른 코드 쓰면 다 0 점 나온다 
	char c;
	in >> noskipws; // 공백을 무시하지 말도록 지시한다. 
	while (in >> c) { // in >> c 때문에 글자만 읽어오라고 시키니 공백을 건너뛰었다. 

		// 'a' ~ 'c'이런식으로
		//if (islower(c))  // 가독성이 좋은 코드다. 
		c = toupper(c);
		out << c;

	}



std:vector<char> vWords = GetWords("STL.cpp");


}
	
*/


===============================================
STL.cpp저장시간 : 2023-03-21 화요일 오후 3:13:41
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 21일 TUE 23 Tue 56 ( 1주 1)
// --------------------------------------------------
//	정렬( sort ) - Callable Type ( 호출가능타입 ) 
// --------------------------------------------------

/*
	2.문제 
		int 10'000'000개를 생성하라. 랜덤값으로 채운다. 
		오른차순으로 정렬한다. 
		끝에서 뒷부분 100개만 찍자. 

		C	: qsort() 
		c++ : sort()

*/


#include <iostream>
#include <array>
#include <algorithm>
#include <format>
#include <ranges>
#include <random>
#include <format>



#include "save.h"

using namespace std;

array<int, 10'000'000> numbers;
default_random_engine dre;
uniform_int_distribution uid{ 1, 10'000'000 };

// C 형식 함수  
int 어떻게( const void * a, const void* b )
{
	return *(int*)a - *(int*)b; // 오름차순 
	//return *(int*)b - *(int*)a; // 내림차순 
}



// -------	
int main()
// -------
{
	for (int& num : numbers) {
		num = uid(dre); 
	}


	int a[100];

	// 오름 차순 정렬 - qsort 와 sort 
	int (*comp)(const void*, const void*) = 어떻게;

	//qsort((void*)&numbers, numbers.size(), sizeof(int), /*어떻게 정렬할까?*/어떻게); // Generic 함수  -	아무거나 다 정렬한다. 
	ranges::sort(numbers); // default 오름차순을 정렬한다. 
		


	// 뒤에서 부터 100 개 찍기
	for (int num : numbers |
		views::drop(numbers.size() - 100))
	cout << format("{:10}", num);

	cout << endl;
	cout << "qsort 네번째 인자의 타입 " << typeid(어떻게).name() << endl;

		
	save("STL.cpp");

}
#endif // STL



	/*
	
	
	// STL.cpp 에서 한 글자를 읽는다. 
	// 글자가 소문자라면 대문자로 바꾼다. 
	// 글자를 저장한다.
	// 소스 대문자.cpp 글자를 저장한다. 

	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	
		프로그램의 문제점 : islower(c) 체크할 이유가 전혀 없다? 
		touppper 에서 알아서 체크
		삽질 하는 것이다. 
	
	
	// 다른 코드 쓰면 다 0 점 나온다 
	char c;
	in >> noskipws; // 공백을 무시하지 말도록 지시한다. 
	while (in >> c) { // in >> c 때문에 글자만 읽어오라고 시키니 공백을 건너뛰었다. 

		// 'a' ~ 'c'이런식으로
		//if (islower(c))  // 가독성이 좋은 코드다. 
		c = toupper(c);
		out << c;

	}



std:vector<char> vWords = GetWords("STL.cpp");


}
	
*/


===============================================
STL.cpp저장시간 : 2023-03-21 화요일 오후 3:16:01
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 21일 TUE 23 Tue 56 ( 1주 1)
// --------------------------------------------------
//	정렬( sort ) - Callable Type ( 호출가능타입 ) 
// --------------------------------------------------

/*
	2.문제 
		int 10'000'000개를 생성하라. 랜덤값으로 채운다. 
		오른차순으로 정렬한다. 
		끝에서 뒷부분 100개만 찍자. 

		C	: qsort() 
		c++ : sort()

*/


#include <iostream>
#include <array>
#include <algorithm>
#include <format>
#include <ranges>
#include <random>
#include <format>



#include "save.h"

using namespace std;

array<int, 10'000'000> numbers;
default_random_engine dre;
uniform_int_distribution uid{ 1, 10'000'000 };

// C 형식 함수  
int 어떻게( const void * a, const void* b )
{
	return *(int*)a - *(int*)b; // 오름차순 
	//return *(int*)b - *(int*)a; // 내림차순 
}


bool 어떻게2(int a, int b)
{
	return a < b; // 오름 차순 
	//return a > b; // 내림 차순
}

// -------	
int main()
// -------
{
	for (int& num : numbers) {
		num = uid(dre); 
	}


	int a[100];

	// 오름 차순 정렬 - qsort 와 sort 
	int (*comp)(const void*, const void*) = 어떻게;

	// C
	//qsort((void*)&numbers, numbers.size(), sizeof(int), /*어떻게 정렬할까?*/어떻게); // Generic 함수  -	아무거나 다 정렬한다. 
	// C++
	//ranges::sort(numbers); // default 오름차순을 정렬한다. 
	sort(numbers.begin(), numbers.end(), 어떻게2);



	// 뒤에서 부터 100 개 찍기
	for (int num : numbers |
		views::drop(numbers.size() - 100))
	cout << format("{:10}", num);

	cout << endl;
	cout << "qsort 네번째 인자의 타입 " << typeid(어떻게).name() << endl;

		
	save("STL.cpp");

}
#endif // STL



	/*
	
	
	// STL.cpp 에서 한 글자를 읽는다. 
	// 글자가 소문자라면 대문자로 바꾼다. 
	// 글자를 저장한다.
	// 소스 대문자.cpp 글자를 저장한다. 

	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	
		프로그램의 문제점 : islower(c) 체크할 이유가 전혀 없다? 
		touppper 에서 알아서 체크
		삽질 하는 것이다. 
	
	
	// 다른 코드 쓰면 다 0 점 나온다 
	char c;
	in >> noskipws; // 공백을 무시하지 말도록 지시한다. 
	while (in >> c) { // in >> c 때문에 글자만 읽어오라고 시키니 공백을 건너뛰었다. 

		// 'a' ~ 'c'이런식으로
		//if (islower(c))  // 가독성이 좋은 코드다. 
		c = toupper(c);
		out << c;

	}



std:vector<char> vWords = GetWords("STL.cpp");


}
	
*/


===============================================
STL.cpp저장시간 : 2023-03-21 화요일 오후 3:19:12
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 21일 TUE 23 Tue 56 ( 1주 1)
// --------------------------------------------------
//	정렬( sort ) - Callable Type ( 호출가능타입 ) 
// --------------------------------------------------

/*
	2.문제 
		int 10'000'000개를 생성하라. 랜덤값으로 채운다. 
		오른차순으로 정렬한다. 
		끝에서 뒷부분 100개만 찍자. 

		C	: qsort() 
		c++ : sort()

*/


#include <iostream>
#include <array>
#include <algorithm>
#include <format>
#include <ranges>
#include <random>
#include <format>



#include "save.h"

using namespace std;

array<int, 10'000'000> numbers;
default_random_engine dre;
uniform_int_distribution uid{ 1, 10'000'000 };

// C 형식 함수  
int 어떻게( const void * a, const void* b )
{
	return *(int*)a - *(int*)b; // 오름차순 
	//return *(int*)b - *(int*)a; // 내림차순 
}


bool 어떻게2(int a, int b)
{
	return a < b; // 오름 차순 
	//return a > b; // 내림 차순
}

class Dog {
private:


public:
	bool operator()(int a, int b) {
		return a < b;
	}

};

// -------	
int main()
// -------
{
	for (int& num : numbers) {
		num = uid(dre); 
	}


	int a[100];

	// 오름 차순 정렬 - qsort 와 sort 
	int (*comp)(const void*, const void*) = 어떻게;

	// C
	//qsort((void*)&numbers, numbers.size(), sizeof(int), /*어떻게 정렬할까?*/어떻게); // Generic 함수  -	아무거나 다 정렬한다. 
	// C++
	//ranges::sort(numbers); // default 오름차순을 정렬한다. 
	sort(numbers.begin(), numbers.end(), 어떻게2);

	sort(numbers.begin(), numbers.end(), Dog() );


	// 뒤에서 부터 100 개 찍기
	for (int num : numbers |
		views::drop(numbers.size() - 100))
	cout << format("{:10}", num);

	cout << endl;
	cout << "qsort 네번째 인자의 타입 " << typeid(어떻게).name() << endl;

		
	save("STL.cpp");

}
#endif // STL



	/*
	
	
	// STL.cpp 에서 한 글자를 읽는다. 
	// 글자가 소문자라면 대문자로 바꾼다. 
	// 글자를 저장한다.
	// 소스 대문자.cpp 글자를 저장한다. 

	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	
		프로그램의 문제점 : islower(c) 체크할 이유가 전혀 없다? 
		touppper 에서 알아서 체크
		삽질 하는 것이다. 
	
	
	// 다른 코드 쓰면 다 0 점 나온다 
	char c;
	in >> noskipws; // 공백을 무시하지 말도록 지시한다. 
	while (in >> c) { // in >> c 때문에 글자만 읽어오라고 시키니 공백을 건너뛰었다. 

		// 'a' ~ 'c'이런식으로
		//if (islower(c))  // 가독성이 좋은 코드다. 
		c = toupper(c);
		out << c;

	}



std:vector<char> vWords = GetWords("STL.cpp");


}
	
*/


===============================================
STL.cpp저장시간 : 2023-03-27 월요일 오전 10:33:44
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 27일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	정렬( sort ) - Callable Type ( 호출가능타입 ) 
// --------------------------------------------------

/*
	2.문제 
		int 10'000'000개를 생성하라. 랜덤값으로 채운다. 
		오른차순으로 정렬한다. 
		끝에서 뒷부분 100개만 찍자. 

		C	: qsort() 
		c++ : sort()

*/


#include <iostream>
#include <array>
#include <algorithm>
#include <format>
#include <ranges>
#include <random>
#include <format>



#include "save.h"

using namespace std;

array<int, 10'000'000> numbers;
default_random_engine dre;
uniform_int_distribution uid{ 1, 10'000'000 };

// C 형식 함수  
int 어떻게( const void * a, const void* b )
{
	return *(int*)a - *(int*)b; // 오름차순 
	//return *(int*)b - *(int*)a; // 내림차순 
}


bool 어떻게2(int a, int b)
{
	return a < b; // 오름 차순 
	//return a > b; // 내림 차순
}

class Dog {
private:


public:
	// sort 함수가 이 함수를 이용해서 정렬 
	bool operator()(int a, int b) {
		return a < b;
	}

};

// -------	
int main()
// -------
{
	for (int& num : numbers) {
		num = uid(dre); 
	}


	int a[100];

	// 오름 차순 정렬 - qsort 와 sort 
	int (*comp)(const void*, const void*) = 어떻게;

	// C
	//qsort((void*)&numbers, numbers.size(), sizeof(int), /*어떻게 정렬할까?*/어떻게); // Generic 함수  -	아무거나 다 정렬한다. 
	// C++
	//ranges::sort(numbers); // default 오름차순을 정렬한다. 
	//sort(numbers.begin(), numbers.end(), 어떻게2);
	
	ranges::sort(numbers, Dog());


	//sort(numbers.begin(), numbers.end(), Dog() );


	// 뒤에서 부터 100 개 찍기
	for (int num : numbers |
		views::drop(numbers.size() - 100))
	cout << format("{:10}", num);

	cout << endl;
	cout << "qsort 네번째 인자의 타입 " << typeid(어떻게).name() << endl;

		
	save("STL.cpp");

}
#endif // STL



	/*
	
	
	// STL.cpp 에서 한 글자를 읽는다. 
	// 글자가 소문자라면 대문자로 바꾼다. 
	// 글자를 저장한다.
	// 소스 대문자.cpp 글자를 저장한다. 

	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	
		프로그램의 문제점 : islower(c) 체크할 이유가 전혀 없다? 
		touppper 에서 알아서 체크
		삽질 하는 것이다. 
	
	
	// 다른 코드 쓰면 다 0 점 나온다 
	char c;
	in >> noskipws; // 공백을 무시하지 말도록 지시한다. 
	while (in >> c) { // in >> c 때문에 글자만 읽어오라고 시키니 공백을 건너뛰었다. 

		// 'a' ~ 'c'이런식으로
		//if (islower(c))  // 가독성이 좋은 코드다. 
		c = toupper(c);
		out << c;

	}



std:vector<char> vWords = GetWords("STL.cpp");


}
	
*/


===============================================
STL.cpp저장시간 : 2023-03-27 월요일 오전 10:39:19
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 27일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	정렬( sort ) - Callable Type ( 호출가능타입 ) 
// --------------------------------------------------

/*
	2.문제 
		int 10'000'000개를 생성하라. 랜덤값으로 채운다. 
		오른차순으로 정렬한다. 
		끝에서 뒷부분 100개만 찍자. 

		C	: qsort() 
		c++ : sort()

*/


#include <iostream>
#include <array>
#include <algorithm>
#include <format>
#include <ranges>
#include <random>
#include <format>



#include "save.h"

using namespace std;

array<int, 10'000'000> numbers;
default_random_engine dre;
uniform_int_distribution uid{ 1, 10'000'000 };

// C 형식 함수  
int 어떻게( const void * a, const void* b )
{
	return *(int*)a - *(int*)b; // 오름차순 
	//return *(int*)b - *(int*)a; // 내림차순 
}


bool 어떻게2(int a, int b)
{
	return a < b; // 오름 차순 
	//return a > b; // 내림 차순
}

class Dog {
private:


public:
	// sort 함수가 이 함수를 이용해서 정렬 
	bool operator()(int a, int b) {
		return a < b;
	}

};

// -------	
int main()
// -------
{
	for (int& num : numbers) {
		num = uid(dre); 
	}


	int a[100];

	// 오름 차순 정렬 - qsort 와 sort 
	int (*comp)(const void*, const void*) = 어떻게;

	// C
	//qsort((void*)&numbers, numbers.size(), sizeof(int), /*어떻게 정렬할까?*/어떻게); // Generic 함수  -	아무거나 다 정렬한다. 
	// C++
	//ranges::sort(numbers); // default 오름차순을 정렬한다. 
	//sort(numbers.begin(), numbers.end(), 어떻게2);
	
	ranges::sort(numbers, Dog());
	//sort(numbers.begin(), numbers.end(), Dog() );
	Dog dog;
	sort(numbers.begin(), numbers.end(), dog);


	// 뒤에서 부터 100 개 찍기
	for (int num : numbers |
		views::drop(numbers.size() - 100))
	cout << format("{:10}", num);

	cout << endl;
	cout << "qsort 네번째 인자의 타입 " << typeid(어떻게).name() << endl;

	cout << sizeof(Dog) << endl;

	save("STL.cpp");

}
#endif // STL



	/*
	
	
	// STL.cpp 에서 한 글자를 읽는다. 
	// 글자가 소문자라면 대문자로 바꾼다. 
	// 글자를 저장한다.
	// 소스 대문자.cpp 글자를 저장한다. 

	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	
		프로그램의 문제점 : islower(c) 체크할 이유가 전혀 없다? 
		touppper 에서 알아서 체크
		삽질 하는 것이다. 
	
	
	// 다른 코드 쓰면 다 0 점 나온다 
	char c;
	in >> noskipws; // 공백을 무시하지 말도록 지시한다. 
	while (in >> c) { // in >> c 때문에 글자만 읽어오라고 시키니 공백을 건너뛰었다. 

		// 'a' ~ 'c'이런식으로
		//if (islower(c))  // 가독성이 좋은 코드다. 
		c = toupper(c);
		out << c;

	}



std:vector<char> vWords = GetWords("STL.cpp");


}
	
*/


===============================================
STL.cpp저장시간 : 2023-03-27 월요일 오전 10:43:38
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 27일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	정렬( sort ) - Callable Type ( 호출가능타입 ) 
// --------------------------------------------------

/*
	2.문제 
		int 10'000'000개를 생성하라. 랜덤값으로 채운다. 
		오른차순으로 정렬한다. 
		끝에서 뒷부분 100개만 찍자. 

		C	: qsort() 
		c++ : sort()

*/


#include <iostream>
#include <array>
#include <algorithm>
#include <format>
#include <ranges>
#include <random>
#include <format>



#include "save.h"

using namespace std;

array<int, 10'000'000> numbers;
default_random_engine dre;
uniform_int_distribution uid{ 1, 10'000'000 };

// C 형식 함수  
int 어떻게( const void * a, const void* b )
{
	return *(int*)a - *(int*)b; // 오름차순 
	//return *(int*)b - *(int*)a; // 내림차순 
}


bool 어떻게2(int a, int b)
{
	return a < b; // 오름 차순 
	//return a > b; // 내림 차순
}

class Dog {
private:


public:
	// sort 함수가 이 함수를 이용해서 정렬 
	bool operator()(int a, int b) {
		return a < b;
	}

};

// -------	
int main()
// -------
{
	Dog dog;
	dog(200, 100); /// 돌아가네 ? 
	
	cout << boolalpha << dog(200, 100) << endl;



	save("STL.cpp");

}
#endif // STL



	/*
	
	
	// STL.cpp 에서 한 글자를 읽는다. 
	// 글자가 소문자라면 대문자로 바꾼다. 
	// 글자를 저장한다.
	// 소스 대문자.cpp 글자를 저장한다. 

	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	
		프로그램의 문제점 : islower(c) 체크할 이유가 전혀 없다? 
		touppper 에서 알아서 체크
		삽질 하는 것이다. 
	
	
	// 다른 코드 쓰면 다 0 점 나온다 
	char c;
	in >> noskipws; // 공백을 무시하지 말도록 지시한다. 
	while (in >> c) { // in >> c 때문에 글자만 읽어오라고 시키니 공백을 건너뛰었다. 

		// 'a' ~ 'c'이런식으로
		//if (islower(c))  // 가독성이 좋은 코드다. 
		c = toupper(c);
		out << c;

	}



std:vector<char> vWords = GetWords("STL.cpp");


}
	
*/


===============================================
STL.cpp저장시간 : 2023-03-27 월요일 오전 10:53:59
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 27일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	정렬( sort ) - Callable Type ( 호출가능타입 ) 
// --------------------------------------------------

/*
	2.문제 
		int 10'000'000개를 생성하라. 랜덤값으로 채운다. 
		오른차순으로 정렬한다. 
		끝에서 뒷부분 100개만 찍자. 

		C	: qsort() 
		c++ : sort()

*/


#include <iostream>
#include <array>
#include <algorithm>
#include <format>
#include <ranges>
#include <random>
#include <format>



#include "save.h"

using namespace std;

array<int, 10'000'000> numbers;
default_random_engine dre;
uniform_int_distribution uid{ 1, 10'000'000 };

// C 형식 함수  
int 어떻게( const void * a, const void* b )
{
	return *(int*)a - *(int*)b; // 오름차순 
	//return *(int*)b - *(int*)a; // 내림차순 
}


bool 어떻게2(int a, int b)
{
	return a < b; // 오름 차순 
	//return a > b; // 내림 차순
}

bool 방법(int a, int b) 
{
	return a > b;
}

class Dog {
private:


public:
	// sort 함수가 이 함수를 이용해서 정렬 
	bool operator()(int a, int b) {
		return a < b;
	}

};

// -------	
int main()
// -------
{
	Dog dog; // dog 라고 하는 객체에ㅔㄱ 함수 처럼 불렀다.

	int n; // 왜 int n 이라고 하니? -> 앞으로 n 이라는 이름으로 연산을 하고 싶다. 
	// 그 이름을 이용해서 작업을 하고 싶다.
	// dog 이름을 줬다. -> dog 라는 이름으로 작업을 하고싶다.
	// sort 함수에서 이름이 필요하지 않다. 
	dog(200, 100); /// 돌아가네 ? 
	

	/// dog(200, 100) -> dog.operator()(200,100) 
	cout << boolalpha << dog(200, 100) << endl;

	//Dog dog;
	sort(numbers.begin(), numbers.end(), dog);
	sort(numbers.begin(), numbers.end(), Dog());
	sort(numbers.begin(), numbers.end(), 방법); // 이렇게 코딩 하지 않는다. 가독성이 매우 별로다 ,
	// 이렇게 코딩하면 전문가가 프로그래밍을 읽어봤을때 

	sort(numbers.begin(), numbers.end(), [](int a, int b) {
		return a > b;
		}); // 다른 함수를 안만들고 기능만 있는 함수 이다. -> 가독성 good  
	// Collable Type 
	/*
		Lambda 
			


	*/


	save("STL.cpp");

}
#endif // STL



	/*
	
	
	// STL.cpp 에서 한 글자를 읽는다. 
	// 글자가 소문자라면 대문자로 바꾼다. 
	// 글자를 저장한다.
	// 소스 대문자.cpp 글자를 저장한다. 

	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	
		프로그램의 문제점 : islower(c) 체크할 이유가 전혀 없다? 
		touppper 에서 알아서 체크
		삽질 하는 것이다. 
	
	
	// 다른 코드 쓰면 다 0 점 나온다 
	char c;
	in >> noskipws; // 공백을 무시하지 말도록 지시한다. 
	while (in >> c) { // in >> c 때문에 글자만 읽어오라고 시키니 공백을 건너뛰었다. 

		// 'a' ~ 'c'이런식으로
		//if (islower(c))  // 가독성이 좋은 코드다. 
		c = toupper(c);
		out << c;

	}



std:vector<char> vWords = GetWords("STL.cpp");


}
	
*/


===============================================
STL.cpp저장시간 : 2023-03-27 월요일 오전 10:58:30
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 27일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	정렬( sort ) - Callable Type ( 호출가능타입 ) 
// --------------------------------------------------

/*
	2.문제 
		int 10'000'000개를 생성하라. 랜덤값으로 채운다. 
		오른차순으로 정렬한다. 
		끝에서 뒷부분 100개만 찍자. 

		C	: qsort() 
		c++ : sort()

*/


#include <iostream>
#include <array>
#include <algorithm>
#include <format>
#include <ranges>
#include <random>
#include <format>



#include "save.h"

using namespace std;

array<int, 10'000'000> numbers;
default_random_engine dre;
uniform_int_distribution uid{ 1, 10'000'000 };

// C 형식 함수  
int 어떻게( const void * a, const void* b )
{
	return *(int*)a - *(int*)b; // 오름차순 
	//return *(int*)b - *(int*)a; // 내림차순 
}


bool 어떻게2(int a, int b)
{
	return a < b; // 오름 차순 
	//return a > b; // 내림 차순
}

bool 방법(int a, int b) 
{
	return a > b;
}

class Dog {
private:


public:
	// sort 함수가 이 함수를 이용해서 정렬 
	bool operator()(int a, int b) {
		return a < b;
	}

};

// -------	
int main()
// -------
{
	Dog dog; // dog 라고 하는 객체에ㅔㄱ 함수 처럼 불렀다.

	int n; // 왜 int n 이라고 하니? -> 앞으로 n 이라는 이름으로 연산을 하고 싶다. 
	// 그 이름을 이용해서 작업을 하고 싶다.
	// dog 이름을 줬다. -> dog 라는 이름으로 작업을 하고싶다.
	// sort 함수에서 이름이 필요하지 않다. 
	dog(200, 100); /// 돌아가네 ? 
	

	/// dog(200, 100) -> dog.operator()(200,100) 
	cout << boolalpha << dog(200, 100) << endl;

	//Dog dog;
	sort(numbers.begin(), numbers.end(), dog);
	sort(numbers.begin(), numbers.end(), Dog());
	sort(numbers.begin(), numbers.end(), 방법); // 이렇게 코딩 하지 않는다. 가독성이 매우 별로다 ,
	// 이렇게 코딩하면 전문가가 프로그래밍을 읽어봤을때 

	sort(numbers.begin(), numbers.end(), [](int a, int b) {
		return a > b;
		}); // 다른 함수를 안만들고 기능만 있는 함수 이다. -> 가독성 good  

	/*
		int n;
		n 의 정체가 뭐야?- > 타입이뭐야

	*/
	
	// Collable Type 
	/*
		Lambda 
			너의 타입은 뭐야 ? typeid(n) sizeof(n) addressof(n)
			typeid(n).name()
			


	*/
	[]() {
		cout << "안녕? 난 람다라고 해!" << endl;
	};

	cout << typeid([]() {
		cout << "안녕? 난 람다라고 해!" << endl;
		}
	).name();


	save("STL.cpp");

}
#endif // STL



	/*
	
	
	// STL.cpp 에서 한 글자를 읽는다. 
	// 글자가 소문자라면 대문자로 바꾼다. 
	// 글자를 저장한다.
	// 소스 대문자.cpp 글자를 저장한다. 

	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	
		프로그램의 문제점 : islower(c) 체크할 이유가 전혀 없다? 
		touppper 에서 알아서 체크
		삽질 하는 것이다. 
	
	
	// 다른 코드 쓰면 다 0 점 나온다 
	char c;
	in >> noskipws; // 공백을 무시하지 말도록 지시한다. 
	while (in >> c) { // in >> c 때문에 글자만 읽어오라고 시키니 공백을 건너뛰었다. 

		// 'a' ~ 'c'이런식으로
		//if (islower(c))  // 가독성이 좋은 코드다. 
		c = toupper(c);
		out << c;

	}



std:vector<char> vWords = GetWords("STL.cpp");


}
	
*/


===============================================
STL.cpp저장시간 : 2023-03-27 월요일 오전 11:02:53
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 27일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	정렬( sort ) - Callable Type ( 호출가능타입 ) 
// --------------------------------------------------

/*
	2.문제 
		int 10'000'000개를 생성하라. 랜덤값으로 채운다. 
		오른차순으로 정렬한다. 
		끝에서 뒷부분 100개만 찍자. 

		C	: qsort() 
		c++ : sort()

*/


#include <iostream>
#include <array>
#include <algorithm>
#include <format>
#include <ranges>
#include <random>
#include <format>



#include "save.h"

using namespace std;

array<int, 10'000'000> numbers;
default_random_engine dre;
uniform_int_distribution uid{ 1, 10'000'000 };

// C 형식 함수  
int 어떻게( const void * a, const void* b )
{
	return *(int*)a - *(int*)b; // 오름차순 
	//return *(int*)b - *(int*)a; // 내림차순 
}


bool 어떻게2(int a, int b)
{
	return a < b; // 오름 차순 
	//return a > b; // 내림 차순
}

bool 방법(int a, int b) 
{
	return a > b;
}

class Dog {
private:


public:
	// sort 함수가 이 함수를 이용해서 정렬 
	bool operator()(int a, int b) {
		return a < b;
	}

};

// -------	
int main()
// -------
{
	Dog dog; // dog 라고 하는 객체에ㅔㄱ 함수 처럼 불렀다.

	int n; // 왜 int n 이라고 하니? -> 앞으로 n 이라는 이름으로 연산을 하고 싶다. 
	// 그 이름을 이용해서 작업을 하고 싶다.
	// dog 이름을 줬다. -> dog 라는 이름으로 작업을 하고싶다.
	// sort 함수에서 이름이 필요하지 않다. 
	dog(200, 100); /// 돌아가네 ? 
	

	/// dog(200, 100) -> dog.operator()(200,100) 
	cout << boolalpha << dog(200, 100) << endl;

	//Dog dog;
	sort(numbers.begin(), numbers.end(), dog);
	sort(numbers.begin(), numbers.end(), Dog());
	sort(numbers.begin(), numbers.end(), 방법); // 이렇게 코딩 하지 않는다. 가독성이 매우 별로다 ,
	// 이렇게 코딩하면 전문가가 프로그래밍을 읽어봤을때 

	sort(numbers.begin(), numbers.end(), [](int a, int b) {
		return a > b;
		}); // 다른 함수를 안만들고 기능만 있는 함수 이다. -> 가독성 good  

	/*
		int n;
		n 의 정체가 뭐야?- > 타입이뭐야

	*/
	
	// Collable Type 
	/*
		Lambda 
			너의 타입은 뭐야 ? typeid(n) sizeof(n) addressof(n)
			typeid(n).name()
			


	*/
	[]() {
		cout << "안녕? 난 람다라고 해!" << endl;
	};

	// 29분 ... 음성듣기 
	cout << typeid([]() {
		cout << "안녕? 난 람다라고 해!" << endl;
		}
	).name();

	// type을 유추한다.
	// 
	auto 람다 = []() {
		cout << "안녕? 난 람다라고 해!" << endl;
	};

	cout << typeid(람다).name() << endl;

	class Dog {};
	//Dog dog;

	cout << typeid(dog).name() << endl;

	// lambda 의 정체는 class 야 ? 


	save("STL.cpp");

}
#endif // STL



	/*
	
	
	// STL.cpp 에서 한 글자를 읽는다. 
	// 글자가 소문자라면 대문자로 바꾼다. 
	// 글자를 저장한다.
	// 소스 대문자.cpp 글자를 저장한다. 

	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	
		프로그램의 문제점 : islower(c) 체크할 이유가 전혀 없다? 
		touppper 에서 알아서 체크
		삽질 하는 것이다. 
	
	
	// 다른 코드 쓰면 다 0 점 나온다 
	char c;
	in >> noskipws; // 공백을 무시하지 말도록 지시한다. 
	while (in >> c) { // in >> c 때문에 글자만 읽어오라고 시키니 공백을 건너뛰었다. 

		// 'a' ~ 'c'이런식으로
		//if (islower(c))  // 가독성이 좋은 코드다. 
		c = toupper(c);
		out << c;

	}



std:vector<char> vWords = GetWords("STL.cpp");


}
	
*/


===============================================
STL.cpp저장시간 : 2023-03-27 월요일 오전 11:03:26
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 27일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	정렬( sort ) - Callable Type ( 호출가능타입 ) 
// --------------------------------------------------

/*
	2.문제 
		int 10'000'000개를 생성하라. 랜덤값으로 채운다. 
		오른차순으로 정렬한다. 
		끝에서 뒷부분 100개만 찍자. 

		C	: qsort() 
		c++ : sort()

*/


#include <iostream>
#include <array>
#include <algorithm>
#include <format>
#include <ranges>
#include <random>
#include <format>



#include "save.h"

using namespace std;

array<int, 10'000'000> numbers;
default_random_engine dre;
uniform_int_distribution uid{ 1, 10'000'000 };

// C 형식 함수  
int 어떻게( const void * a, const void* b )
{
	return *(int*)a - *(int*)b; // 오름차순 
	//return *(int*)b - *(int*)a; // 내림차순 
}


bool 어떻게2(int a, int b)
{
	return a < b; // 오름 차순 
	//return a > b; // 내림 차순
}

bool 방법(int a, int b) 
{
	return a > b;
}

class Dog {
private:


public:
	// sort 함수가 이 함수를 이용해서 정렬 
	bool operator()(int a, int b) {
		return a < b;
	}

};

// -------	
int main()
// -------
{
	Dog dog; // dog 라고 하는 객체에ㅔㄱ 함수 처럼 불렀다.

	int n; // 왜 int n 이라고 하니? -> 앞으로 n 이라는 이름으로 연산을 하고 싶다. 
	// 그 이름을 이용해서 작업을 하고 싶다.
	// dog 이름을 줬다. -> dog 라는 이름으로 작업을 하고싶다.
	// sort 함수에서 이름이 필요하지 않다. 
	dog(200, 100); /// 돌아가네 ? 
	

	/// dog(200, 100) -> dog.operator()(200,100) 
	cout << boolalpha << dog(200, 100) << endl;

	//Dog dog;
	sort(numbers.begin(), numbers.end(), dog);
	sort(numbers.begin(), numbers.end(), Dog());
	sort(numbers.begin(), numbers.end(), 방법); // 이렇게 코딩 하지 않는다. 가독성이 매우 별로다 ,
	// 이렇게 코딩하면 전문가가 프로그래밍을 읽어봤을때 

	sort(numbers.begin(), numbers.end(), [](int a, int b) {
		return a > b;
		}); // 다른 함수를 안만들고 기능만 있는 함수 이다. -> 가독성 good  

	/*
		int n;
		n 의 정체가 뭐야?- > 타입이뭐야

	*/
	
	// Collable Type 
	/*
		Lambda 
			너의 타입은 뭐야 ? typeid(n) sizeof(n) addressof(n)
			typeid(n).name()
			


	*/
	[]() {
		cout << "안녕? 난 람다라고 해!" << endl;
	};

	// 29분 ... 음성듣기 
	cout << typeid([]() {
		cout << "안녕? 난 람다라고 해!" << endl;
		}
	).name();

	// type을 유추한다.
	// 
	auto 람다 = []() {
		cout << "안녕? 난 람다라고 해!" << endl;
	};

	cout << typeid(람다).name() << endl;

	class Dog {};
	//Dog dog;

	cout << typeid(dog).name() << endl;

	// lambda 의 정체는 class 야 ? 
	// class `int __cdecl main(void)'::`2'::<lambda_3>
	// 나는 클래스인데 main()속에서 만들어진 클래스야 

	save("STL.cpp");

}
#endif // STL



	/*
	
	
	// STL.cpp 에서 한 글자를 읽는다. 
	// 글자가 소문자라면 대문자로 바꾼다. 
	// 글자를 저장한다.
	// 소스 대문자.cpp 글자를 저장한다. 

	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	
		프로그램의 문제점 : islower(c) 체크할 이유가 전혀 없다? 
		touppper 에서 알아서 체크
		삽질 하는 것이다. 
	
	
	// 다른 코드 쓰면 다 0 점 나온다 
	char c;
	in >> noskipws; // 공백을 무시하지 말도록 지시한다. 
	while (in >> c) { // in >> c 때문에 글자만 읽어오라고 시키니 공백을 건너뛰었다. 

		// 'a' ~ 'c'이런식으로
		//if (islower(c))  // 가독성이 좋은 코드다. 
		c = toupper(c);
		out << c;

	}



std:vector<char> vWords = GetWords("STL.cpp");


}
	
*/


===============================================
STL.cpp저장시간 : 2023-03-27 월요일 오전 11:04:02
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 27일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	정렬( sort ) - Callable Type ( 호출가능타입 ) 
// --------------------------------------------------

/*
	2.문제 
		int 10'000'000개를 생성하라. 랜덤값으로 채운다. 
		오른차순으로 정렬한다. 
		끝에서 뒷부분 100개만 찍자. 

		C	: qsort() 
		c++ : sort()

*/


#include <iostream>
#include <array>
#include <algorithm>
#include <format>
#include <ranges>
#include <random>
#include <format>



#include "save.h"

using namespace std;

array<int, 10'000'000> numbers;
default_random_engine dre;
uniform_int_distribution uid{ 1, 10'000'000 };

// C 형식 함수  
int 어떻게( const void * a, const void* b )
{
	return *(int*)a - *(int*)b; // 오름차순 
	//return *(int*)b - *(int*)a; // 내림차순 
}


bool 어떻게2(int a, int b)
{
	return a < b; // 오름 차순 
	//return a > b; // 내림 차순
}

bool 방법(int a, int b) 
{
	return a > b;
}

class Dog {
private:


public:
	// sort 함수가 이 함수를 이용해서 정렬 
	bool operator()(int a, int b) {
		return a < b;
	}

};

// -------	
int main()
// -------
{
	//Dog dog; // dog 라고 하는 객체에ㅔㄱ 함수 처럼 불렀다.

	//int n; // 왜 int n 이라고 하니? -> 앞으로 n 이라는 이름으로 연산을 하고 싶다. 
	// 그 이름을 이용해서 작업을 하고 싶다.
	// dog 이름을 줬다. -> dog 라는 이름으로 작업을 하고싶다.
	// sort 함수에서 이름이 필요하지 않다. 
	//dog(200, 100); /// 돌아가네 ? 
	

	/// dog(200, 100) -> dog.operator()(200,100) 
	//cout << boolalpha << dog(200, 100) << endl;

	//Dog dog;
	//sort(numbers.begin(), numbers.end(), dog);
	sort(numbers.begin(), numbers.end(), Dog());
	sort(numbers.begin(), numbers.end(), 방법); // 이렇게 코딩 하지 않는다. 가독성이 매우 별로다 ,
	// 이렇게 코딩하면 전문가가 프로그래밍을 읽어봤을때 

	sort(numbers.begin(), numbers.end(), [](int a, int b) {
		return a > b;
		}); // 다른 함수를 안만들고 기능만 있는 함수 이다. -> 가독성 good  

	/*
		int n;
		n 의 정체가 뭐야?- > 타입이뭐야

	*/
	
	// Collable Type 
	/*
		Lambda 
			너의 타입은 뭐야 ? typeid(n) sizeof(n) addressof(n)
			typeid(n).name()
			


	*/
	[]() {
		cout << "안녕? 난 람다라고 해!" << endl;
	};

	// 29분 ... 음성듣기 
	cout << typeid([]() {
		cout << "안녕? 난 람다라고 해!" << endl;
		}
	).name();

	// type을 유추한다.
	// 
	auto 람다 = []() {
		cout << "안녕? 난 람다라고 해!" << endl;
	};

	cout << typeid(람다).name() << endl;

	class Dog {};
	Dog dog;

	cout << typeid(dog).name() << endl;

	// lambda 의 정체는 class 야 ? 
	// class `int __cdecl main(void)'::`2'::<lambda_3>
	// 나는 클래스인데 main()속에서 만들어진 클래스야 

	save("STL.cpp");

}
#endif // STL



	/*
	
	
	// STL.cpp 에서 한 글자를 읽는다. 
	// 글자가 소문자라면 대문자로 바꾼다. 
	// 글자를 저장한다.
	// 소스 대문자.cpp 글자를 저장한다. 

	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	
		프로그램의 문제점 : islower(c) 체크할 이유가 전혀 없다? 
		touppper 에서 알아서 체크
		삽질 하는 것이다. 
	
	
	// 다른 코드 쓰면 다 0 점 나온다 
	char c;
	in >> noskipws; // 공백을 무시하지 말도록 지시한다. 
	while (in >> c) { // in >> c 때문에 글자만 읽어오라고 시키니 공백을 건너뛰었다. 

		// 'a' ~ 'c'이런식으로
		//if (islower(c))  // 가독성이 좋은 코드다. 
		c = toupper(c);
		out << c;

	}



std:vector<char> vWords = GetWords("STL.cpp");


}
	
*/


===============================================
STL.cpp저장시간 : 2023-03-27 월요일 오전 11:06:28
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 27일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	정렬( sort ) - Callable Type ( 호출가능타입 ) 
// --------------------------------------------------

/*
	2.문제 
		int 10'000'000개를 생성하라. 랜덤값으로 채운다. 
		오른차순으로 정렬한다. 
		끝에서 뒷부분 100개만 찍자. 

		C	: qsort() 
		c++ : sort()

*/


#include <iostream>
#include <array>
#include <algorithm>
#include <format>
#include <ranges>
#include <random>
#include <format>



#include "save.h"

using namespace std;

array<int, 10'000'000> numbers;
default_random_engine dre;
uniform_int_distribution uid{ 1, 10'000'000 };

// C 형식 함수  
int 어떻게( const void * a, const void* b )
{
	return *(int*)a - *(int*)b; // 오름차순 
	//return *(int*)b - *(int*)a; // 내림차순 
}


bool 어떻게2(int a, int b)
{
	return a < b; // 오름 차순 
	//return a > b; // 내림 차순
}

bool 방법(int a, int b) 
{
	return a > b;
}

class Dog {
private:


public:
	// sort 함수가 이 함수를 이용해서 정렬 
	bool operator()(int a, int b) {
		return a < b;
	}

};

auto 람다 = []() {
	cout << "안녕? 난 람다라고 해!" << endl;
};
// -------	
int main()
// -------
{
	//Dog dog; // dog 라고 하는 객체에ㅔㄱ 함수 처럼 불렀다.

	//int n; // 왜 int n 이라고 하니? -> 앞으로 n 이라는 이름으로 연산을 하고 싶다. 
	// 그 이름을 이용해서 작업을 하고 싶다.
	// dog 이름을 줬다. -> dog 라는 이름으로 작업을 하고싶다.
	// sort 함수에서 이름이 필요하지 않다. 
	//dog(200, 100); /// 돌아가네 ? 
	

	/// dog(200, 100) -> dog.operator()(200,100) 
	//cout << boolalpha << dog(200, 100) << endl;

	//Dog dog;
	//sort(numbers.begin(), numbers.end(), dog);
	sort(numbers.begin(), numbers.end(), Dog());
	sort(numbers.begin(), numbers.end(), 방법); // 이렇게 코딩 하지 않는다. 가독성이 매우 별로다 ,
	// 이렇게 코딩하면 전문가가 프로그래밍을 읽어봤을때 

	sort(numbers.begin(), numbers.end(), [](int a, int b) {
		return a > b;
		}); // 다른 함수를 안만들고 기능만 있는 함수 이다. -> 가독성 good  

	/*
		int n;
		n 의 정체가 뭐야?- > 타입이뭐야

	*/
	
	// Collable Type 
	/*
		Lambda 
			너의 타입은 뭐야 ? typeid(n) sizeof(n) addressof(n)
			typeid(n).name()
			


	*/
	[]() {
		cout << "안녕? 난 람다라고 해!" << endl;
	};

	// 29분 ... 음성듣기 
	cout << typeid([]() {
		cout << "안녕? 난 람다라고 해!" << endl;
		}
	).name();

	// type을 유추한다.
	// 


	cout << typeid(람다).name() << endl;

	class Dog {};
	Dog dog;

	cout << typeid(dog).name() << endl;

	// lambda 의 정체는 class 야 ? 
	// class `int __cdecl main(void)'::`2'::<lambda_3>
	// 나는 클래스인데 main()속에서 만들어진 클래스야 
	// class `int __cdecl main(void)'::`2'::Dog

	/*
			함수 이름에 대한 설명
			함수이름은 코드세그먼트의 시작번지를 의J나다.
			
			오버라이딩 해서 똑같은 이름을 써도 컴파일러가 번호 붙여서 자동으로 
			다른 함수로 쓴다.

			Contiguious
			Dangling Pointer 
			Mangling -> 이름을 바꾼다.


	
	
	*/

	save("STL.cpp");

}
#endif // STL



	/*
	
	
	// STL.cpp 에서 한 글자를 읽는다. 
	// 글자가 소문자라면 대문자로 바꾼다. 
	// 글자를 저장한다.
	// 소스 대문자.cpp 글자를 저장한다. 

	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	
		프로그램의 문제점 : islower(c) 체크할 이유가 전혀 없다? 
		touppper 에서 알아서 체크
		삽질 하는 것이다. 
	
	
	// 다른 코드 쓰면 다 0 점 나온다 
	char c;
	in >> noskipws; // 공백을 무시하지 말도록 지시한다. 
	while (in >> c) { // in >> c 때문에 글자만 읽어오라고 시키니 공백을 건너뛰었다. 

		// 'a' ~ 'c'이런식으로
		//if (islower(c))  // 가독성이 좋은 코드다. 
		c = toupper(c);
		out << c;

	}



std:vector<char> vWords = GetWords("STL.cpp");


}
	
*/


===============================================
STL.cpp저장시간 : 2023-03-27 월요일 오전 11:07:34
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 27일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	정렬( sort ) - Callable Type ( 호출가능타입 ) 
// --------------------------------------------------

/*
	2.문제 
		int 10'000'000개를 생성하라. 랜덤값으로 채운다. 
		오른차순으로 정렬한다. 
		끝에서 뒷부분 100개만 찍자. 

		C	: qsort() 
		c++ : sort()

*/


#include <iostream>
#include <array>
#include <algorithm>
#include <format>
#include <ranges>
#include <random>
#include <format>



#include "save.h"

using namespace std;

array<int, 10'000'000> numbers;
default_random_engine dre;
uniform_int_distribution uid{ 1, 10'000'000 };

// C 형식 함수  
int 어떻게( const void * a, const void* b )
{
	return *(int*)a - *(int*)b; // 오름차순 
	//return *(int*)b - *(int*)a; // 내림차순 
}


bool 어떻게2(int a, int b)
{
	return a < b; // 오름 차순 
	//return a > b; // 내림 차순
}

bool 방법(int a, int b) 
{
	return a > b;
}

class Dog {
private:


public:
	// sort 함수가 이 함수를 이용해서 정렬 
	bool operator()(int a, int b) {
		return a < b;
	}

};

auto 람다_g = []() {
	cout << "안녕? 난 람다라고 해!" << endl;
};
// -------	
int main()
// -------
{
	//Dog dog; // dog 라고 하는 객체에ㅔㄱ 함수 처럼 불렀다.

	//int n; // 왜 int n 이라고 하니? -> 앞으로 n 이라는 이름으로 연산을 하고 싶다. 
	// 그 이름을 이용해서 작업을 하고 싶다.
	// dog 이름을 줬다. -> dog 라는 이름으로 작업을 하고싶다.
	// sort 함수에서 이름이 필요하지 않다. 
	//dog(200, 100); /// 돌아가네 ? 
	

	/// dog(200, 100) -> dog.operator()(200,100) 
	//cout << boolalpha << dog(200, 100) << endl;

	//Dog dog;
	//sort(numbers.begin(), numbers.end(), dog);
	sort(numbers.begin(), numbers.end(), Dog());
	sort(numbers.begin(), numbers.end(), 방법); // 이렇게 코딩 하지 않는다. 가독성이 매우 별로다 ,
	// 이렇게 코딩하면 전문가가 프로그래밍을 읽어봤을때 

	sort(numbers.begin(), numbers.end(), [](int a, int b) {
		return a > b;
		}); // 다른 함수를 안만들고 기능만 있는 함수 이다. -> 가독성 good  

	/*
		int n;
		n 의 정체가 뭐야?- > 타입이뭐야

	*/
	
	// Collable Type 
	/*
		Lambda 
			너의 타입은 뭐야 ? typeid(n) sizeof(n) addressof(n)
			typeid(n).name()
			


	*/
	[]() {
		cout << "안녕? 난 람다라고 해!" << endl;
	};

	// 29분 ... 음성듣기 
	cout << typeid([]() {
		cout << "안녕? 난 람다라고 해!" << endl;
		}
	).name();

	// type을 유추한다.
	// 

	// MANGLING 
	cout << typeid(람다_g).name() << endl;

	class Dog {};
	Dog dog;

	cout << typeid(dog).name() << endl;

	// lambda 의 정체는 class 야 ? 
	// class `int __cdecl main(void)'::`2'::<lambda_3>
	// 나는 클래스인데 main()속에서 만들어진 클래스야 
	// class `int __cdecl main(void)'::`2'::Dog

	/*
			함수 이름에 대한 설명
			함수이름은 코드세그먼트의 시작번지를 의J나다.
			
			오버라이딩 해서 똑같은 이름을 써도 컴파일러가 번호 붙여서 자동으로 
			다른 함수로 쓴다.

			Contiguious
			Dangling Pointer 
			Mangling -> 이름을 바꾼다.


	
	
	*/

	[]() {
		cout << "My Lambda" << endl;
	}();


	save("STL.cpp");

}
#endif // STL



	/*
	
	
	// STL.cpp 에서 한 글자를 읽는다. 
	// 글자가 소문자라면 대문자로 바꾼다. 
	// 글자를 저장한다.
	// 소스 대문자.cpp 글자를 저장한다. 

	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	
		프로그램의 문제점 : islower(c) 체크할 이유가 전혀 없다? 
		touppper 에서 알아서 체크
		삽질 하는 것이다. 
	
	
	// 다른 코드 쓰면 다 0 점 나온다 
	char c;
	in >> noskipws; // 공백을 무시하지 말도록 지시한다. 
	while (in >> c) { // in >> c 때문에 글자만 읽어오라고 시키니 공백을 건너뛰었다. 

		// 'a' ~ 'c'이런식으로
		//if (islower(c))  // 가독성이 좋은 코드다. 
		c = toupper(c);
		out << c;

	}



std:vector<char> vWords = GetWords("STL.cpp");


}
	
*/


===============================================
STL.cpp저장시간 : 2023-03-27 월요일 오전 11:11:42
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 27일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	정렬( sort ) - Callable Type ( 호출가능타입 ) 
// --------------------------------------------------

/*
	2.문제 
		int 10'000'000개를 생성하라. 랜덤값으로 채운다. 
		오른차순으로 정렬한다. 
		끝에서 뒷부분 100개만 찍자. 

		C	: qsort() 
		c++ : sort()

*/


#include <iostream>
#include <array>
#include <algorithm>
#include <format>
#include <ranges>
#include <random>
#include <format>



#include "save.h"

using namespace std;

array<int, 10'000'000> numbers;
default_random_engine dre;
uniform_int_distribution uid{ 1, 10'000'000 };

// C 형식 함수  
int 어떻게( const void * a, const void* b )
{
	return *(int*)a - *(int*)b; // 오름차순 
	//return *(int*)b - *(int*)a; // 내림차순 
}


bool 어떻게2(int a, int b)
{
	return a < b; // 오름 차순 
	//return a > b; // 내림 차순
}

bool 방법(int a, int b) 
{
	return a > b;
}

class Dog {
private:


public:
	// sort 함수가 이 함수를 이용해서 정렬 
	bool operator()(int a, int b) {
		return a < b;
	}

};

auto 람다_g = []() {
	cout << "안녕? 난 람다라고 해!" << endl;
};

class 람다람다 {
public:
	// 음성 38분 
	// 람다를 쓰면 이런 쏘스코드를 넣는다.
	// 얘는 메모리에 어떻게 사냐? 
	// 
	void operator()( ) {
		cout << "My Lambda" << endl;
	} 

};
// -------	
int main()
// -------
{
	//Dog dog; // dog 라고 하는 객체에ㅔㄱ 함수 처럼 불렀다.

	//int n; // 왜 int n 이라고 하니? -> 앞으로 n 이라는 이름으로 연산을 하고 싶다. 
	// 그 이름을 이용해서 작업을 하고 싶다.
	// dog 이름을 줬다. -> dog 라는 이름으로 작업을 하고싶다.
	// sort 함수에서 이름이 필요하지 않다. 
	//dog(200, 100); /// 돌아가네 ? 
	

	/// dog(200, 100) -> dog.operator()(200,100) 
	//cout << boolalpha << dog(200, 100) << endl;

	//Dog dog;
	//sort(numbers.begin(), numbers.end(), dog);
	sort(numbers.begin(), numbers.end(), Dog());
	sort(numbers.begin(), numbers.end(), 방법); // 이렇게 코딩 하지 않는다. 가독성이 매우 별로다 ,
	// 이렇게 코딩하면 전문가가 프로그래밍을 읽어봤을때 

	sort(numbers.begin(), numbers.end(), [](int a, int b) {
		return a > b;
		}); // 다른 함수를 안만들고 기능만 있는 함수 이다. -> 가독성 good  

	/*
		int n;
		n 의 정체가 뭐야?- > 타입이뭐야

	*/
	
	// Collable Type 
	/*
		Lambda 
			너의 타입은 뭐야 ? typeid(n) sizeof(n) addressof(n)
			typeid(n).name()
			


	*/
	[]() {
		cout << "안녕? 난 람다라고 해!" << endl;
	};

	// 29분 ... 음성듣기 
	cout << typeid([]() {
		cout << "안녕? 난 람다라고 해!" << endl;
		}
	).name();

	// type을 유추한다.
	// 

	// MANGLING 
	cout << typeid(람다_g).name() << endl;

	class Dog {};
	Dog dog;

	cout << typeid(dog).name() << endl;

	// lambda 의 정체는 class 야 ? 
	// class `int __cdecl main(void)'::`2'::<lambda_3>
	// 나는 클래스인데 main()속에서 만들어진 클래스야 
	// class `int __cdecl main(void)'::`2'::Dog

	/*
			함수 이름에 대한 설명
			함수이름은 코드세그먼트의 시작번지를 의J나다.
			
			오버라이딩 해서 똑같은 이름을 써도 컴파일러가 번호 붙여서 자동으로 
			다른 함수로 쓴다.

			Contiguious
			Dangling Pointer 
			Mangling -> 이름을 바꾼다.


	
	
	*/




	save("STL.cpp");

}
#endif // STL



	/*
	
	
	// STL.cpp 에서 한 글자를 읽는다. 
	// 글자가 소문자라면 대문자로 바꾼다. 
	// 글자를 저장한다.
	// 소스 대문자.cpp 글자를 저장한다. 

	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	
		프로그램의 문제점 : islower(c) 체크할 이유가 전혀 없다? 
		touppper 에서 알아서 체크
		삽질 하는 것이다. 
	
	
	// 다른 코드 쓰면 다 0 점 나온다 
	char c;
	in >> noskipws; // 공백을 무시하지 말도록 지시한다. 
	while (in >> c) { // in >> c 때문에 글자만 읽어오라고 시키니 공백을 건너뛰었다. 

		// 'a' ~ 'c'이런식으로
		//if (islower(c))  // 가독성이 좋은 코드다. 
		c = toupper(c);
		out << c;

	}



std:vector<char> vWords = GetWords("STL.cpp");


}
	
*/


===============================================
STL.cpp저장시간 : 2023-03-27 월요일 오전 11:12:27
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 27일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	정렬( sort ) - Callable Type ( 호출가능타입 ) 
// --------------------------------------------------

/*
	2.문제 
		int 10'000'000개를 생성하라. 랜덤값으로 채운다. 
		오른차순으로 정렬한다. 
		끝에서 뒷부분 100개만 찍자. 

		C	: qsort() 
		c++ : sort()

*/


#include <iostream>
#include <array>
#include <algorithm>
#include <format>
#include <ranges>
#include <random>
#include <format>



#include "save.h"

using namespace std;

array<int, 10'000'000> numbers;
default_random_engine dre;
uniform_int_distribution uid{ 1, 10'000'000 };

// C 형식 함수  
int 어떻게( const void * a, const void* b )
{
	return *(int*)a - *(int*)b; // 오름차순 
	//return *(int*)b - *(int*)a; // 내림차순 
}


bool 어떻게2(int a, int b)
{
	return a < b; // 오름 차순 
	//return a > b; // 내림 차순
}

bool 방법(int a, int b) 
{
	return a > b;
}

class Dog {
private:


public:
	// sort 함수가 이 함수를 이용해서 정렬 
	bool operator()(int a, int b) {
		return a < b;
	}

};

auto 람다_g = []() {
	cout << "안녕? 난 람다라고 해!" << endl;
};

class 람다람다 {
public:
	// 음성 38분 
	// 람다를 쓰면 이런 쏘스코드를 넣는다.
	// 얘는 메모리에 어떻게 사냐? 
	// 
	void operator()( ) {
		cout << "My Lambda" << endl;
	} 

};
// -------	
int main()
// -------
{
	cout << typeid(main).name() << endl;


	save("STL.cpp");

}
#endif // STL



	/*
	
	
	// STL.cpp 에서 한 글자를 읽는다. 
	// 글자가 소문자라면 대문자로 바꾼다. 
	// 글자를 저장한다.
	// 소스 대문자.cpp 글자를 저장한다. 

	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	
		프로그램의 문제점 : islower(c) 체크할 이유가 전혀 없다? 
		touppper 에서 알아서 체크
		삽질 하는 것이다. 
	
	
	// 다른 코드 쓰면 다 0 점 나온다 
	char c;
	in >> noskipws; // 공백을 무시하지 말도록 지시한다. 
	while (in >> c) { // in >> c 때문에 글자만 읽어오라고 시키니 공백을 건너뛰었다. 

		// 'a' ~ 'c'이런식으로
		//if (islower(c))  // 가독성이 좋은 코드다. 
		c = toupper(c);
		out << c;

	}



std:vector<char> vWords = GetWords("STL.cpp");


}
	
*/


===============================================
STL.cpp저장시간 : 2023-03-27 월요일 오전 11:12:52
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 27일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	정렬( sort ) - Callable Type ( 호출가능타입 ) 
// --------------------------------------------------

/*
	2.문제 
		int 10'000'000개를 생성하라. 랜덤값으로 채운다. 
		오른차순으로 정렬한다. 
		끝에서 뒷부분 100개만 찍자. 

		C	: qsort() 
		c++ : sort()

*/


#include <iostream>
#include <array>
#include <algorithm>
#include <format>
#include <ranges>
#include <random>
#include <format>



#include "save.h"

using namespace std;

array<int, 10'000'000> numbers;
default_random_engine dre;
uniform_int_distribution uid{ 1, 10'000'000 };

// C 형식 함수  
int 어떻게( const void * a, const void* b )
{
	return *(int*)a - *(int*)b; // 오름차순 
	//return *(int*)b - *(int*)a; // 내림차순 
}


bool 어떻게2(int a, int b)
{
	return a < b; // 오름 차순 
	//return a > b; // 내림 차순
}

bool 방법(int a, int b) 
{
	return a > b;
}

class Dog {
private:


public:
	// sort 함수가 이 함수를 이용해서 정렬 
	bool operator()(int a, int b) {
		return a < b;
	}

};

auto 람다_g = []() {
	cout << "안녕? 난 람다라고 해!" << endl;
};

class 람다람다 {
public:
	// 음성 38분 
	// 람다를 쓰면 이런 쏘스코드를 넣는다.
	// 얘는 메모리에 어떻게 사냐? 
	// 
	void operator()( ) {
		cout << "My Lambda" << endl;
	} 

};
// -------	
int main(int, int, int)
// -------
{
	cout << typeid(main).name() << endl;


	save("STL.cpp");

}
#endif // STL



	/*
	
	
	// STL.cpp 에서 한 글자를 읽는다. 
	// 글자가 소문자라면 대문자로 바꾼다. 
	// 글자를 저장한다.
	// 소스 대문자.cpp 글자를 저장한다. 

	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	
		프로그램의 문제점 : islower(c) 체크할 이유가 전혀 없다? 
		touppper 에서 알아서 체크
		삽질 하는 것이다. 
	
	
	// 다른 코드 쓰면 다 0 점 나온다 
	char c;
	in >> noskipws; // 공백을 무시하지 말도록 지시한다. 
	while (in >> c) { // in >> c 때문에 글자만 읽어오라고 시키니 공백을 건너뛰었다. 

		// 'a' ~ 'c'이런식으로
		//if (islower(c))  // 가독성이 좋은 코드다. 
		c = toupper(c);
		out << c;

	}



std:vector<char> vWords = GetWords("STL.cpp");


}
	
*/


===============================================
STL.cpp저장시간 : 2023-03-27 월요일 오전 11:24:10
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 27일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	정렬( sort ) - Callable Type ( 호출가능타입 ) 
// --------------------------------------------------

/*
	2.문제 
		int 10'000'000개를 생성하라. 랜덤값으로 채운다. 
		오른차순으로 정렬한다. 
		끝에서 뒷부분 100개만 찍자. 

		C	: qsort() 
		c++ : sort()

*/


#include <iostream>
#include <array>
#include <algorithm>
#include <format>
#include <ranges>
#include <random>
#include <format>



#include "save.h"

using namespace std;

array<int, 10'000'000> numbers;
default_random_engine dre;
uniform_int_distribution uid{ 1, 10'000'000 };

// C 형식 함수  
int 어떻게( const void * a, const void* b )
{
	return *(int*)a - *(int*)b; // 오름차순 
	//return *(int*)b - *(int*)a; // 내림차순 
}


bool 어떻게2(int a, int b)
{
	return a < b; // 오름 차순 
	//return a > b; // 내림 차순
}

bool 방법(int a, int b) 
{
	return a > b;
}

class Dog {
private:


public:
	// sort 함수가 이 함수를 이용해서 정렬 
	bool operator()(int a, int b) {
		return a < b;
	}

};

auto 람다_g = []() {
	cout << "안녕? 난 람다라고 해!" << endl;
};

class 람다람다 {
public:
	// 음성 38분 
	// 람다를 쓰면 이런 쏘스코드를 넣는다.
	// 얘는 메모리에 어떻게 사냐? 
	// 
	void operator()( ) {
		cout << "My Lambda" << endl;
	} 

};

class A{
private:
	int b;
	int a;

};
// -------	
int main()
// -------
{
	int n;
	int x = n; // 어떤 것의 정체를 알았따면 그래 그러면 똑같은 타입의 다른 객체를 만들어줘...
	 

	cout << typeid(main).name() << endl; // return / 인자를 알려준다. 
	/*
		__cdecl

		main 은 int 를 전달하고 인자가 없는 함수야.
	*/
	//int(void) = main; // 함수를 가리키는 포인터 
	/*
		이 세상의 모든 함수는 함수가 시작하는 주소값을 가지는 포인터이다.
		  

	*/

	int(*메인)(void) = main;
	cout << "나는 메인 속에 있다." << endl;
	//메인(); 
	// 조용히 죽는다. 

	cout << sizeof(A) << endl;


	int a[100];

	// Collable 정리
	// 함수 포인터 예제 



	save("STL.cpp");

}
#endif // STL



	/*
	
	
	// STL.cpp 에서 한 글자를 읽는다. 
	// 글자가 소문자라면 대문자로 바꾼다. 
	// 글자를 저장한다.
	// 소스 대문자.cpp 글자를 저장한다. 

	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	
		프로그램의 문제점 : islower(c) 체크할 이유가 전혀 없다? 
		touppper 에서 알아서 체크
		삽질 하는 것이다. 
	
	
	// 다른 코드 쓰면 다 0 점 나온다 
	char c;
	in >> noskipws; // 공백을 무시하지 말도록 지시한다. 
	while (in >> c) { // in >> c 때문에 글자만 읽어오라고 시키니 공백을 건너뛰었다. 

		// 'a' ~ 'c'이런식으로
		//if (islower(c))  // 가독성이 좋은 코드다. 
		c = toupper(c);
		out << c;

	}



std:vector<char> vWords = GetWords("STL.cpp");


}
	
*/


===============================================
STL.cpp저장시간 : 2023-03-27 월요일 오전 11:24:27
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 27일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	정렬( sort ) - Callable Type ( 호출가능타입 ) 
// --------------------------------------------------

/*
	2.문제 
		int 10'000'000개를 생성하라. 랜덤값으로 채운다. 
		오른차순으로 정렬한다. 
		끝에서 뒷부분 100개만 찍자. 

		C	: qsort() 
		c++ : sort()

*/


#include <iostream>
#include <array>
#include <algorithm>
#include <format>
#include <ranges>
#include <random>
#include <format>



#include "save.h"

using namespace std;

array<int, 10'000'000> numbers;
default_random_engine dre;
uniform_int_distribution uid{ 1, 10'000'000 };

// C 형식 함수  
int 어떻게( const void * a, const void* b )
{
	return *(int*)a - *(int*)b; // 오름차순 
	//return *(int*)b - *(int*)a; // 내림차순 
}


bool 어떻게2(int a, int b)
{
	return a < b; // 오름 차순 
	//return a > b; // 내림 차순
}

bool 방법(int a, int b) 
{
	return a > b;
}

class Dog {
private:


public:
	// sort 함수가 이 함수를 이용해서 정렬 
	bool operator()(int a, int b) {
		return a < b;
	}

};

auto 람다_g = []() {
	cout << "안녕? 난 람다라고 해!" << endl;
};

class 람다람다 {
public:
	// 음성 38분 
	// 람다를 쓰면 이런 쏘스코드를 넣는다.
	// 얘는 메모리에 어떻게 사냐? 
	// 
	void operator()( ) {
		cout << "My Lambda" << endl;
	} 

};

class A{
private:
	char b;
	char a;

};
// -------	
int main()
// -------
{
	int n;
	int x = n; // 어떤 것의 정체를 알았따면 그래 그러면 똑같은 타입의 다른 객체를 만들어줘...
	 

	cout << typeid(main).name() << endl; // return / 인자를 알려준다. 
	/*
		__cdecl

		main 은 int 를 전달하고 인자가 없는 함수야.
	*/
	//int(void) = main; // 함수를 가리키는 포인터 
	/*
		이 세상의 모든 함수는 함수가 시작하는 주소값을 가지는 포인터이다.
		  

	*/

	int(*메인)(void) = main;
	cout << "나는 메인 속에 있다." << endl;
	//메인(); 
	// 조용히 죽는다. 

	cout << sizeof(A) << endl;


	int a[100];

	// Collable 정리
	// 함수 포인터 예제 



	save("STL.cpp");

}
#endif // STL



	/*
	
	
	// STL.cpp 에서 한 글자를 읽는다. 
	// 글자가 소문자라면 대문자로 바꾼다. 
	// 글자를 저장한다.
	// 소스 대문자.cpp 글자를 저장한다. 

	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	
		프로그램의 문제점 : islower(c) 체크할 이유가 전혀 없다? 
		touppper 에서 알아서 체크
		삽질 하는 것이다. 
	
	
	// 다른 코드 쓰면 다 0 점 나온다 
	char c;
	in >> noskipws; // 공백을 무시하지 말도록 지시한다. 
	while (in >> c) { // in >> c 때문에 글자만 읽어오라고 시키니 공백을 건너뛰었다. 

		// 'a' ~ 'c'이런식으로
		//if (islower(c))  // 가독성이 좋은 코드다. 
		c = toupper(c);
		out << c;

	}



std:vector<char> vWords = GetWords("STL.cpp");


}
	
*/


===============================================
STL.cpp저장시간 : 2023-03-27 월요일 오전 11:24:40
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 27일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	정렬( sort ) - Callable Type ( 호출가능타입 ) 
// --------------------------------------------------

/*
	2.문제 
		int 10'000'000개를 생성하라. 랜덤값으로 채운다. 
		오른차순으로 정렬한다. 
		끝에서 뒷부분 100개만 찍자. 

		C	: qsort() 
		c++ : sort()

*/


#include <iostream>
#include <array>
#include <algorithm>
#include <format>
#include <ranges>
#include <random>
#include <format>



#include "save.h"

using namespace std;

array<int, 10'000'000> numbers;
default_random_engine dre;
uniform_int_distribution uid{ 1, 10'000'000 };

// C 형식 함수  
int 어떻게( const void * a, const void* b )
{
	return *(int*)a - *(int*)b; // 오름차순 
	//return *(int*)b - *(int*)a; // 내림차순 
}


bool 어떻게2(int a, int b)
{
	return a < b; // 오름 차순 
	//return a > b; // 내림 차순
}

bool 방법(int a, int b) 
{
	return a > b;
}

class Dog {
private:


public:
	// sort 함수가 이 함수를 이용해서 정렬 
	bool operator()(int a, int b) {
		return a < b;
	}

};

auto 람다_g = []() {
	cout << "안녕? 난 람다라고 해!" << endl;
};

class 람다람다 {
public:
	// 음성 38분 
	// 람다를 쓰면 이런 쏘스코드를 넣는다.
	// 얘는 메모리에 어떻게 사냐? 
	// 
	void operator()( ) {
		cout << "My Lambda" << endl;
	} 

};

class A{
private:
	int b;
	char a;

};
// -------	
int main()
// -------
{
	int n;
	int x = n; // 어떤 것의 정체를 알았따면 그래 그러면 똑같은 타입의 다른 객체를 만들어줘...
	 

	cout << typeid(main).name() << endl; // return / 인자를 알려준다. 
	/*
		__cdecl

		main 은 int 를 전달하고 인자가 없는 함수야.
	*/
	//int(void) = main; // 함수를 가리키는 포인터 
	/*
		이 세상의 모든 함수는 함수가 시작하는 주소값을 가지는 포인터이다.
		  

	*/

	int(*메인)(void) = main;
	cout << "나는 메인 속에 있다." << endl;
	//메인(); 
	// 조용히 죽는다. 

	cout << sizeof(A) << endl;


	int a[100];

	// Collable 정리
	// 함수 포인터 예제 



	save("STL.cpp");

}
#endif // STL



	/*
	
	
	// STL.cpp 에서 한 글자를 읽는다. 
	// 글자가 소문자라면 대문자로 바꾼다. 
	// 글자를 저장한다.
	// 소스 대문자.cpp 글자를 저장한다. 

	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	
		프로그램의 문제점 : islower(c) 체크할 이유가 전혀 없다? 
		touppper 에서 알아서 체크
		삽질 하는 것이다. 
	
	
	// 다른 코드 쓰면 다 0 점 나온다 
	char c;
	in >> noskipws; // 공백을 무시하지 말도록 지시한다. 
	while (in >> c) { // in >> c 때문에 글자만 읽어오라고 시키니 공백을 건너뛰었다. 

		// 'a' ~ 'c'이런식으로
		//if (islower(c))  // 가독성이 좋은 코드다. 
		c = toupper(c);
		out << c;

	}



std:vector<char> vWords = GetWords("STL.cpp");


}
	
*/


===============================================
STL.cpp저장시간 : 2023-03-27 월요일 오전 11:27:04
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 27일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	정렬( sort ) - Callable Type ( 호출가능타입 ) 
// --------------------------------------------------

/*
	2.문제 
		int 10'000'000개를 생성하라. 랜덤값으로 채운다. 
		오른차순으로 정렬한다. 
		끝에서 뒷부분 100개만 찍자. 

		C	: qsort() 
		c++ : sort()

*/


#include <iostream>
#include <array>
#include <algorithm>
#include <format>
#include <ranges>
#include <random>
#include <format>



#include "save.h"

using namespace std;

array<int, 10'000'000> numbers;
default_random_engine dre;
uniform_int_distribution uid{ 1, 10'000'000 };

// C 형식 함수  
int 어떻게( const void * a, const void* b )
{
	return *(int*)a - *(int*)b; // 오름차순 
	//return *(int*)b - *(int*)a; // 내림차순 
}


bool 어떻게2(int a, int b)
{
	return a < b; // 오름 차순 
	//return a > b; // 내림 차순
}

bool 방법(int a, int b) 
{
	return a > b;
}

class Dog {
private:


public:
	// sort 함수가 이 함수를 이용해서 정렬 
	bool operator()(int a, int b) {
		return a < b;
	}

};

auto 람다_g = []() {
	cout << "안녕? 난 람다라고 해!" << endl;
};

class 람다람다 {
public:
	// 음성 38분 
	// 람다를 쓰면 이런 쏘스코드를 넣는다.
	// 얘는 메모리에 어떻게 사냐? 
	// 
	void operator()( ) {
		cout << "My Lambda" << endl;
	} 

};

class A{
private:
	char a[3];
	

};
// -------	
int main()
// -------
{
	int n;
	int x = n; // 어떤 것의 정체를 알았따면 그래 그러면 똑같은 타입의 다른 객체를 만들어줘...
	 

	cout << typeid(main).name() << endl; // return / 인자를 알려준다. 
	/*
		__cdecl

		main 은 int 를 전달하고 인자가 없는 함수야.
	*/
	//int(void) = main; // 함수를 가리키는 포인터 
	/*
		이 세상의 모든 함수는 함수가 시작하는 주소값을 가지는 포인터이다.
		  

	*/

	int(*메인)(void) = main;
	cout << "나는 메인 속에 있다." << endl;
	//메인(); 
	// 조용히 죽는다. 

	cout << sizeof(A) << endl;


	int a[100];

	// Collable 정리
	// 함수 포인터 예제 



	save("STL.cpp");

}
#endif // STL



	/*
	
	
	// STL.cpp 에서 한 글자를 읽는다. 
	// 글자가 소문자라면 대문자로 바꾼다. 
	// 글자를 저장한다.
	// 소스 대문자.cpp 글자를 저장한다. 

	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	
		프로그램의 문제점 : islower(c) 체크할 이유가 전혀 없다? 
		touppper 에서 알아서 체크
		삽질 하는 것이다. 
	
	
	// 다른 코드 쓰면 다 0 점 나온다 
	char c;
	in >> noskipws; // 공백을 무시하지 말도록 지시한다. 
	while (in >> c) { // in >> c 때문에 글자만 읽어오라고 시키니 공백을 건너뛰었다. 

		// 'a' ~ 'c'이런식으로
		//if (islower(c))  // 가독성이 좋은 코드다. 
		c = toupper(c);
		out << c;

	}



std:vector<char> vWords = GetWords("STL.cpp");


}
	
*/


===============================================
STL.cpp저장시간 : 2023-03-27 월요일 오전 11:42:03
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 27일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	정렬( sort ) - Callable Type ( 호출가능타입 ) 
// --------------------------------------------------

/*
	Collable Type ( 호출 가능 타입 )
	1. 함수( 함수 포인터 ) 
	2. 함수 객체 ( 함수 호출 연산자() 를 오버로딩한 클래스 
	3. 람다 ( 이름없는 함수 )
	4. 멤버함수 포인터

	Callable Type 전체를 대표하는 클래스가 
	즉 전체를 추상화한 ( 대표하는 ) 클래스 -> function 


*/


#include <iostream>
#include <array>
#include <algorithm>
#include <format>
#include <ranges>
#include <random>
#include <format>
#include <functional> // 인터넷 서칭하기 




#include "save.h"

using namespace std;

array<int, 10'000'000> numbers;
default_random_engine dre;
uniform_int_distribution uid{ 1, 10'000'000 };

// C 형식 함수  
int 어떻게( const void * a, const void* b )
{
	return *(int*)a - *(int*)b; // 오름차순 
	//return *(int*)b - *(int*)a; // 내림차순 
}


bool 어떻게2(int a, int b)
{
	return a < b; // 오름 차순 
	//return a > b; // 내림 차순
}

bool 방법(int a, int b) 
{
	return a > b;
}

class Dog {
private:


public:
	// sort 함수가 이 함수를 이용해서 정렬 
	bool operator()(int a, int b) {
		return a < b;
	}

};

auto 람다_g = []() {
	cout << "안녕? 난 람다라고 해!" << endl;
};

class 람다람다 {
public:
	// 음성 38분 
	// 람다를 쓰면 이런 쏘스코드를 넣는다.
	// 얘는 메모리에 어떻게 사냐? 
	// 
	void operator()( ) {
		cout << "My Lambda" << endl;
	} 

};

// -------	
int main()
// -------
{
	function<int(void)> f = main;

	cout << sizeof(f) << endl;


	save("STL.cpp");

}
#endif // STL



	/*
	
	
	// STL.cpp 에서 한 글자를 읽는다. 
	// 글자가 소문자라면 대문자로 바꾼다. 
	// 글자를 저장한다.
	// 소스 대문자.cpp 글자를 저장한다. 

	std::ifstream in{ "STL.cpp" }; 	// 1. 파일을 읽기 모드로 연다 ( STL.cpp ) 
	if (!in) {
		cout << "파일 열기 실패" << endl;
		return 0;
	}

	std::ofstream out{ "소스대문자.cpp" };	// 2. 소스대문자.cpp를 쓰기모드로 연다.

	
		프로그램의 문제점 : islower(c) 체크할 이유가 전혀 없다? 
		touppper 에서 알아서 체크
		삽질 하는 것이다. 
	
	
	// 다른 코드 쓰면 다 0 점 나온다 
	char c;
	in >> noskipws; // 공백을 무시하지 말도록 지시한다. 
	while (in >> c) { // in >> c 때문에 글자만 읽어오라고 시키니 공백을 건너뛰었다. 

		// 'a' ~ 'c'이런식으로
		//if (islower(c))  // 가독성이 좋은 코드다. 
		c = toupper(c);
		out << c;

	}



std:vector<char> vWords = GetWords("STL.cpp");


}
	
*/


===============================================
STL.cpp저장시간 : 2023-03-27 월요일 오전 11:50:07
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 27일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	정렬( sort ) - Callable Type ( 호출가능타입 ) 
// --------------------------------------------------

/*
	Collable Type ( 호출 가능 타입 )
	1. 함수( 함수 포인터 ) 
	2. 함수 객체 ( 함수 호출 연산자() 를 오버로딩한 클래스 
	3. 람다 ( 이름없는 함수 )
	4. 멤버함수 포인터

	Callable Type 전체를 대표하는 클래스가 
	즉 전체를 추상화한 ( 대표하는 ) 클래스 -> function 
*/
#include <iostream>
#include <functional> // 인터넷 서칭하기 
#include "save.h"
using namespace std;

/*
	[문제] 게임의 버튼에 할당된 기능을 바꾼다. 
	
*/

void jump()
{
	cout << "jump" << endl;
}

void slide()
{
	cout << "slide" << endl;
}



// -------	
int main()
// -------
{
	// Callable Type 이 STL 에서 가장 많이 쓰인다. 기본기다. 
	function<int(void)> f = main;
	cout << sizeof(f) << endl;

	/*
		게임 에서 가장 많이 사용하는 디자인패턴은 
		
		게임패턴 책 1장에서 나오는 내용
	*/

	save("STL.cpp");
	while (true) {
		
		// Key 설명 : a, l 점프/ 슬라이드 , o 옵션 , q 끝내기 
		cout << "키를 누르시오( a, l, o, q )";
		char c;
		cin >> c;

		switch (c)
		{
		case 'a': // 점프 
			jump();

			break;

		case 'l':
			slide();

			break;

		case 'o':
			break;

		case 'q':
			return 0;
			break;
		}




	}


	
}
#endif // STL


===============================================
STL.cpp저장시간 : 2023-03-27 월요일 오전 11:59:12
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 27일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	정렬( sort ) - Callable Type ( 호출가능타입 ) 
// --------------------------------------------------

/*
	Collable Type ( 호출 가능 타입 )
	1. 함수( 함수 포인터 ) 
	2. 함수 객체 ( 함수 호출 연산자() 를 오버로딩한 클래스 
	3. 람다 ( 이름없는 함수 )
	4. 멤버함수 포인터

	Callable Type 전체를 대표하는 클래스가 
	즉 전체를 추상화한 ( 대표하는 ) 클래스 -> function 
*/
#include <iostream>
#include <functional> // 인터넷 서칭하기 
#include "save.h"
using namespace std;

/*
	[문제] 게임의 버튼에 할당된 기능을 바꾼다. 
	
*/

void jump()
{
	cout << "jump" << endl;
}

void slide()
{
	cout << "slide" << endl;
}



// -------	
int main()
// -------
{
	// Callable Type 이 STL 에서 가장 많이 쓰인다. 기본기다. 
	function<int(void)> f = main;
	cout << sizeof(f) << endl;

	/*
		게임 에서 가장 많이 사용하는 디자인패턴은 
		
		게임패턴 책 1장에서 나오는 내용
	*/

	save("STL.cpp");
	
	//function<void(void)> akey = jump; // 왜 안되는지 공부해보자 
	void (*akey) (void) = jump;
	auto lkey = slide; // auto 는 함수 포인터로 난다. function<> 과 차이점이 있다. 
	
	 



	while (true) {
		
		// Key 설명 : a, l 점프/ 슬라이드 , o 옵션 , q 끝내기 
		cout << "키를 누르시오( a, l, o, q )";
		char c;
		cin >> c;

		// hard wired code // 못고치는 코드 : 유연성이 꽝이다...
		// 유연하게 바꾸고 싶으면 방법은 이러하다.
		// 
		switch (c)
		{
		case 'a': // 점프 
			akey();

			break;

		case 'l':
			lkey();

			break;

		case 'o':
			if (akey == jump) { // type 이 같으니 이렇게 쓸 수 있네? 
				akey = slide;
				lkey = jump;
				
			}
			else {
				akey = jump;
				lkey = slide;

			}

			break;

		case 'q':
			return 0;
			break;
		}




	}


	
}
#endif // STL


===============================================
STL.cpp저장시간 : 2023-03-27 월요일 오후 12:08:52
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 27일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	정렬( sort ) - Callable Type ( 호출가능타입 ) 
// --------------------------------------------------

/*
	Collable Type ( 호출 가능 타입 )
	1. 함수( 함수 포인터 ) 
	2. 함수 객체 ( 함수 호출 연산자() 를 오버로딩한 클래스 
	3. 람다 ( 이름없는 함수 )
	4. 멤버함수 포인터

	Callable Type 전체를 대표하는 클래스가 
	즉 전체를 추상화한 ( 대표하는 ) 클래스 -> function 
*/
#include <iostream>
#include <functional> // 인터넷 서칭하기 '
#include <random>
#include <string>
#include <format>

#include "save.h"
using namespace std;

/*
	[문제] class 객체를 정렬한다.

*/

default_random_engine dre;
uniform_int_distribution uidNum{ 0, 10'0000 };
uniform_int_distribution uidLen{ 1, 60 };  
uniform_int_distribution<int> uidName{ 'a', 'z' };






class Dog {

private:
	int num;
	string name;
public:
	Dog() {
		// num : [0, 10'0000], name : [1, 60글자]
		num = uidNum(dre);
		size_t len = uidLen(dre);
		for (size_t i = 0; i < len; ++i) {
			name += uidName(dre);
		}
			

	}


	void show() const {
		cout << format("{:8} - {}", num, name) << endl;
	}


};


// -------	
int main()
// -------
{
	for (int i = 0; i < 10; ++i) {
		Dog().show();

	}


	save("STL.cpp");
}
#endif // STL


===============================================
STL.cpp저장시간 : 2023-03-27 월요일 오후 12:30:37
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 27일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	정렬( sort ) - Callable Type ( 호출가능타입 ) 
// --------------------------------------------------

/*
	Collable Type ( 호출 가능 타입 )
	1. 함수( 함수 포인터 ) 
	2. 함수 객체 ( 함수 호출 연산자() 를 오버로딩한 클래스 
	3. 람다 ( 이름없는 함수 )
	4. 멤버함수 포인터

	Callable Type 전체를 대표하는 클래스가 
	즉 전체를 추상화한 ( 대표하는 ) 클래스 -> function 
*/
#include <iostream>
#include <functional> // 인터넷 서칭하기 '
#include <random>
#include <string>
#include <format>
#include <algorithm>
#include <array>
#include <ranges>

#include "save.h"
using namespace std;


default_random_engine dre;
uniform_int_distribution uidNum{ 0, 10'0000 };
uniform_int_distribution uidLen{ 1, 60 };  
uniform_int_distribution<int> uidName{ 'a', 'z' };






class Dog {

private:
	int num;
	string name;
public:
	Dog() {
		// num : [0, 10'0000], name : [1, 60글자]
		num = uidNum(dre);
		size_t len = uidLen(dre);
		for (size_t i = 0; i < len; ++i) {
			name += uidName(dre);
		}
	}
	~Dog() {};

	void show() const {
		cout << format("{:8} - {}", num, name) << endl;
	}

	bool operator()(int a, int b) {
		return a > b;

	}

};



/*
	[문제] Dog 객체 100 만개를 생성하라.
	num 기준 오름차순으로 정렬하라. 
	앞에서부터 100개만 출력하라. 
*/

// 1. 100'0000 만개 생성
array<Dog, 100'0000> dogs;



// -------	
int main()
// -------
{
	//for (int i = 0; i < 10; ++i) {
	//	Dog().show();
	//}

	// 2. num 기준 오름차순 정렬   
	/*sort(dogs.begin(), dogs.end(), [](int a, int b) {
		return a > b;
		});*/


	for (int i = 0; i < 100; ++i) {
		dogs[i].show();
	}


	// Dog 천만마리를 만들어서 이름순으로 정렬해봐라... 라는 문제 나옴 
	// 이름에 ap[ple 있는 거 찾아봐라 라는 문제나옴 
	


	save("STL.cpp");
}
#endif // STL


===============================================
STL.cpp저장시간 : 2023-03-27 월요일 오후 12:33:05
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 27일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	정렬( sort ) - Callable Type ( 호출가능타입 ) 
// --------------------------------------------------

/*
	Collable Type ( 호출 가능 타입 )
	1. 함수( 함수 포인터 ) 
	2. 함수 객체 ( 함수 호출 연산자() 를 오버로딩한 클래스 
	3. 람다 ( 이름없는 함수 )
	4. 멤버함수 포인터

	Callable Type 전체를 대표하는 클래스가 
	즉 전체를 추상화한 ( 대표하는 ) 클래스 -> function 
*/
#include <iostream>
#include <functional> // 인터넷 서칭하기 '
#include <random>
#include <string>
#include <format>
#include <algorithm>
#include <array>
#include <ranges>

#include "save.h"
using namespace std;


default_random_engine dre;
uniform_int_distribution uidNum{ 0, 10'0000 };
uniform_int_distribution uidLen{ 1, 60 };  
uniform_int_distribution<int> uidName{ 'a', 'z' };






class Dog {

private:
	int num;
	string name;
public:
	Dog() {
		// num : [0, 10'0000], name : [1, 60글자]
		num = uidNum(dre);
		size_t len = uidLen(dre);
		for (size_t i = 0; i < len; ++i) {
			name += uidName(dre);
		}
	}
	~Dog() {};

	void show() const {
		cout << format("{:8} - {}", num, name) << endl;
	}

	bool operator()(Dog a, Dog b) {
		return a.num > b.num;

	}

};



/*
	[문제] Dog 객체 100 만개를 생성하라.
	num 기준 오름차순으로 정렬하라. 
	앞에서부터 100개만 출력하라. 
*/

// 1. 100'0000 만개 생성
array<Dog, 100'0000> dogs;



// -------	
int main()
// -------
{
	//for (int i = 0; i < 10; ++i) {
	//	Dog().show();
	//}

	// 2. num 기준 오름차순 정렬   
	sort(dogs.begin(), dogs.end(), Dog());



	for (int i = 0; i < 100; ++i) {
		dogs[i].show();
	}


	// Dog 천만마리를 만들어서 이름순으로 정렬해봐라... 라는 문제 나옴 
	// 이름에 ap[ple 있는 거 찾아봐라 라는 문제나옴 
	


	save("STL.cpp");
}
#endif // STL


===============================================
STL.cpp저장시간 : 2023-03-28 화요일 오후 1:37:53
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 28일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	정렬( sort ) - Callable Type ( 호출가능타입 ) 
// --------------------------------------------------

/*
	Collable Type ( 호출 가능 타입 )
	1. 함수( 함수 포인터 ) 
	2. 함수 객체 ( 함수 호출 연산자() 를 오버로딩한 클래스 
	3. 람다 ( 이름없는 함수 )
	4. 멤버함수 포인터

	Callable Type 전체를 대표하는 클래스가 
	즉 전체를 추상화한 ( 대표하는 ) 클래스 -> function 
*/
#include <iostream>
#include <functional> // 인터넷 서칭하기 '
#include <random>
#include <string>
#include <format>
#include <algorithm>
#include <array>
#include <ranges>

#include "save.h"
using namespace std;


default_random_engine dre;
uniform_int_distribution uidNum{ 0, 10'0000 };
uniform_int_distribution uidLen{ 1, 60 };  
uniform_int_distribution<int> uidName{ 'a', 'z' };

class Dog {

private:
	int num;
	string name;
public:
	Dog() {
		// num : [0, 10'0000], name : [1, 60글자]
		num = uidNum(dre);
		size_t len = uidLen(dre);
		for (size_t i = 0; i < len; ++i) {
			name += uidName(dre);
		}
	}
	~Dog() {};

	void show() const {
		cout << format("{:8} - {}", num, name) << endl;
	}

	bool operator()(Dog a, Dog b) {
		return a.num > b.num;
	}

};



/*
	[문제] Dog 객체 100 만개를 생성하라.
	num 기준 오름차순으로 정렬하라. 
	앞에서부터 100개만 출력하라. 
*/

// 1. 100'0000 만개 생성
array<Dog, 100'0000> dogs;



// -------	
int main()
// -------
{
	cout << sizeof(Dog) << endl;

	// 2. num 기준 오름차순 정렬   
	sort(dogs.begin(), dogs.end(), Dog());

	for (int i = 0; i < 100; ++i) {
		dogs[i].show();
	}

	// Dog 천만마리를 만들어서 이름순으로 정렬해봐라... 라는 문제 나옴 
	// 이름에 ap[ple 있는 거 찾아봐라 라는 문제나옴 
	save("STL.cpp");
}
#endif // STL


===============================================
STL.cpp저장시간 : 2023-03-28 화요일 오후 1:44:22
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 28일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	정렬( sort ) - Callable Type ( 호출가능타입 ) 
// --------------------------------------------------

/*
	Collable Type ( 호출 가능 타입 )
	1. 함수( 함수 포인터 ) 
	2. 함수 객체 ( 함수 호출 연산자() 를 오버로딩한 클래스 
	3. 람다 ( 이름없는 함수 )
	4. 멤버함수 포인터

	Callable Type 전체를 대표하는 클래스가 
	즉 전체를 추상화한 ( 대표하는 ) 클래스 -> function 
*/
#include <iostream>
#include <functional> // 인터넷 서칭하기 '
#include <random>
#include <string>
#include <format>
#include <algorithm>
#include <array>
#include <ranges>

#include "save.h"
using namespace std;


default_random_engine dre;
uniform_int_distribution uidNum{ 0, 10'0000 };
uniform_int_distribution uidLen{ 1, 60 };  
uniform_int_distribution<int> uidName{ 'a', 'z' };

class Dog {

private:
	int num;
	string name;
public:
	Dog() {
		// num : [0, 10'0000], name : [1, 60글자]
		num = uidNum(dre);
		size_t len = uidLen(dre);
		for (size_t i = 0; i < len; ++i) {
			name += uidName(dre);
		}
	}
	~Dog() {};

	int getNum() const{
		return num;
	}

	void show() const {
		cout << format("{:8} - {}", num, name) << endl;
	}

	bool operator()(Dog a, Dog b) {
		return a.num > b.num;
	}

};



/*
	[문제] Dog 객체 100 만개를 생성하라.
	num 기준 오름차순으로 정렬하라. 
	앞에서부터 100개만 출력하라. 
*/

// 1. 100'0000 만개 생성
array<Dog, 100'0000> dogs; // default 생성자가 100'0000번 불린다. 




// -------	
int main()
// -------
{
	cout << sizeof(Dog) << endl;

	// 2. num 기준 오름차순 정렬   
	//sort(dogs.begin(), dogs.end(), Dog()); // 내 코드 
	
	sort(dogs.begin(), dogs.end(), [](const Dog& a,const Dog& b) { // 레퍼런스로 붙여서 40 바이트에서 8바이트로, 읽기만 할 것으로 const 
		return a.getNum() < b.getNum();
		}); // 교수님 코드 



	for (int i = 0; i < 100; ++i) {
		dogs[i].show();
	}

	// Dog 천만마리를 만들어서 이름순으로 정렬해봐라... 라는 문제 나옴 
	// 이름에 ap[ple 있는 거 찾아봐라 라는 문제나옴 
	save("STL.cpp");
}
#endif // STL


===============================================
STL.cpp저장시간 : 2023-03-28 화요일 오후 1:49:30
===============================================


#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 28일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------


#include <iostream>
#include "save.h"
using namespace std;

// -------	
int main()
// -------
{
	string a{ "123asdfasdasdf" };
	cout << sizeof(a) << endl;
	cout << a << endl;


	save("STL.cpp");

}
#endif // STL


===============================================
STL.cpp저장시간 : 2023-03-28 화요일 오후 2:09:25
===============================================

#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 28일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------


#include <iostream>
#include "save.h"
using namespace std;

class String {
private:
	size_t len{};
	char* p{}; // default nullptr 이다.  // unique_ptr<char> p 로 바꿔서 코딩하여 살려볼것 
	

public:
	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}

	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);


	}
};

// -------	
int main()
// -------
{


	//string a{ "123asdfasdasdf" };
	String a{"123"};

	cout << sizeof(a) << endl;
	cout << a << endl;

	save("STL.cpp");


}

#endif // STL


===============================================
STL.cpp저장시간 : 2023-03-28 화요일 오후 2:21:39
===============================================

#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 28일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------


#include <iostream>
#include "save.h"
using namespace std;

class String {
private:
	size_t len{};
	char* p{}; // default nullptr 이다.  // unique_ptr<char> p 로 바꿔서 코딩하여 살려볼것 


public:
	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		delete[] p;
	}
	String() {

	}

	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		// 꼭 delete 써야힘 
	}

	friend String operator+(String& _str1, String& _str2) {
		int len = _str1.len + _str2.len;
		char* NewP = new char[len];

		String str{};

		/*for (int i = 0; i < _str1.len; ++i) {
			str.p[i] = _str1.p[i];
		}
		for (int i = _str1.len; i < _str1.len + _str2.len; ++i) {
			str.p[i] = _str2.p[i];
		}*/

		return str;
		
	}


};


// -------	
int main()
// -------
{


	//string a{ "123asdfasdasdf" };
	String a{ "123" };
	String b{ "4567890" };
	String c = a + b;


	cout << c << endl;
	cout << sizeof(a) << endl;
	cout << a << endl;

	save("STL.cpp");


}

#endif // STL
/*
#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 28일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다.
// --------------------------------------------------


#include <iostream>
#include "save.h"
using namespace std;

class String {
private:
	size_t len{};
	char* p{}; // default nullptr 이다.  // unique_ptr<char> p 로 바꿔서 코딩하여 살려볼것


public:
	// 100 점만점중에 10 점도 안되는 코드이다. 잘못된 코드....
	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}

	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름
		memcpy(p, s, len);


	}
};

// -------
int main()
// -------
{


	//string a{ "123asdfasdasdf" };
	String a{"123"};

	cout << sizeof(a) << endl;
	cout << a << endl;

	save("STL.cpp");


}

#endif // STL

*/



===============================================
STL.cpp저장시간 : 2023-03-28 화요일 오후 2:53:18
===============================================

#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 28일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

/*
	[문제] String 을 코딩하라
	모든 Special 함수에 관찰 메시지를 추가하라. 
	생성시 객체에 고유 번호를부여히라. 
*/

#include <iostream>
#include "save.h"
using namespace std;

bool 관찰{ false };


class String {
private:
	size_t len{};
	char* p{}; // default nullptr 이다.  // unique_ptr<char> p 로 바꿔서 코딩하여 살려볼것 
	size_t id = ++sid;	// 객체 고유번호 
	
	static size_t sid;

public:
	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}
	//String() = default;
	String() {
		print("디폴트 생성");
	}
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자"); 
		delete[] p;
	}
	
	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");

		// 꼭 delete 써야힘 
	}

	/*friend String& operator+(const String& _str1, const String& _str2) {
		int len = _str1.len + _str2.len;
		char* p = new char[len];
		for (int i = 0; i < _str1.len; ++i) {
			p[i] = _str1.p[i];
		}
		for (int i = _str1.len; i < len; ++i) {
			p[i] = _str2.p[i];
		}
	
		String str{p};
		delete[]p;
		return str;
		
	}*/

 
	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}

	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	관찰 = true;

	String a{ "123" };
	String b{ "4567890" };
	String c = a + b;
\
	save("STL.cpp");

}

#endif // STL
/*
#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 28일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다.
// --------------------------------------------------


#include <iostream>
#include "save.h"
using namespace std;

class String {
private:
	size_t len{};
	char* p{}; // default nullptr 이다.  // unique_ptr<char> p 로 바꿔서 코딩하여 살려볼것


public:
	// 100 점만점중에 10 점도 안되는 코드이다. 잘못된 코드....
	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}

	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름
		memcpy(p, s, len);


	}
};

// -------
int main()
// -------
{


	//string a{ "123asdfasdasdf" };
	String a{"123"};

	cout << sizeof(a) << endl;
	cout << a << endl;

	save("STL.cpp");


}

#endif // STL

*/



===============================================
STL.cpp저장시간 : 2023-03-28 화요일 오후 3:04:04
===============================================

#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 28일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

/*
	[문제] String 을 코딩하라
	모든 Special 함수에 관찰 메시지를 추가하라. 
	생성시 객체에 고유 번호를부여히라. 
*/

#include <iostream>
#include "save.h"
using namespace std;

bool 관찰{ false };


class String {
private:
	size_t len{};
	char* p{}; // default nullptr 이다.  // unique_ptr<char> p 로 바꿔서 코딩하여 살려볼것 
	size_t id = ++sid;	// 객체 고유번호 
	
	static size_t sid;

public:
	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}
	//String() = default;
	String() {
		print("디폴트 생성");
	}
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자"); 
		delete[] p;
	}

	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사생성자를 코딩했다면 복사할당 연산자도 반드시 코딩해야 한다.???
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}

	
	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");

		// 꼭 delete 써야힘 
	}

	/*friend String& operator+(const String& _str1, const String& _str2) {
		int len = _str1.len + _str2.len;
		char* p = new char[len];
		for (int i = 0; i < _str1.len; ++i) {
			p[i] = _str1.p[i];
		}
		for (int i = _str1.len; i < len; ++i) {
			p[i] = _str2.p[i];
		}
	
		String str{p};
		delete[]p;
		return str;
		
	}*/

 
	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}

	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	관찰 = true;

	String a{ "123" };
	String b{ "4567890" };
	String c = a + b;
\
	save("STL.cpp");

}

#endif // STL
/*
#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 28일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다.
// --------------------------------------------------


#include <iostream>
#include "save.h"
using namespace std;

class String {
private:
	size_t len{};
	char* p{}; // default nullptr 이다.  // unique_ptr<char> p 로 바꿔서 코딩하여 살려볼것


public:
	// 100 점만점중에 10 점도 안되는 코드이다. 잘못된 코드....
	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}

	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름
		memcpy(p, s, len);


	}
};

// -------
int main()
// -------
{


	//string a{ "123asdfasdasdf" };
	String a{"123"};

	cout << sizeof(a) << endl;
	cout << a << endl;

	save("STL.cpp");


}

#endif // STL

*/



===============================================
STL.cpp저장시간 : 2023-03-28 화요일 오후 3:06:23
===============================================

#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 28일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

/*
	[문제] String 을 코딩하라
	모든 Special 함수에 관찰 메시지를 추가하라. 
	생성시 객체에 고유 번호를부여히라. 
*/

#include <iostream>
#include "save.h"
using namespace std;

bool 관찰{ false };


class String {
private:
	size_t len{};
	char* p{}; // default nullptr 이다.  // unique_ptr<char> p 로 바꿔서 코딩하여 살려볼것 
	size_t id = ++sid;	// 객체 고유번호 
	
	static size_t sid;

public:
	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}
	//String() = default;
	String() {
		print("디폴트 생성");
	}
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자"); 
		delete[] p;
	}

	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사생성자를 코딩했다면 복사할당 연산자도 반드시 코딩해야 한다.???
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}

	
	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");

		// 꼭 delete 써야힘 
	}

	/*friend String& operator+(const String& _str1, const String& _str2) {
		int len = _str1.len + _str2.len;
		char* p = new char[len];
		for (int i = 0; i < _str1.len; ++i) {
			p[i] = _str1.p[i];
		}
		for (int i = _str1.len; i < len; ++i) {
			p[i] = _str2.p[i];
		}
	
		String str{p};
		delete[]p;
		return str;
		
	}*/

 
	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}

	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	관찰 = true;

	String a{ "123" };
	String b{ "4567890" };
	String c;
	c = a + b;

	save("STL.cpp");

}

#endif // STL
/*
#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 28일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다.
// --------------------------------------------------


#include <iostream>
#include "save.h"
using namespace std;

class String {
private:
	size_t len{};
	char* p{}; // default nullptr 이다.  // unique_ptr<char> p 로 바꿔서 코딩하여 살려볼것


public:
	// 100 점만점중에 10 점도 안되는 코드이다. 잘못된 코드....
	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}

	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름
		memcpy(p, s, len);


	}
};

// -------
int main()
// -------
{


	//string a{ "123asdfasdasdf" };
	String a{"123"};

	cout << sizeof(a) << endl;
	cout << a << endl;

	save("STL.cpp");


}

#endif // STL

*/



===============================================
STL.cpp저장시간 : 2023-03-28 화요일 오후 3:10:25
===============================================

#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 28일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};
	char* p{}; // default nullptr 이다.  // unique_ptr<char> p 로 바꿔서 코딩하여 살려볼것 
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;

public:
	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}
	//String() = default;
	String() {
		print("디폴트 생성");
	}
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사생성자를 코딩했다면 복사할당 연산자도 반드시 코딩해야 한다.???
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}


	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");

		// 꼭 delete 써야힘 
	}

	/*friend String& operator+(const String& _str1, const String& _str2) {
		int len = _str1.len + _str2.len;
		char* p = new char[len];
		for (int i = 0; i < _str1.len; ++i) {
			p[i] = _str1.p[i];
		}
		for (int i = _str1.len; i < len; ++i) {
			p[i] = _str2.p[i];
		}

		String str{p};
		delete[]p;
		return str;

	}*/


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}

	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	array<String, 5> news{
		"유재석이", "목숨", "걸어가지고", "만든", "걸그룹.."
	};

	for (String s : news) {
		cout << s << endl;

	}


	save("STL.cpp");

}

#endif // STL



===============================================
STL.cpp저장시간 : 2023-03-28 화요일 오후 3:10:46
===============================================

#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 28일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};
	char* p{}; // default nullptr 이다.  // unique_ptr<char> p 로 바꿔서 코딩하여 살려볼것 
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;

public:
	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}
	//String() = default;
	String() {
		print("디폴트 생성");
	}
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사생성자를 코딩했다면 복사할당 연산자도 반드시 코딩해야 한다.???
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}


	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");

		// 꼭 delete 써야힘 
	}

	/*friend String& operator+(const String& _str1, const String& _str2) {
		int len = _str1.len + _str2.len;
		char* p = new char[len];
		for (int i = 0; i < _str1.len; ++i) {
			p[i] = _str1.p[i];
		}
		for (int i = _str1.len; i < len; ++i) {
			p[i] = _str2.p[i];
		}

		String str{p};
		delete[]p;
		return str;

	}*/


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}

	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	관찰 = true;

	array<String, 5> news{
		"유재석이", "목숨", "걸어가지고", "만든", "걸그룹.."
	};

	for (String s : news) {
		cout << s << endl;

	}


	save("STL.cpp");

}

#endif // STL



===============================================
STL.cpp저장시간 : 2023-03-28 화요일 오후 3:11:34
===============================================

#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 28일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};
	char* p{}; // default nullptr 이다.  // unique_ptr<char> p 로 바꿔서 코딩하여 살려볼것 
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;

public:
	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}
	//String() = default;
	String() {
		print("디폴트 생성");
	}
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사생성자를 코딩했다면 복사할당 연산자도 반드시 코딩해야 한다.???
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}


	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");

		// 꼭 delete 써야힘 
	}

	/*friend String& operator+(const String& _str1, const String& _str2) {
		int len = _str1.len + _str2.len;
		char* p = new char[len];
		for (int i = 0; i < _str1.len; ++i) {
			p[i] = _str1.p[i];
		}
		for (int i = _str1.len; i < len; ++i) {
			p[i] = _str2.p[i];
		}

		String str{p};
		delete[]p;
		return str;

	}*/


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}

	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{

	array<String, 5> news{
		"유재석이", "목숨", "걸어가지고", "만든", "걸그룹.."
	};

	관찰 = true;

	for (String s : news) {
		cout << s << endl;

	}
	관찰 = false;


	save("STL.cpp");

}

#endif // STL



===============================================
STL.cpp저장시간 : 2023-03-28 화요일 오후 3:17:50
===============================================

#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 28일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include <string>

#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};
	char* p{}; // default nullptr 이다.  // unique_ptr<char> p 로 바꿔서 코딩하여 살려볼것 
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;

public:
	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}
	//String() = default;
	String() {
		print("디폴트 생성");
	}
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사생성자를 코딩했다면 복사할당 연산자도 반드시 코딩해야 한다.???
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}


	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");

		// 꼭 delete 써야힘 
	}

	/*friend String& operator+(const String& _str1, const String& _str2) {
		int len = _str1.len + _str2.len;
		char* p = new char[len];
		for (int i = 0; i < _str1.len; ++i) {
			p[i] = _str1.p[i];
		}
		for (int i = _str1.len; i < len; ++i) {
			p[i] = _str2.p[i];
		}

		String str{p};
		delete[]p;
		return str;

	}*/


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}


	string getString() const {
		return string(p, len);
	}

	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{

	array<String, 5> news{
		"유재석이", "목숨", "걸어가지고", "만든", "걸그룹.."
	};

	관찰 = true;

	// 이렇게 자면 복사되니까 쓸데없는짓을 많이한다...
	for (String s : news) {
		cout << s << endl;

	}
	// & 를 써야한다. 
	for (String& s : news) {
		cout << s << endl;

	}

	sort(news.begin(), news.end(), [](String a, String b) {
		return a.getString() < b.getString(); // 오름차순 
		});


	관찰 = false;


	save("STL.cpp");

}

#endif // STL



===============================================
STL.cpp저장시간 : 2023-03-28 화요일 오후 3:18:33
===============================================

#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 28일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include <string>

#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};
	char* p{}; // default nullptr 이다.  // unique_ptr<char> p 로 바꿔서 코딩하여 살려볼것 
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;

public:
	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}
	//String() = default;
	String() {
		print("디폴트 생성");
	}
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사생성자를 코딩했다면 복사할당 연산자도 반드시 코딩해야 한다.???
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}


	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");

		// 꼭 delete 써야힘 
	}

	/*friend String& operator+(const String& _str1, const String& _str2) {
		int len = _str1.len + _str2.len;
		char* p = new char[len];
		for (int i = 0; i < _str1.len; ++i) {
			p[i] = _str1.p[i];
		}
		for (int i = _str1.len; i < len; ++i) {
			p[i] = _str2.p[i];
		}

		String str{p};
		delete[]p;
		return str;

	}*/


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}


	string getString() const {
		return string(p, len);
	}

	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{

	array<String, 5> news{
		"유재석이", "목숨", "걸어가지고", "만든", "걸그룹.."
	};

	관찰 = true;

	// 이렇게 자면 복사되니까 쓸데없는짓을 많이한다...
	for (String s : news) {
		cout << s << endl;

	}
	// & 를 써야한다. 
	for (String& s : news) {
		cout << s << endl;

	}

	// 꼭 레퍼런스를 넣자 .... 복사 소멸 엄청함 
	sort(news.begin(), news.end(), [](String& a, String& b) {
		return a.getString() < b.getString(); // 오름차순 
		});


	관찰 = false;


	save("STL.cpp");

}

#endif // STL



===============================================
STL.cpp저장시간 : 2023-03-28 화요일 오후 3:19:27
===============================================

#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 3월 28일 TUE 23 Tue 56 ( 4주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include <string>

#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};
	char* p{}; // default nullptr 이다.  // unique_ptr<char> p 로 바꿔서 코딩하여 살려볼것 
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;

public:
	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}
	//String() = default;
	String() {
		print("디폴트 생성");
	}
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사생성자를 코딩했다면 복사할당 연산자도 반드시 코딩해야 한다.???
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}


	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");

		// 꼭 delete 써야힘 
	}

	/*friend String& operator+(const String& _str1, const String& _str2) {
		int len = _str1.len + _str2.len;
		char* p = new char[len];
		for (int i = 0; i < _str1.len; ++i) {
			p[i] = _str1.p[i];
		}
		for (int i = _str1.len; i < len; ++i) {
			p[i] = _str2.p[i];
		}

		String str{p};
		delete[]p;
		return str;

	}*/


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}


	string getString() const {
		return string(p, len);
	}

	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	/*
	
		** 그림 그리면서 복습해보기 ** 
		
		
	*/

	array<String, 5> news{
		"유재석이", "목숨", "걸어가지고", "만든", "걸그룹.."
	};

	관찰 = true;

	// 이렇게 자면 복사되니까 쓸데없는짓을 많이한다...
	for (String s : news) {
		cout << s << endl;

	}
	// & 를 써야한다. 
	for (String& s : news) {
		cout << s << endl;

	}

	// 꼭 레퍼런스를 넣자 .... 복사 소멸 엄청함 
	sort(news.begin(), news.end(), [](const String& a,const String& b) {
		return a.getString() < b.getString(); // 오름차순 
		});


	관찰 = false;


	save("STL.cpp");

}

#endif // STL



===============================================
STL.cpp저장시간 : 2023-04-25 화요일 오전 8:36:49
===============================================

//#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 4월 03일 TUE 23 Tue 56 ( 5주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include <string>

#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};
	char* p{}; // default nullptr 이다.  // unique_ptr<char> p 로 바꿔서 코딩하여 살려볼것 
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;

public:
	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}
	//String() = default;
	String() {
		print("디폴트 생성");
	}
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사생성자를 코딩했다면 복사할당 연산자도 반드시 코딩해야 한다.???
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}


	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");

		// 꼭 delete 써야힘 
	}

	/*friend String& operator+(const String& _str1, const String& _str2) {
		int len = _str1.len + _str2.len;
		char* p = new char[len];
		for (int i = 0; i < _str1.len; ++i) {
			p[i] = _str1.p[i];
		}
		for (int i = _str1.len; i < len; ++i) {
			p[i] = _str2.p[i];
		}

		String str{p};
		delete[]p;
		return str;

	}*/


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}


	string getString() const {
		return string(p, len);
	}

	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	/*
	
		** 그림 그리면서 복습해보기 ** 
		
		
	*/

	array<String, 5> news{
		"유재석이", "목숨", "걸어가지고", "만든", "걸그룹.."
	};

	관찰 = true;

	// 이렇게 자면 복사되니까 쓸데없는짓을 많이한다...
	for (String s : news) {
		cout << s << endl;

	}
	// & 를 써야한다. 
	for (String& s : news) {
		cout << s << endl;

	}

	// 꼭 레퍼런스를 넣자 .... 복사 소멸 엄청함 
	sort(news.begin(), news.end(), [](const String& a,const String& b) {
		return a.getString() < b.getString(); // 오름차순 
		});


	관찰 = false;


	save("STL.cpp");

}

#endif // STL



===============================================
STL.cpp저장시간 : 2023-04-25 화요일 오전 8:36:55
===============================================

//#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 4월 03일 TUE 23 Tue 56 ( 5주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include <string>

#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};
	char* p{}; // default nullptr 이다.  // unique_ptr<char> p 로 바꿔서 코딩하여 살려볼것 
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;

public:
	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}
	//String() = default;
	String() {
		print("디폴트 생성");
	}
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사생성자를 코딩했다면 복사할당 연산자도 반드시 코딩해야 한다.???
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}


	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");

		// 꼭 delete 써야힘 
	}

	/*friend String& operator+(const String& _str1, const String& _str2) {
		int len = _str1.len + _str2.len;
		char* p = new char[len];
		for (int i = 0; i < _str1.len; ++i) {
			p[i] = _str1.p[i];
		}
		for (int i = _str1.len; i < len; ++i) {
			p[i] = _str2.p[i];
		}

		String str{p};
		delete[]p;
		return str;

	}*/


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}


	string getString() const {
		return string(p, len);
	}

	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	/*
	
		** 그림 그리면서 복습해보기 ** 
		
		
	*/

	array<String, 5> news{
		"유재석이", "목숨", "걸어가지고", "만든", "걸그룹.."
	};

	관찰 = true;

	// 이렇게 자면 복사되니까 쓸데없는짓을 많이한다...
	for (String s : news) {
		cout << s << endl;

	}
	// & 를 써야한다. 
	for (String& s : news) {
		cout << s << endl;

	}

	// 꼭 레퍼런스를 넣자 .... 복사 소멸 엄청함 
	sort(news.begin(), news.end(), [](const String& a,const String& b) {
		return a.getString() < b.getString(); // 오름차순 
		});


	관찰 = false;


	save("STL.cpp");

}

#endif // STL



===============================================
STL.cpp저장시간 : 2023-04-25 화요일 오전 8:37:00
===============================================

//#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 4월 03일 TUE 23 Tue 56 ( 5주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include <string>

#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};
	char* p{}; // default nullptr 이다.  // unique_ptr<char> p 로 바꿔서 코딩하여 살려볼것 
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;

public:
	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}
	//String() = default;
	String() {
		print("디폴트 생성");
	}
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사생성자를 코딩했다면 복사할당 연산자도 반드시 코딩해야 한다.???
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}


	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");

		// 꼭 delete 써야힘 
	}

	/*friend String& operator+(const String& _str1, const String& _str2) {
		int len = _str1.len + _str2.len;
		char* p = new char[len];
		for (int i = 0; i < _str1.len; ++i) {
			p[i] = _str1.p[i];
		}
		for (int i = _str1.len; i < len; ++i) {
			p[i] = _str2.p[i];
		}

		String str{p};
		delete[]p;
		return str;

	}*/


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}


	string getString() const {
		return string(p, len);
	}

	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	/*
	
		** 그림 그리면서 복습해보기 ** 
		
		
	*/

	array<String, 5> news{
		"유재석이", "목숨", "걸어가지고", "만든", "걸그룹.."
	};

	관찰 = true;

	// 이렇게 자면 복사되니까 쓸데없는짓을 많이한다...
	for (String s : news) {
		cout << s << endl;

	}
	// & 를 써야한다. 
	for (String& s : news) {
		cout << s << endl;

	}

	// 꼭 레퍼런스를 넣자 .... 복사 소멸 엄청함 
	sort(news.begin(), news.end(), [](const String& a,const String& b) {
		return a.getString() < b.getString(); // 오름차순 
		});


	관찰 = false;


	save("STL.cpp");

}

#endif // STL



===============================================
STL.cpp저장시간 : 2023-04-25 화요일 오전 8:37:05
===============================================

//#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 4월 03일 TUE 23 Tue 56 ( 5주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include <string>

#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};
	char* p{}; // default nullptr 이다.  // unique_ptr<char> p 로 바꿔서 코딩하여 살려볼것 
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;

public:
	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}
	//String() = default;
	String() {
		print("디폴트 생성");
	}
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사생성자를 코딩했다면 복사할당 연산자도 반드시 코딩해야 한다.???
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}


	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");

		// 꼭 delete 써야힘 
	}

	/*friend String& operator+(const String& _str1, const String& _str2) {
		int len = _str1.len + _str2.len;
		char* p = new char[len];
		for (int i = 0; i < _str1.len; ++i) {
			p[i] = _str1.p[i];
		}
		for (int i = _str1.len; i < len; ++i) {
			p[i] = _str2.p[i];
		}

		String str{p};
		delete[]p;
		return str;

	}*/


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}


	string getString() const {
		return string(p, len);
	}

	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	/*
	
		** 그림 그리면서 복습해보기 ** 
		
		
	*/

	array<String, 5> news{
		"유재석이", "목숨", "걸어가지고", "만든", "걸그룹.."
	};

	관찰 = true;

	// 이렇게 자면 복사되니까 쓸데없는짓을 많이한다...
	for (String s : news) {
		cout << s << endl;

	}
	// & 를 써야한다. 
	for (String& s : news) {
		cout << s << endl;

	}

	// 꼭 레퍼런스를 넣자 .... 복사 소멸 엄청함 
	sort(news.begin(), news.end(), [](const String& a,const String& b) {
		return a.getString() < b.getString(); // 오름차순 
		});


	관찰 = false;


	save("STL.cpp");

}

#endif // STL



===============================================
STL.cpp저장시간 : 2023-04-25 화요일 오전 8:37:15
===============================================

//#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 4월 03일 TUE 23 Tue 56 ( 5주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include <string>

#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};
	char* p{}; // default nullptr 이다.  // unique_ptr<char> p 로 바꿔서 코딩하여 살려볼것 
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;

public:
	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}
	//String() = default;
	String() {
		print("디폴트 생성");
	}
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사생성자를 코딩했다면 복사할당 연산자도 반드시 코딩해야 한다.???
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}


	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");

		// 꼭 delete 써야힘 
	}

	/*friend String& operator+(const String& _str1, const String& _str2) {
		int len = _str1.len + _str2.len;
		char* p = new char[len];
		for (int i = 0; i < _str1.len; ++i) {
			p[i] = _str1.p[i];
		}
		for (int i = _str1.len; i < len; ++i) {
			p[i] = _str2.p[i];
		}

		String str{p};
		delete[]p;
		return str;

	}*/


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}


	string getString() const {
		return string(p, len);
	}

	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	/*
	
		** 그림 그리면서 복습해보기 ** 
		
		
	*/

	array<String, 5> news{
		"유재석이", "목숨", "걸어가지고", "만든", "걸그룹.."
	};

	관찰 = true;

	// 이렇게 자면 복사되니까 쓸데없는짓을 많이한다...
	for (String s : news) {
		cout << s << endl;

	}
	// & 를 써야한다. 
	for (String& s : news) {
		cout << s << endl;

	}

	// 꼭 레퍼런스를 넣자 .... 복사 소멸 엄청함 
	sort(news.begin(), news.end(), [](const String& a,const String& b) {
		return a.getString() < b.getString(); // 오름차순 
		});


	관찰 = false;


	save("STL.cpp");

}

#endif // STL



===============================================
STL.cpp저장시간 : 2023-04-25 화요일 오전 8:37:23
===============================================

//#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 4월 03일 TUE 23 Tue 56 ( 5주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include <string>

#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};
	char* p{}; // default nullptr 이다.  // unique_ptr<char> p 로 바꿔서 코딩하여 살려볼것 
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;

public:
	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}
	//String() = default;
	String() {
		print("디폴트 생성");
	}
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사생성자를 코딩했다면 복사할당 연산자도 반드시 코딩해야 한다.???
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}


	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");

		// 꼭 delete 써야힘 
	}

	/*friend String& operator+(const String& _str1, const String& _str2) {
		int len = _str1.len + _str2.len;
		char* p = new char[len];
		for (int i = 0; i < _str1.len; ++i) {
			p[i] = _str1.p[i];
		}
		for (int i = _str1.len; i < len; ++i) {
			p[i] = _str2.p[i];
		}

		String str{p};
		delete[]p;
		return str;

	}*/


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}


	string getString() const {
		return string(p, len);
	}

	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	/*
	
		** 그림 그리면서 복습해보기 ** 
		
		
	*/

	array<String, 5> news{
		"유재석이", "목숨", "걸어가지고", "만든", "걸그룹.."
	};

	관찰 = true;

	// 이렇게 자면 복사되니까 쓸데없는짓을 많이한다...
	for (String s : news) {
		cout << s << endl;

	}
	// & 를 써야한다. 
	for (String& s : news) {
		cout << s << endl;

	}

	// 꼭 레퍼런스를 넣자 .... 복사 소멸 엄청함 
	sort(news.begin(), news.end(), [](const String& a,const String& b) {
		return a.getString() < b.getString(); // 오름차순 
		});


	관찰 = false;


	save("STL.cpp");

}

#endif // STL



===============================================
STL.cpp저장시간 : 2023-04-25 화요일 오전 8:37:29
===============================================

//#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 4월 03일 TUE 23 Tue 56 ( 5주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include <string>

#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};
	char* p{}; // default nullptr 이다.  // unique_ptr<char> p 로 바꿔서 코딩하여 살려볼것 
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;

public:
	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}
	//String() = default;
	String() {
		print("디폴트 생성");
	}
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사생성자를 코딩했다면 복사할당 연산자도 반드시 코딩해야 한다.???
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}


	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");

		// 꼭 delete 써야힘 
	}

	/*friend String& operator+(const String& _str1, const String& _str2) {
		int len = _str1.len + _str2.len;
		char* p = new char[len];
		for (int i = 0; i < _str1.len; ++i) {
			p[i] = _str1.p[i];
		}
		for (int i = _str1.len; i < len; ++i) {
			p[i] = _str2.p[i];
		}

		String str{p};
		delete[]p;
		return str;

	}*/


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}


	string getString() const {
		return string(p, len);
	}

	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	/*
	
		** 그림 그리면서 복습해보기 ** 
		
		
	*/

	array<String, 5> news{
		"유재석이", "목숨", "걸어가지고", "만든", "걸그룹.."
	};

	관찰 = true;

	// 이렇게 자면 복사되니까 쓸데없는짓을 많이한다...
	for (String s : news) {
		cout << s << endl;

	}
	// & 를 써야한다. 
	for (String& s : news) {
		cout << s << endl;

	}

	// 꼭 레퍼런스를 넣자 .... 복사 소멸 엄청함 
	sort(news.begin(), news.end(), [](const String& a,const String& b) {
		return a.getString() < b.getString(); // 오름차순 
		});


	관찰 = false;


	save("STL.cpp");

}

#endif // STL



===============================================
STL.cpp저장시간 : 2023-04-25 화요일 오전 8:37:34
===============================================

//#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 4월 03일 TUE 23 Tue 56 ( 5주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include <string>

#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};
	char* p{}; // default nullptr 이다.  // unique_ptr<char> p 로 바꿔서 코딩하여 살려볼것 
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;

public:
	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}
	//String() = default;
	String() {
		print("디폴트 생성");
	}
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사생성자를 코딩했다면 복사할당 연산자도 반드시 코딩해야 한다.???
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}


	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");

		// 꼭 delete 써야힘 
	}

	/*friend String& operator+(const String& _str1, const String& _str2) {
		int len = _str1.len + _str2.len;
		char* p = new char[len];
		for (int i = 0; i < _str1.len; ++i) {
			p[i] = _str1.p[i];
		}
		for (int i = _str1.len; i < len; ++i) {
			p[i] = _str2.p[i];
		}

		String str{p};
		delete[]p;
		return str;

	}*/


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}


	string getString() const {
		return string(p, len);
	}

	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	/*
	
		** 그림 그리면서 복습해보기 ** 
		
		
	*/

	array<String, 5> news{
		"유재석이", "목숨", "걸어가지고", "만든", "걸그룹.."
	};

	관찰 = true;

	// 이렇게 자면 복사되니까 쓸데없는짓을 많이한다...
	for (String s : news) {
		cout << s << endl;

	}
	// & 를 써야한다. 
	for (String& s : news) {
		cout << s << endl;

	}

	// 꼭 레퍼런스를 넣자 .... 복사 소멸 엄청함 
	sort(news.begin(), news.end(), [](const String& a,const String& b) {
		return a.getString() < b.getString(); // 오름차순 
		});


	관찰 = false;


	save("STL.cpp");

}

#endif // STL



===============================================
STL.cpp저장시간 : 2023-04-25 화요일 오전 8:37:47
===============================================

//#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 4월 03일 TUE 23 Tue 56 ( 5주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include <string>

#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};
	char* p{}; // default nullptr 이다.  // unique_ptr<char> p 로 바꿔서 코딩하여 살려볼것 
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;

public:
	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}
	//String() = default;
	String() {
		print("디폴트 생성");
	}
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사생성자를 코딩했다면 복사할당 연산자도 반드시 코딩해야 한다.???
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}


	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");

		// 꼭 delete 써야힘 
	}

	/*friend String& operator+(const String& _str1, const String& _str2) {
		int len = _str1.len + _str2.len;
		char* p = new char[len];
		for (int i = 0; i < _str1.len; ++i) {
			p[i] = _str1.p[i];
		}
		for (int i = _str1.len; i < len; ++i) {
			p[i] = _str2.p[i];
		}

		String str{p};
		delete[]p;
		return str;

	}*/


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}


	string getString() const {
		return string(p, len);
	}

	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	/*
	
		** 그림 그리면서 복습해보기 ** 
		
		
	*/

	array<String, 5> news{
		"유재석이", "목숨", "걸어가지고", "만든", "걸그룹.."
	};

	관찰 = true;

	// 이렇게 자면 복사되니까 쓸데없는짓을 많이한다...
	for (String s : news) {
		cout << s << endl;

	}
	// & 를 써야한다. 
	for (String& s : news) {
		cout << s << endl;

	}

	// 꼭 레퍼런스를 넣자 .... 복사 소멸 엄청함 
	sort(news.begin(), news.end(), [](const String& a,const String& b) {
		return a.getString() < b.getString(); // 오름차순 
		});


	관찰 = false;


	save("STL.cpp");

}

#endif // STL



===============================================
STL.cpp저장시간 : 2023-04-25 화요일 오전 8:37:53
===============================================

//#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 4월 03일 TUE 23 Tue 56 ( 5주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include <string>

#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};
	char* p{}; // default nullptr 이다.  // unique_ptr<char> p 로 바꿔서 코딩하여 살려볼것 
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;

public:
	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}
	//String() = default;
	String() {
		print("디폴트 생성");
	}
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사생성자를 코딩했다면 복사할당 연산자도 반드시 코딩해야 한다.???
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}


	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");

		// 꼭 delete 써야힘 
	}

	/*friend String& operator+(const String& _str1, const String& _str2) {
		int len = _str1.len + _str2.len;
		char* p = new char[len];
		for (int i = 0; i < _str1.len; ++i) {
			p[i] = _str1.p[i];
		}
		for (int i = _str1.len; i < len; ++i) {
			p[i] = _str2.p[i];
		}

		String str{p};
		delete[]p;
		return str;

	}*/


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}


	string getString() const {
		return string(p, len);
	}

	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	/*
	
		** 그림 그리면서 복습해보기 ** 
		
		
	*/

	array<String, 5> news{
		"유재석이", "목숨", "걸어가지고", "만든", "걸그룹.."
	};

	관찰 = true;

	// 이렇게 자면 복사되니까 쓸데없는짓을 많이한다...
	for (String s : news) {
		cout << s << endl;

	}
	// & 를 써야한다. 
	for (String& s : news) {
		cout << s << endl;

	}

	// 꼭 레퍼런스를 넣자 .... 복사 소멸 엄청함 
	sort(news.begin(), news.end(), [](const String& a,const String& b) {
		return a.getString() < b.getString(); // 오름차순 
		});


	관찰 = false;


	save("STL.cpp");

}

#endif // STL



===============================================
STL.cpp저장시간 : 2023-04-25 화요일 오전 8:43:24
===============================================

//#define STL
#ifdef STL
// --------------------------------------------------
//	2023 1 학기 STL 4월 03일 TUE 23 Tue 56 ( 5주 1)
// --------------------------------------------------
//	C++ 클래스 복습 - String 클래스를 만든다.
// 앞으로 String 클래스를 STL 컨테이너로 발전시킨다. 
// --------------------------------------------------

#include <iostream>
#include <array>
#include <algorithm>
#include <string>

#include "save.h"

using namespace std;


bool 관찰{ false };


class String {
private:
	size_t len{};
	char* p{}; // default nullptr 이다.  // unique_ptr<char> p 로 바꿔서 코딩하여 살려볼것 
	size_t id = ++sid;	// 객체 고유번호 

	static size_t sid;

public:
	friend ostream& operator<<(ostream& _os, const String& _str) {
		// return _os << _str.p  << endl; // str.p 하면 안찍힌다...
		for (int i = 0; i < _str.len; ++i) {
			_os << _str.p[i];
		}
		return _os;
	}
	//String() = default;
	String() {
		print("디폴트 생성");
	}
	~String() {
		//if( p != nullptr) // 전혀 필요가 없는 코드이다. 
		print("소멸자");
		delete[] p;
	}

	String(const String& other) : len(other.len) {
		p = new char[len];
		memcpy(p, other.p, len);
		print("복사생성");
	}

	// 복사생성자를 코딩했다면 복사할당 연산자도 반드시 코딩해야 한다.???
	String& operator=(const String& other) {
		if (this == &other)
			return *this;
		delete[] p;

		len = other.len;
		p = new char[len];
		memcpy(p, other.p, len);

		print("복사할당연산자");

		return *this;

	}


	String(const char* s) : len{ strlen(s) } {
		p = new char[len]; // 동적할당은 여기서 len 이 먼저될지 p 가 먼저 될지 : 이후에 쓰면 모름 
		memcpy(p, s, len);
		print("생성(char*)");

		// 꼭 delete 써야힘 
	}

	/*friend String& operator+(const String& _str1, const String& _str2) {
		int len = _str1.len + _str2.len;
		char* p = new char[len];
		for (int i = 0; i < _str1.len; ++i) {
			p[i] = _str1.p[i];
		}
		for (int i = _str1.len; i < len; ++i) {
			p[i] = _str2.p[i];
		}

		String str{p};
		delete[]p;
		return str;

	}*/


	String operator+(const String& rhs) const // right hand side 
	{
		String temp;
		temp.len = len + rhs.len;
		temp.p = new char[temp.len];

		memcpy(temp.p, p, len);
		memcpy(temp.p + len, rhs.p, rhs.len);
		return temp;
	}


	string getString() const {
		return string(p, len);
	}

	void print(const char* msg) {

		if (관찰) {
			cout << "[" << id << "] - " << msg << ", 개수:" << len
				<< ", 주소:" << (void*)p << endl; // 형변환 해야한다. 
		}
	}


};

size_t String::sid = { 0 };

// -------	
int main()
// -------
{
	/*
	
		** 그림 그리면서 복습해보기 ** 
		
		
	*/

	array<String, 5> news{
		"유재석이", "목숨", "걸어가지고", "만든", "걸그룹.."
	};

	관찰 = true;

	// 이렇게 자면 복사되니까 쓸데없는짓을 많이한다...
	for (String s : news) {
		cout << s << endl;

	}
	// & 를 써야한다. 
	for (String& s : news) {
		cout << s << endl;

	}

	// 꼭 레퍼런스를 넣자 .... 복사 소멸 엄청함 
	sort(news.begin(), news.end(), [](const String& a,const String& b) {
		return a.getString() < b.getString(); // 오름차순 
		});


	관찰 = false;


	save("STL.cpp");

}

#endif // STL
